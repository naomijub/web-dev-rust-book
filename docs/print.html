<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Desenvolvimento Web em Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li class="chapter-item expanded "><a href="intro/1-about.html"><strong aria-hidden="true">2.</strong> Sobre autora</a></li><li class="chapter-item expanded "><a href="intro/2-Audience.html"><strong aria-hidden="true">3.</strong> Público alvo</a></li><li class="chapter-item expanded "><a href="intro/3-book.html"><strong aria-hidden="true">4.</strong> Como o livro está organizado</a></li><li class="chapter-item expanded "><a href="intro/4-setup.html"><strong aria-hidden="true">5.</strong> Instalando Rust</a></li><li class="chapter-item expanded "><a href="intro/5-exercício.html"><strong aria-hidden="true">6.</strong> Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded "><a href="part-1/00-capa.html"><strong aria-hidden="true">7.</strong> Todo Server com Actix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-1/01-ping-pong.html"><strong aria-hidden="true">7.1.</strong> Configurando os primeiros endpoints</a></li><li class="chapter-item expanded "><a href="part-1/02-create.html"><strong aria-hidden="true">7.2.</strong> Criando Tarefas</a></li><li class="chapter-item expanded "><a href="part-1/03-get.html"><strong aria-hidden="true">7.3.</strong> Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded "><a href="part-1/04-serving.html"><strong aria-hidden="true">7.4.</strong> Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded "><a href="part-1/05-auth.html"><strong aria-hidden="true">7.5.</strong> Autenticação</a></li><li class="chapter-item expanded "><a href="part-1/06-middleware.html"><strong aria-hidden="true">7.6.</strong> Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded "><a href="part-1/07-ci.html"><strong aria-hidden="true">7.7.</strong> Configurando um CI</a></li><li class="chapter-item expanded "><a href="part-1/08-conclusao.html"><strong aria-hidden="true">7.8.</strong> Concluindo o serviço</a></li></ol></li><li class="chapter-item expanded "><a href="part-2/00-capa.html"><strong aria-hidden="true">8.</strong> GraphQL com Actix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-2/01-ping-gql.html"><strong aria-hidden="true">8.1.</strong> Configurando o GraphQL</a></li><li class="chapter-item expanded "><a href="part-2/02-bestprices.html"><strong aria-hidden="true">8.2.</strong> Query Best Prices</a></li><li class="chapter-item expanded "><a href="part-2/03-recommendations.html"><strong aria-hidden="true">8.3.</strong> Query Recommendations</a></li><li class="chapter-item expanded "><a href="part-2/04-redis.html"><strong aria-hidden="true">8.4.</strong> Adicionando Caching com Redis</a></li></ol></li><li class="chapter-item expanded "><a href="part-3/00-capa.html"><strong aria-hidden="true">9.</strong> Frontend com WebAssembly e YewStack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-3/01-setup.html"><strong aria-hidden="true">9.1.</strong> Setup de WebAssembly</a></li><li class="chapter-item expanded "><a href="part-3/02-iniciando.html"><strong aria-hidden="true">9.2.</strong> Iniciando o projeto</a></li><li class="chapter-item expanded "><a href="part-3/03-best-prices.html"><strong aria-hidden="true">9.3.</strong> Componente de Best Prices</a></li><li class="chapter-item expanded "><a href="part-3/04-recommendations.html"><strong aria-hidden="true">9.4.</strong> Componente de Recomendações</a></li><li class="chapter-item expanded "><a href="part-3/05-route.html"><strong aria-hidden="true">9.5.</strong> Aplicando um Router</a></li></ol></li><li class="chapter-item expanded "><a href="appendix.html"><strong aria-hidden="true">10.</strong> Appendix</a></li><li class="chapter-item expanded "><a href="bibliografia.html"><strong aria-hidden="true">11.</strong> Bibliografia</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="desenvolvimento-web-com-rust"><a class="header" href="#desenvolvimento-web-com-rust">Desenvolvimento Web com Rust</a></h1>
<p>Por Julia Naomi Boeira.</p>
<p><a href="https://www.patreon.com/naomijub"><img src="https://media.giphy.com/media/FOe2EcTuBYGbG0Yc3w/giphy.gif" alt="" /></a> <br/>
<a href="https://www.patreon.com/naomijub">Patreon link</a></p>
<h2 id="tecnologias"><a class="header" href="#tecnologias">Tecnologias:</a></h2>
<ul>
<li>Actix</li>
<li>Yew</li>
<li>Wasm</li>
<li>Graphql</li>
<li>Rest</li>
<li>Redis</li>
<li>DynamoDB</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sobre-a-autora"><a class="header" href="#sobre-a-autora">Sobre a autora</a></h1>
<p>Julia Naomi Boeira é uma engenheira de software com experiência em programação funcional e concorrente, games e sistemas distribuídos. Atualmente trabalha com open source em Rust e C++. Algumas empresas em seu currículo são Ubisoft, Creditas, Chorus One, Nubank, Thoughtworks, Latam e Globo.com.</p>
<p>Por este livro, agradeço ao Otávio Pace, ao Bruno Tavares e ao pessoal da Rust in Poa (Julio Biason, Douglas, Ruan Nunes e a todos os exercícios do Exercism.io que fizemos).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audiência"><a class="header" href="#audiência">Audiência</a></h1>
<p>Este livro é para todas as pessoas que estão cansadas de lidar com projetos gigantes e arcaicos, com frameworks burocráticos e que têm muita dor de cabeça na hora de otimizar o código. Rust é uma linguagem de programação de baixo nível, como C, mas com abstrações de alto nível, como Ruby e JavaScript, que garante segurança na criação de processos e evita que threads diferentes concorram e mutem os mesmos dados ao mesmo tempo. Além disso, Rust cuida para ter duas características principais, uma comunidade inclusiva e uma linguagem de fácil entendimento, isso se mostra através dos milhares de livros completíssimos para aprender Rust e suas ferramentas. Infelizmente as partes de <code>macros</code>, <code>borrow checker</code> e <code>lifetimes</code> não são tão simples de aprender — acredito que sejam as partes mais difíceis do Rust —, mas acredito que o <code>borrow checker</code> será a única parte que você precisará conviver diariamente.</p>
<p>Existem alguns grandes casos de uso de Rust em produção, tirando a Mozilla, empresa criadora da linguagem e hoje uma das principais mantenedoras dela. Os maiores casos são:</p>
<ul>
<li><strong>NPM</strong> - Escalando um serviço ligado a CPU com bilhões de requests. Rust foi escolhido entre C, C++, Java e Go. C e C++ foram descartados devido à insegurança a nível de memória, Java por conta da necessidade de deployar a JVM e Go por ter tido uma performance pior que Rust com muito mais trabalho em relação a ferramental básico.</li>
<li><strong>Tilde</strong> - Tilde fez seu MVP para monitoramento do espaço com Ruby on Rails, mas infelizmente a quantidade brutal de memória consumida fazia com que eles não tivessem competitividade do produto. Avaliando uma solução em C++, perceberam que a quantidade de crashes podia aumentar exponencialmente e que treinar uma equipe rubysta para manter um código C++ era bem complicado. Foi aí que entrou o Rust, a ausência de coletor de lixo e a segurança em memória garantiram a performance que o projeto queria.</li>
<li><strong>Dropbox</strong> - Para a Dropbox, o diferencial do uso de Rust foi desenvolver um serviço que aumentasse a velocidade de entrega e que diminuísse o espaço consumido. Rust com seu runtime quase mínimo e sua performance excepcional foi a solução preferida.</li>
<li><strong>Discord</strong> - Quando o Elixir para de performar bem para a quantidade de dados que você precisa processar, está na hora de delegar esse processamento para quem é bom nisso. No caso do Discord foi o Rust.</li>
</ul>
<p>Ou seja, Rust é ideal para quem quer produzir serviços com performance excepcional, uma linguagem simples, pouco consumo de memória e muita felicidade. Acredito que seja um livro para pessoas que pelo menos já brincaram um ou dois dias com Rust, mas caso seja necessário, recomendo conferir os livros da documentação oficial e os maravilhosos livros que a Casa do Código possui sobre Rust antes de ler este.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="como-este-livro-é-organizado"><a class="header" href="#como-este-livro-é-organizado">Como este livro é organizado</a></h1>
<p>Nos capítulos de introdução teremos um guia de instalação e um exercício básico. Nosso primeiro projeto será um servidor de gerenciamento de tarefas baseado em Actix Web. Actix Web é um framework de desenvolvimento web em Rust que tem feito muito barulho por suas constantes primeiras colocações em benchmarks de performance, principalmente da TechEmpower, e por algumas confusões pelo uso de <code>unsafe</code>. Acredito que o framework seja bastante simples de entender e muito completo, mais informações sobre os benchmarks no apêndice A. Vamos utilizar diversas ferramentas da stack Actix para garantir um serviço completo e algumas ferramentas clássicas da comunidade Rust, como Serde para serialização de JSON e clientes de bancos de dados. Para este projeto vamos utilizar DynamoDB como banco de dados via biblioteca Rusoto para salvar os dados de gerenciamento de tarefas e Postgres com Diesel para salvar informações de autorização. O padrão de arquitetura de software utilizado para esta parte é inspirado no framework Phoenix do Elixir. </p>
<p>Na segunda parte, vamos modelar um serviço que retorna valores e rotas de passagens aéreas via queries GraphQL. Esse serviço realizará requests para serviços reais e será desenvolvido no padrão de arquitetura Hexagonal, ou, como também é conhecido, Cebola, que é inspirado no livro <strong>Clean Architecture</strong> de Robert C. Martin. A idéia central deste padrão é separarmos funções puras na parte mais interna da arquitetura e funções impuras na parte mais externa. Na terceira parte do livro, que está associada à parte anterior, construiremos um front-end utilizando a Yew Stack, que é baseada em WebAssembly, para a representação das opções de passagens. Lembrando que HTML e CSS serão mantidos de forma primitiva por não serem o foco deste livro.</p>
<ul>
<li>Para a parte 2 do livro, recomendo conhecer os conceitos de GraphQL. Livros e tutoriais estão indicados na bibliografia. </li>
<li>Para a parte 3 do livro, recomendo conhecer os conceitos de WebAssembly. O livro oficial gratuito está indicado na bibliografia.</li>
</ul>
<h3 id="por-que-utilizar-o-dynamodb"><a class="header" href="#por-que-utilizar-o-dynamodb">Por que utilizar o DynamoDB</a></h3>
<p>Existem dois motivos para eu ter escolhido utilizar o DynamoDB para nosso serviço.</p>
<ol>
<li>Existem centenas de ótimos exemplos utilizando o banco Postgres com a crate Diesel. Inclusive integrados com AWS e em português. Além do mais, vamos utilizar o Postgres com Diesel, só que não como nosso principal banco de dados, já que é bastante comum aplicações diferentes possuirem mais de um tipo de banco de dados. A escolha do Diesel para o middleware de autorização não tem nenhuma relação com segurança ou performance, foi somente o recurso que me ocorreu usar no momento.</li>
<li>Em um mundo cada vez mais voltado para cloud, escolher uma tecnologia nativa de cloud parece uma boa solução.
Agora, isso não quer dizer que o DynamoDB seja o banco que modela perfeitamente nosso domínio ou as relações entre ele, mas é um banco com uma performance excepcional que permite muita flexibilidade ao modelar domínios. Alguns limites associados a transações e tipos no DynamoDB:</li>
</ol>
<ul>
<li>O tamanho máximo de uma String é limitada a 400KB, assim como para binários. </li>
<li>Uma String de expressão pode ter no máximo 4KB.</li>
<li>Uma transação não pode conter mais de 25 itens únicos, assim como não pode conter mais de 25MB de dados.</li>
<li>É possível ter até 50 requests simultâneos para criar, atualizar ou deletar tabelas.</li>
<li><code>BatchGetItem</code>, buscar um conjunto de itens pode trazer no máximo 100 itens e um total de 16MB de dados.</li>
<li><code>BatchWriteItem</code>, como <code>PutItem</code> e <code>DeleteItem</code>, pode conter até 25 itens e um total de 16MB de dados.</li>
<li><code>Query</code> e <code>Scan</code> tem um limite de 1MB por chamada.</li>
</ul>
<h3 id="phoenix-mvc"><a class="header" href="#phoenix-mvc">Phoenix MVC</a></h3>
<p>O que eu gosto no modelo que o Phoenix utiliza para organizar seus módulos é a divisão entre a lógica web e a lógica core, ou seja, ele separa a camada de comunicação com o mundo da camada de comunicação interna. Por exemplo, uma API chamada de <code>TodoApi</code> vai possuir módulos com os nomes <code>todo_api_web</code> para a lógica web e <code>todo_api</code> para a lógica core. O formato interno do <code>todo_api_web</code> é bastante comum e geralmente utiliza a nomenclatura do MVC, na qual seus modelos representando o domínio estão dentro de um módulo chamado <code>models</code>; seus operadores entre camadas, geralmente sem lógica, ou controllers, estão em um módulo chamado <code>controllers</code>, e as visualizações das telas estão em um módulo chamado <code>views</code>. Caso você esteja utilizando GraphQL, a divisão do MVC pode ficar um pouco diferente, como <code>queries</code> e <code>mutations</code> em um módulo de <code>schemas</code>, seus objetos de entrada e saída em um módulo chamado <code>models</code> e seus resolvers em um módulo <code>resolvers</code>. Seria esse padrão o <code>MRS</code> (<em>Models Resolvers Schema</em>)?</p>
<p>Quanto ao módulo <code>todo_api</code>, ele estaria organizado em um módulo para gerenciar a fonte dos dados, geralmente denominado <code>repo</code> ou <code>db</code>, e em um outro módulo para organizar as estruturas de dados correspondentes chamado de <code>models</code>. Aqui é comum existir uma camada que adapta os modelos de <code>todo_api</code> para <code>todo_api_web</code>, geralmente chamado de <code>adapters</code>. Para serviços que se comunicam por mensagens, é comum um módulo <code>message</code> aqui também. Resumindo graficamente seria:</p>
<pre><code>todo_api
    main
    |-&gt; todo_api
        |-&gt; adapters
        |-&gt; db (ou repo)
        |-&gt; message
        |-&gt; models
    |-&gt; todo_api_web
        |-&gt; controllers
        |-&gt; http (configurações do sistema e middlewares)
        |-&gt; models
        |-&gt; routes (rotas do sistema)
        |-&gt; views
</code></pre>
<h3 id="hexagonal"><a class="header" href="#hexagonal">Hexagonal</a></h3>
<p>O modelo hexagonal é mais simples em organização, e talvez mais fácil para quem estiver começando a trabalhar em um sistema, mas talvez menos prático para quem já conhece o sistema. Ele consiste em algumas camadas que vão das camadas impuras com efeitos colaterais chamadas de <code>boundaries</code> ou <code>diplomat</code> até as camadas mais puras chamadas de <code>core</code> ou <code>logic</code>, assim como as camadas de modelagem. No módulo <code>boundaries</code> vamos ter coisas como <code>web</code>, <code>db</code> e <code>messaging</code>, ou seja, qualquer coisa que cause efeitos colaterais. Depois disso vamos ter uma camada que recebe esses efeitos colaterais e chama funções puras para lidar com eles, comumente chamado de <code>controllers</code>. Os <code>controllers</code> utilizam principalmente duas camadas para tratar os efeitos colaterais, a camada de <code>adapters</code>, que transforma as entidades de <code>boundaries</code> em entidades internas, e a camada de <code>core</code>, que é dona de toda lógica do sistema, <code>core</code> pode ainda possuir uma separação de negócio, <code>business</code>, e outra computacional ou de apoio, <code>compute</code>. Por último, a parte mais interna são os <code>models</code>, que correspondem a estrutura de dados do sistema. Resumindo graficamente, em ordem de mais impura até mais pura, seria:</p>
<pre><code>todo_api
    main
    |-&gt; boundaries
        |-&gt; web
        |-&gt; db
        |-&gt; message
    |-&gt; controllers/resolvers
    |-&gt; adapters
    |-&gt; core 
        |-&gt; business
        |-&gt; compute
    |-&gt; models/schemas
</code></pre>
<h3 id="considerações"><a class="header" href="#considerações">Considerações</a></h3>
<ul>
<li>
<p>Qual nomenclatura ou quais nomes específicos você vai dar para seus módulos é menos relevante do que a forma como as coisas estarão organizadas, a única coisa importante de lembrar é a necessidade de seu código e sua organização ser inteligível para todas as pessoas.</p>
</li>
<li>
<p>Este livro utiliza apenas o framework Actix para servidores web, mas exemplos com outros frameworks podem ser encontrados no livro <code>Programação Funcional e Concorrente em Rust</code>. Actix é o framework de <code>actors</code> do Rust, e tem como framework web o <code>actix-web</code>. </p>
</li>
<li>
<p>A versão de Rust utilizada neste livro é a 1.40 da edição 2018, assim, caso a linguagem evolua mais rápido que o livro, você pode fazer Pull Request nos repositórios do livro. Só peço que explique no Pull Request a que parte ele se refere, qual a modificação, o porquê da modificação e caso ela derive de um erro preexistente, salientar o motivo. Algumas modificações na organização e renomeação de arquivos podem ser bastante interessantes também.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instalando-rust"><a class="header" href="#instalando-rust">Instalando Rust</a></h1>
<p>O primeiro passo para instalar Rust é a instalação do <code>rustup</code>, uma ferramenta de linha de comando para gerenciar versões do Rust e todo ferramental a sua volta. Para fazer download do <code>rustup</code> em Linux e macOS, basta digitar <code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code> em seu terminal e seguir as instruções. Para a instalação em Windows, basta ir ao site https://www.rust-lang.org/tools/install e garantir que você possui o <code>C++ build tools for Visual Studio 2013</code> ou posterior instalado em sua máquina. </p>
<p>Para atualizar o <code>rustup</code>, basta digitar <code>rustup update</code> em seu terminal e, para desinstalar o Rust, <code>rustup self uninstall</code>. Caso você precise saber a versão do Rust, basta digitar <code>rustc --version</code> e você verá a resposta no formato <code>rustc x.y.z (abcabcabc yyyy-mm-dd)</code>, na qual <code>x.y.z</code> correspondente à versão, <code>abcabcabc</code> ao commit da versão <code>x.y.z</code> e <code>yyyy-mm-dd</code> à data da versão <code>x.y.z</code>. Se estiver desconectada da internet e quiser ver a documentação, basta digitar <code>rustup doc</code>.</p>
<p>Não esqueça de experimentar a utilização do <code>cargo</code>, gerenciador de pacotes e de build do Rust. Para ver se ele está bem em sua máquina, basta digitar <code>cargo --version</code>. Para criar um pacote, você pode digitar <code>cargo new &lt;nome do pacote&gt; --lib</code> e, para criar um executável, você pode digitar <code>cargo new &lt;nome do executável&gt; --bin</code>. Caso você omita as opções <code>--lib</code> e <code>--bin</code>, o padrão atual é criar um executável. </p>
<p>A minha experiência de desenvolvimento Rust tem sido muito agradável com o Racer e o RLS configurados no VSCode ou no emacs. Para o VSCode, basta adicionar os plugins <code>Rust</code> e <code>Rust (rls)</code>. Caso seu path do cargo tenha algum problema, será necessário apontar o caminho para o <code>racer</code> dentro do pacote do <code>cargo</code>.</p>
<p>Pronto, agora podemos resolver um exercício básico.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercício-maior-produto-de-uma-série"><a class="header" href="#exercício-maior-produto-de-uma-série">Exercício Maior Produto de uma Série</a></h1>
<p>Este exercício é retirado do site exercism.io da track de Rust, e em inglês é chamado de <em>Largest Series Product</em>. Ele consiste no seguinte problema:</p>
<blockquote>
<p>Dada uma string de dígitos, calcular o maior produto contínuo de uma substring de tamanho <code>n</code>. Por exemplo, para a string <code>&quot;1027839564&quot;</code> o maior produto com <code>n = 3</code> seria <code>9 * 5 * 6 = 270</code>, e o maior produto para <code>n = 5</code> seria <code>7 * 8 * 3 * 9 * 5 = 7560</code>.</p>
</blockquote>
<p>Você pode utilizar a ferramenta do exercism.io para realizar as configurações deste exercício. Para isso, pule para o subcapítulo <strong>Resolvendo o primeiro teste</strong>. Bom, a primeira coisa que precisamos fazer é criar uma lib para rodar esses testes. Para isso, executamos em nosso terminal <code>cargo new largest-series-product --lib &amp;&amp; cd largest-series-product</code>. Abra em seu editor favorito e seu projeto deverá ser da seguinte forma:</p>
<p><img src="intro/../imagens/cargoproj.png" alt="Projeto de pacote básico do Cargo" /></p>
<p>Agora, precisamos criar uma pasta para conter todos os testes, a pasta <code>tests</code>. O padrão em Rust é que os testes de integração fiquem na pasta <code>tests</code> enquanto os testes unitários fiquem junto ao arquivo. Como o exercism já nos dispõe um conjunto bom de testes, podemos simplesmente colar eles no caminho <code>tests/largest-series-product.rs</code>. Os testes são:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use largest_series_product::*;

#[test]
fn return_is_a_result() {
    assert!(lsp(&quot;29&quot;, 2).is_ok());
}

#[test]
#[ignore]
fn find_the_largest_product_when_span_equals_length() {
    assert_eq!(Ok(18), lsp(&quot;29&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_two_with_numbers_in_order() {
    assert_eq!(Ok(72), lsp(&quot;0123456789&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_two_with_numbers_not_in_order() {
    assert_eq!(Ok(48), lsp(&quot;576802143&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_three_with_numbers_in_order() {
    assert_eq!(Ok(504), lsp(&quot;0123456789&quot;, 3));
}

#[test]
#[ignore]
fn find_the_largest_product_of_three_with_numbers_not_in_order() {
    assert_eq!(Ok(270), lsp(&quot;1027839564&quot;, 3));
}

#[test]
#[ignore]
fn find_the_largest_product_of_five_with_numbers_in_order() {
    assert_eq!(Ok(15120), lsp(&quot;0123456789&quot;, 5));
}

#[test]
#[ignore]
fn span_of_six_in_a_large_number() {
    assert_eq!(
        Ok(23520),
        lsp(&quot;73167176531330624919225119674426574742355349194934&quot;, 6)
    );
}

#[test]
#[ignore]
fn returns_zero_if_number_is_zeros() {
    assert_eq!(Ok(0), lsp(&quot;0000&quot;, 2));
}

#[test]
#[ignore]
fn returns_zero_if_all_products_are_zero() {
    assert_eq!(Ok(0), lsp(&quot;99099&quot;, 3));
}

#[test]
#[ignore]
fn a_span_is_longer_than_number_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;123&quot;, 4));
}

// There may be some confusion about whether this should be 1 or error.
// The reasoning for it being 1 is this:
// There is one 0-character string contained in the empty string.
// That's the empty string itself.
// The empty product is 1 (the identity for multiplication).
// Therefore LSP('', 0) is 1.
// It's NOT the case that LSP('', 0) takes max of an empty list.
// So there is no error.
// Compare against LSP('123', 4):
// There are zero 4-character strings in '123'.
// So LSP('123', 4) really DOES take the max of an empty list.
// So LSP('123', 4) errors and LSP('', 0) does NOT.
#[test]
#[ignore]
fn an_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;&quot;, 0));
}

#[test]
#[ignore]
fn a_non_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;123&quot;, 0));
}

#[test]
#[ignore]
fn empty_string_and_non_zero_span_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;&quot;, 1));
}

#[test]
#[ignore]
fn a_string_with_non_digits_is_an_error() {
    assert_eq!(Err(Error::InvalidDigit('a')), lsp(&quot;1234a5&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos explicar rapidamente o que estamos vendo aqui. A primeira linha contém <code>use largest_series_product::*;</code>, isso corresponde a uma diretiva de importar todas as funcionalidades (<code>::*</code>) do pacote <code>largest_series_product</code>. Poderíamos importar somente a diretiva <code>lsp</code> com <code>use largest_series_product::lsp;</code> ou mais de uma diretiva com <code>use largest_series_product::{lsp, db::xps}</code>. Note que a diretiva <code>xps</code> vem de um pacote interno chamado <code>db</code>. Nas linhas seguintes, percebemos as anotações <code>#[test]</code> e <code>#[ignore]</code>, consideradas atributos que indicam como essa função deve se comportar. No caso do atributo <code>#[test]</code>, a função descrita a seguir executará somente com a execução de testes no <code>cargo test</code>, enquanto o atributo <code>#[ignore]</code>, pulará esse teste. Depois disso, temos a declaração de uma função com o seguinte formato:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nome_da_funcao_em_snake_case() {
    //corpo da funcnao
    // ...
}
 pub fn nome_da_funcao_em_snake_case(arg1: TArgs1, arg2: TArgs2, // ... argn: TArgsn) -&gt; TResposta {
     //corpo da funcnao
    // ...
 }
<span class="boring">}
</span></code></pre></pre>
<p>Em Rust, a declaração de uma função começa com a palavra-chave <code>fn</code> seguida pelo nome da função em snake_case. Caso existam, os argumentos são separados como <code>argumento: TipoDoArgument</code> e, caso a função retorne algum tipo, se adiciona a linha <code>-&gt; TipoDeRetorno</code>. A última linha da função, caso não tenha <code>;</code> no final é sempre retornada. Agora para o corpo da função de teste vemos <code>assert!(lsp(&quot;29&quot;, 2).is_ok());</code>. <code>assert!</code> e <code>assert_eq!</code> são macros de teste de assertividade, isso quer dizer que <code>assert!</code> retorna verdade caso o argumento dentro de seu corpo seja verdadeiro, como lsp de 29 e duas casas é do tipo <code>Ok</code> (<code>lsp(&quot;29&quot;, 2).is_ok()</code>), e <code>assert_eq!</code> recebe dois argumentos, separados por vírgula e procura igualdade e identidade entre eles.</p>
<h2 id="resolvendo-o-primeiro-teste"><a class="header" href="#resolvendo-o-primeiro-teste">Resolvendo o primeiro teste</a></h2>
<p>Vamos para a primeira função que temos e vamos tentar dissecá-la:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn return_is_a_result() {
   assert!(lsp(&quot;29&quot;, 2).is_ok());
}
<span class="boring">}
</span></code></pre></pre>
<p>Sabemos que é uma função de teste, <code>#[test]</code>, e que existe uma chamada para função <code>lsp</code> que recebe dois argumentos, <code>&quot;29&quot;</code> (um <code>&amp;str</code>) e <code>2</code> (um <code>inteiro</code>). Além disso, sabemos que retorna um tipo <code>Result</code>, pois estamos esperando um resultado do tipo <code>Ok</code>. Para este teste passar precisamos fazer muito pouco, assim a implementação dele passa a ser:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub enum Error {
    SpanTooLong,
    InvalidDigit(char),
}

pub fn lsp(_: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    Ok(0u64)
}
<span class="boring">}
</span></code></pre></pre>
<p>Tanto faz o valor que retornamos para esse teste, pois somente queremos saber se é <code>Ok()</code>. Agora removemos o <code>#[ignore]</code> do teste a seguir e mudamos nosso <code>Ok(0u64)</code> para <code>Ok(18u64)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_when_span_equals_length() {
    assert_eq!(Ok(18), lsp(&quot;29&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>O próximo teste nos exige um pouco mais:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_two_with_numbers_in_order() {
    assert_eq!(Ok(72), lsp(&quot;0123456789&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para este teste podemos pegar os dois últimos números da string e multiplicá-los.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    let mut digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
    digits.reverse();
    Ok(digits.iter().take(2).fold(1u64, |acc, i| acc * i))
}
<span class="boring">}
</span></code></pre></pre>
<p>Como sabemos que os dois últimos dígitos de ambos os casos são o maior produto, não precisamos nos preocupar muito com o resto. Assim, aplicamos a função <code>split(&quot;&quot;)</code> ao valor de entrada, que gerará um vetor contendo cada um dos elementos, como <code>vec![&quot;2&quot;, &quot;9&quot;]</code>, para o caso do <code>&quot;29&quot;</code>. Depois aplicamos um <code>parse</code> deles para o tipo inferido em <code>let mut digits: Vec&lt;u64&gt; =</code>, filtramos para evitar elementos que resultaram em <code>Err</code> e assim podemos utilizar o <code>unwrap</code> sem problemas. Coletamos tudo com o <code>collect</code> e revertemos a lista para obter somente os dois primeiros elementos, que após o <code>reverse</code> passaram de últimos a primeiros. Depois aplicamos o <code>.fold(1u64, |acc, i| acc * i))</code>, que inicia a multiplicação com um <code>1u64</code>, e depois multiplicamos cada um deles pelo acumulador <code>acc</code>. Tudo isso envolvido em um <code>Ok()</code>. Existem formas mais simples de resolver esse problema em Rust, como o uso de <code>slices</code>, mas acredito que seja uma boa solução para quem precisa revisar a linguagem.</p>
<p>Ao rodarmos o próximo teste, podemos perceber que nossa estratégia falha e que novas implementações são necessárias:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_two_with_numbers_not_in_order() {
    assert_eq!(Ok(48), lsp(&quot;576802143&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Felizmente parte de nossa solução, a variável <code>digits</code>, já é bastante útil, pois converteu a <code>&amp;str</code> em um vetor de <code>u64</code>. Agora precisamos de uma função que atue sobre os vetores e agrupe-os de dois em dois. Para poupar nosso tempo, a implementacão de <code>Vec</code> em Rust já possui uma função assim, ela chama <code>window</code> e recebe como argumento um <code>self</code> e um span do tipo <code>usize</code>, retornando um <code>Window&lt;T&gt;</code>, no qual <code>T</code> representa um genérico correspondente ao tipo do vetor. A struct <code>Window&lt;T&gt;</code> corresponde a um iterável com valores internos do tipo slice com o tamanho de cada slice do valor span <code>usize</code>, se fossemos comparar a um vetor seria um <code>vec![ &amp;[&quot;a&quot;, &quot;b&quot;], &amp;[&quot;b&quot;, &quot;c&quot;], &amp;[&quot;c&quot;, &quot;d&quot;], // ...]</code> para o afaltabeto separado <code>2usize</code>. Agora, precisamos de uma função que nos retorne o valor de cada <code>Window</code> e ordene os valores de forma que o maior seja o primeiro ou o último. Chamei essa função de <code>window_values</code>, e ela recebe como argumento o vetor que criamos anteriormente, <code>digits: Vec&lt;u64&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    let digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
            
    Ok(window_values(digits)
        .first()
        .unwrap()
        .to_owned())
}

fn window_values(digits: Vec&lt;u64&gt;) -&gt; Vec&lt;u64&gt; {
    let mut window_values = digits
        .windows(2usize)
        .map(|w| w.to_vec())
        .map(|v| v.iter().fold(1,|acc, i| acc * i))
        .collect::&lt;Vec&lt;u64&gt;&gt;();
    window_values.sort();
    window_values.reverse();
    window_values
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que a função <code>lsp</code> não mudou muito, o que mudou nela é que chamamos a função <code>window_values</code> com o <code>digits</code>, que deixou de ser mutável. Na função <code>window_values</code>, estamos criando windows de tamanho <code>2usize</code>, depois aplicando <code>map</code> para converter o tipo <code>&amp;[T;usize]</code> em vetor e, no <code>map</code> seguinte, transformamos esse vetor gerado em um iterável que consome eles em um fold de multiplicação. Depois ordenamos a lista de maior para menor, e depois revertemos para termos o maior produto como primeiro elemento (podíamos deixar sem o reverse e aplicar um <code>last</code> em vez de <code>first</code> à solução da função). A chamada de função <code>to_owned</code> ocorre porque o resultado do first é um <em>borrow</em>, ou seja <code>&amp;u64</code> e precisamos de um <code>u64</code>.</p>
<p>O próximo teste inclui apenas uma diferença: o valor de <code>span</code> deixa de ser <code>2</code> e passa a ser <code>3</code>. Para isso, precisamos passar span como argumento para <code>window_values</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_three_with_numbers_in_order() {
    assert_eq!(Ok(504), lsp(&quot;0123456789&quot;, 3));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora a solução passa a ser (note o valor <code>span</code> adicionado nas funções):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}

fn window_values(digits: Vec&lt;u64&gt;, span: usize) -&gt; Vec&lt;u64&gt; {
    let mut str_chunks = digits
        .windows(span)
        .map(|x| x.to_vec())
        .map(|i| i.iter().fold(1,|acc, x| acc * x))
        .collect::&lt;Vec&lt;u64&gt;&gt;();
    str_chunks.sort();
    str_chunks.reverse();
    str_chunks
}
<span class="boring">}
</span></code></pre></pre>
<p>Com essas mudanças, os próximos três testes passam sem grandes esforços:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_three_with_numbers_not_in_order() {
    assert_eq!(Ok(270), lsp(&quot;1027839564&quot;, 3));
}

#[test]
fn find_the_largest_product_of_five_with_numbers_in_order() {
    assert_eq!(Ok(15120), lsp(&quot;0123456789&quot;, 5));
}

#[test]
fn span_of_six_in_a_large_number() {
    assert_eq!(
        Ok(23520),
        lsp(&quot;73167176531330624919225119674426574742355349194934&quot;, 6)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Os testes seguintes também passam, mas quis separá-los para chamar a atenção em relação aos <code>0</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn returns_zero_if_number_is_zeros() {
    assert_eq!(Ok(0), lsp(&quot;0000&quot;, 2));
}

#[test]
fn returns_zero_if_all_products_are_zero() {
    assert_eq!(Ok(0), lsp(&quot;99099&quot;, 3));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, o próximo teste já falha, pois apesar de termos a implementação do tipo <code>Error</code>, não estamos usando o <code>Error</code>. Note que o teste consiste em retornar um Result<Err> por conta do tamanho da <code>window</code> ser maior que o tamanho total das strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn a_span_is_longer_than_number_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;123&quot;, 4));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos adicionar um <code>if</code> que valida se o tamanho da string é maior que o tamanho da <code>window</code>. <code>span &gt; string_digits.len()</code> e que caso verdadeiro retorne <code>Err(Error::SpanTooLong)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    SpanTooLong,
    InvalidDigit(char),
}

pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }

    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Os próximos dois testes se referem à mesma coisa. Se o valor do <code>span</code> for zero, o resultado sempre será <code>Ok(1u64)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn an_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;&quot;, 0));
}

#[test]
fn a_non_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;123&quot;, 0));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver esse teste basta adicionar mais um <code>if</code>, <code>if span == 0 { return Ok(1u64); }</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }

    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, o teste seguinte também passa:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn empty_string_and_non_zero_span_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;&quot;, 1));
}
<span class="boring">}
</span></code></pre></pre>
<p>O próximo e último teste traz um novo conceito: falha por conta de um dígito não válido, como um caractere alfabético. Vamos incluir este caractere como argumento do erro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn a_string_with_non_digits_is_an_error() {
    assert_eq!(Err(Error::InvalidDigit('a')), lsp(&quot;1234a5&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver esse teste precisamos fazer um <code>match</code> por tipos alfabéticos e retornar o primeiro que falha. O <code>if</code> que garante que existe uma falha é <code>if string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;().len() &gt; 0</code> e assim bastaria adicionar o seguinte código a <code>lsp</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }
    else if string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;().len() &gt; 0 {
        let digit = string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;();
        return Err(Error::InvalidDigit(digit
                .first().unwrap()
                .to_owned()
                .to_string()
                .pop().unwrap()));
    }

    let digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, com o resultado de <code>string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;()</code> podemos obter o primeiro com <code>first</code>, e depois aplicar o <code>pop</code> para retirar o valor de <code>char</code>. Além disso, podemos perceber que a conta <code>string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;()</code> está sendo executada duas vezes, assim podemos extrair para um valor, <code>v_alphanumeric</code>, antes dos ifs/elses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    let v_alphanumeric = string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;();
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }
    else if v_alphanumeric.len() &gt; 0 {
        return Err(Error::InvalidDigit(v_alphanumeric
                .first().unwrap()
                .to_owned()
                .to_string()
                .pop().unwrap()));
    }
// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora que revisamos Rust podemos iniciar nosso primeiro serviço.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-server-com-actix"><a class="header" href="#todo-server-com-actix">Todo Server com Actix</a></h1>
<p>Nesta primeira parte vamos desenvolver um Todo Server aplicando um modelo semelhante ao MVC do projeto Phoenix, da comunidade Elixir. Este modelo foi explicado no capítulo <code>Como este livro é organizado</code>, mas agora vamos detalhar um pouco quais serão as características deste serviço.</p>
<p>Vamos criar um RESTful Todo Server que seria facilmente utilizado em produção pois contará com uma série de recursos como:</p>
<ol>
<li>Endpoints de monitoramento:
<ul>
<li><code>ping</code> que funciona como <code>health check</code>.</li>
<li><code>~/ready</code> que funciona como disponibilidade do servico, <code>readiness probe</code>.</li>
</ul>
</li>
<li>Endpoints para salvar as informações dos <code>TODO</code>s, <code>create</code> <code>show</code> <code>show-by-id</code> e <code>update</code>.</li>
<li>Sistema de logs, headers padrão e middlewares de autenticação.</li>
<li>Endpoints de autenticação, com <code>signup</code>, <code>login</code> e <code>logout</code> utilizando tokens <code>JWT</code> e banco de dados Postgres via Diesel.</li>
<li>Bastion para tornar o sistema tolerante a falhas.</li>
<li>Dockerização de todos os serviços.</li>
<li>CI executando as pipelines de teste.</li>
<li>Serde para serialização e deserialização de Json.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configurando-os-primeiros-endpoints"><a class="header" href="#configurando-os-primeiros-endpoints">Configurando os primeiros endpoints</a></h1>
<p>O nosso objetivo inicial é fazer nosso servidor responder <code>pong</code> na rota <code>/ping</code> e executar uma função de baixo custo na rota <code>/~/ready</code> retornando 200 ou algum valor de status superior a 400, bastante simples. O objetivo disso é definir em nosso servidor endpoints que respondam se o servidor está disponível e saudável, <code>/ping</code>, assim como responder se esta pronto para executar mais uma operação, <code>/~/ready</code>. Para isso, precisamos criar nosso <code>todo-server</code> com o cargo rodando o comando <code>cargo new todo-server --bin</code>, que irá gerar os arquivos a seguir:</p>
<ol>
<li>todo-server/src/main.rs</li>
<li>todo-server/Cargo.lock </li>
<li>todo-server/Cargo.toml</li>
</ol>
<p>O arquivo <code>main.rs</code> é bastante simples, pois possui somente uma linha executando uma impressão no console de <code>&quot;Hello, world!&quot;</code> da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Já o arquivo <code>Cargo.toml</code> possui todas as informações sobre o binário gerado:</p>
<pre><code class="language-toml">[package]
name = &quot;todo-server&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Julia Naomi @naomijub&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>Já o arquivo <code>Cargo.lock</code> corresponde às configurações geradas para o <code>Cargo.toml</code> com o registro de versões de dependências, assim como o <code>package-lock.json</code> no Node.</p>
<h2 id="adicionando-actix"><a class="header" href="#adicionando-actix">Adicionando Actix</a></h2>
<p>Nossa principal dependência é o <code>Actix</code>, assim precisamos adicionar a dependência <code>actix-web = &quot;2.0&quot;</code> à seção <code>[dependencies]</code> do <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;todo-server&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Julia Naomi @naomijub&quot;]
edition = &quot;2018&quot;

[dependencies]
actix-web = &quot;2.0&quot;
</code></pre>
<h3 id="implementando-o-endpoint-ping"><a class="header" href="#implementando-o-endpoint-ping">Implementando o endpoint <code>/ping</code></a></h3>
<p>Este endpoint é comum a muitos serviços, mas em alguns casos é chamado de <code>/healthy</code>, <code>/healthcheck</code> ou <code>/~/healthy</code>, digamos que seja um exemplo com aplicações práticas de um <code>hello world</code>. Neste primeiro momento vamos apresentar primeiro a implementção do <code>/ping</code> e depois explicar, pois acredito que neste caso seja importante ter visão do todo antes de entrar nos detalhes. Assim, uma implementação bem simples de <code>/ping</code> seria:</p>
<pre><pre class="playground"><code class="language-rust">use actix_web::{HttpServer, App};
use actix_web::{get, Responder, HttpResponse};

#[get(&quot;/ping&quot;)]
pub async fn ping() -&gt; impl Responder {
   HttpResponse::Ok().body(&quot;pong&quot;)
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
   HttpServer::new(||{
       App::new()
           .service(healthcheck) 
           .service(ping)
           .default_service(web::to(||HttpResponse::NotFound()))    
   })
   .workers(6)
   .bind((&quot;localhost&quot;, 4000))
   .unwrap()
   .run()
   .await
}
</code></pre></pre>
<p>E seu funcionamento seria:</p>
<p><img src="part-1/../imagens/pingpong.png" alt="Endpoint /ping" /></p>
<p><img src="part-1/../imagens/notfound.png" alt="Endpoint Not Found para a rota /" /></p>
<p>Agora podemos começar a descrever o endpoint <code>/ping</code>: </p>
<ol>
<li>A primeira coisa que vemos é a diretiva <code>use</code> associada a lib <code>actix_web</code>. Essa diretiva nos permite disponibilizar no nosso código as funções e estruturas de <code>actix_web</code> para uso posterior, assim a diretiva <code>use actix_web::HttpServer</code> disponibilizaria a estrutura <code>HttpServer</code> para usarmos. </li>
<li>Depois vemos a função <code>async fn ping() -&gt; impl Responder</code>. Essa função é uma função assíncrona, devido as palavras reservadas <code>async fn</code>, cujo nome é <code>ping</code>, recebe nenhum argumento <code>()</code> e como tipo de resposta implementa a trait <code>Responder</code>, que tem como tipo de retorno <code>Future&lt;Output = Result&lt;Response, Self::Error&gt;&gt;</code>. A resposta de <code>ping</code> é um status code <code>Ok()</code> com um <code>body(&quot;pong&quot;)</code>, porém seria possível também implementar com a função <code>with_status</code> da trait <code>Responder</code>, ficando <code>&quot;pong&quot;.with_status(StatusCode::Ok)</code>, que seria classificado como um <code>CustomResponder</code>, ou um <code>Responder</code> customizado.</li>
<li>A seguir encontramos a macro <code>#[actix_web::main]</code>, que é habilitada por padrão (https://docs.rs/actix-web/latest/actix_web/#crate-features). A função dessa macro é executar qualquer função marcada como <code>async</code> no runtime de actix.</li>
<li>Agora temos a função de execução <code>main</code> como <code>async fn main() -&gt; std::io::Result&lt;()&gt; </code>. Assim, essa <a href="https://docs.rs/actix-web/latest/actix_web/attr.main.html">macro</a> gera o código necessário para que nossa função <code>main</code> esteja conforme o padrão de funções <code>main</code> do Rust .</li>
<li>A linha <code>HttpServer::new(|| {..})</code> permite criar um servidor HTTP com uma <code>application factory</code>, assim como permite configurar a instância do servidor, como <code>workers</code> e <code>bind</code>, que veremos a seguir.</li>
<li>A linha <code>App::new().service(..)</code> é um <code>application builder</code> baseado no padrão <em>builder</em> para o <code>App</code>, que é uma struct correspondente a aplicação do actix-web, seu objetivo é configurar rotas e settings padrões. A função <code>service</code> registra um serviço no servidor.</li>
<li>A rota do serviço <code>ping</code> é definida pela macro <code>#[get(&quot;/ping&quot;)]</code>.</li>
<li>O módulo <code>web</code> possui uma série de funções auxiliares e e tipos auxiliares para o actix-web.</li>
<li>Depois disso, vemos <code>workers(6)</code>, uma função de <code>HttpServer</code> que define a quantidade de threads trabalhadoras que estarão envolvidas nesse executável. Por padrão, o valor de <code>workers</code> é a quantidade de CPUs lógicas disponíveis.</li>
<li>Agora temos o <code>bind</code>, que recebe o IP e a porta a qual esse servidor se conectará.</li>
<li><code>run</code> e <code>await</code> para executar o serviço e esperar pelo <code>async</code> definido anteriormente.</li>
</ol>
<p>É importante também implementarmos um teste para <code>NOT_FOUND</code>. Esse teste consiste em um request para uma rota que não existe e um status <code>NOT_FOUND</code>: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_web::test]
async fn not_found_route() {
    let mut app = test::init_service(
        App::new()
        .service(healthcheck) 
        .service(ping) 
        .default_service(web::to(|| HttpResponse::NotFound()))
    ).await;

    let req = test::TestRequest::with_uri(&quot;/crazy-path&quot;).to_request();

    let resp = app.call(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::NOT_FOUND);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementando-o-endpoint-ready"><a class="header" href="#implementando-o-endpoint-ready">Implementando o endpoint /~/ready</a></h3>
<p>Este endpoint é comum especialmente em serviços kubernetes e sua execução é via <code>kubectl</code>. Usualmente o <code>kubectl</code> espera que o processo ocorra via HTTP, TCP-gRPC ou uma execução de comando no contêiner. Para um contexto simples de contêineres, ter esse endpoint permite um monitoramento mais elevado de serviços, como os <em>Golden Signals</em> (sinais dourados apresentados pelo Google no livro Engenharia de Confiabilidade de Sites). Assim, ele permite um pouco mais de informações além de saber se o servidor está vivo (<code>/ping</code>), já que verifica se o serviço é capaz de realizar um pequeno processo. Outros endpoints comuns para esse tipo de prova são <code>/readiness</code> ou <code>/~/readiness</code>. O nosso endpoint vai executar um simples <code>$ echo hello</code> e retornar <code>accepted</code> para um resultado <code>Ok</code> e <code>internal server error</code> para um resultado <code>Err</code>. </p>
<p>O primeiro passo para essa prova é definir a rota que vamos chamar, no caso <code>/~/ready</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::new()
    .service(readiness)
    .service(healthcheck)
    .service(ping) 
    .default_service(web::to(|| HttpResponse::NotFound())) 
<span class="boring">}
</span></code></pre></pre>
<p>Agora temos que implementar a função <code>readiness</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get(&quot;/~/ready&quot;)]
pub async fn readiness() -&gt; impl Responder {
    let process = std::process::Command::new(&quot;sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&quot;echo hello&quot;)
        .output();
    match process {
        Ok(_) =&gt; HttpResponse::Accepted(),
        Err(_) =&gt; HttpResponse::InternalServerError()
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Note que criamos um valor chamado <code>process</code> que é um comando executado pela crate de <code>OS</code> <code>std::process::Command</code>. Para o <code>readiness</code> o comando que estamos executando é <code>sh -c echo hello</code>, que imprime <code>hello</code> no console. Depois disso fazemos pattern matching do resultado e se for <code>Ok</code> retornamos um <code>2XX</code> ou retornamos <code>500</code> para um <code>Err</code>.</p>
<h3 id="refatorando"><a class="header" href="#refatorando">Refatorando</a></h3>
<p>Agora que nosso código está funcionando podemos começar a pensar em organizá-lo, já que nosso arquivo <code>main</code> está com muitas funções. A ideia é seguir o padrão do framework Phoenix do Elixir, assim vamos separar o código em  3 conjuntos:</p>
<ol>
<li><code>main.rs</code>, que contém todas as informações de configuração do servidor, ou seja, a própria instância do servidor.</li>
<li><code>todo_api</code>, que contém todos os módulos responsáveis por lógica e banco de dados.</li>
<li><code>todo_api_web</code>, que contém todos os módulos responsáveis pelo gerenciamento do conteúdo web, como views e controllers, no nosso caso somente controllers.</li>
</ol>
<p>Assim, nossa primeira refatoração seria mover as funcões que implementam a trait <code>Responder</code> para um módulo de controller, <code>src/todo_api_web/controller/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{get, Responder, HttpResponse};

#[get(&quot;/~/ready&quot;)]
pub async fn readiness() -&gt; impl Responder {
    let process = std::process::Command::new(&quot;sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&quot;echo hello&quot;)
        .output();
    match process {
        Ok(_) =&gt; HttpResponse::Accepted(),
        Err(_) =&gt; HttpResponse::InternalServerError(),
    }
}

#[get(&quot;/ping&quot;)]
pub async fn ping() -&gt; impl Responder {
    HttpResponse::Ok().body(&quot;pong&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, nosso arquivo <code>main.rs</code> agora consome nosso módulo:</p>
<pre><pre class="playground"><code class="language-rust">pub mod todo_api_web;

use actix_web::{
    web, App, HttpResponse, HttpServer,
};
use todo_api_web::*;

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new()
            .service(readiness)
            .service(ping)
            .default_service(web::to(|| HttpResponse::NotFound()))
    })
    .workers(6)
    .bind((&quot;localhost&quot;, 4004))
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<p>Note a presença do módulo <code>todo_api_web</code> declarado como <code>mod todo_api_web;</code> e importando as funções <code>ping</code> e <code>readiness</code> através de <code>use todo_api_web::controller::{pong, readiness};</code>. Além disso, na imagem a seguir podemos perceber a presença de um arquivo <code>lib.rs</code> no sistema de arquivos, esse arquivo serve para podermos exportar nossos módulos internos para testes de integração. Assim, atualmente o único módulo declarado em <code>lib.rs</code> é <code>pub mod todo_api_web</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//src/todo_web_api/mod.rs
pub mod controller;
<span class="boring">}
</span></code></pre></pre>
<p><img src="part-1/../imagens/basicfilesystem.png" alt="Sistema de arquivos após a refatoração" /></p>
<p>Outro ponto que creio ser interessante rafatorar é dar a capacidade de nosso servidor adaptar o número de <code>workers</code> a quantidade de cores lógicos que a máquina hospedeira possui. Por exemplo, minha máquina pessoal possui 4 cores lógicos e decidi usar uma estratégia de leve estresse aos cores que geralmente se resume a <code>número de cores lógicos + 2</code>, ela se torna uma opção segura pelo fato de estarmos utilizando <code>async</code> no nosso serviço, ou seja, defini 6 <code>workers</code>, mas se meu computador possuísse 8 cores lógicos, eu poderia estar utilizando 10 <code>workers</code>. Para resolver este problema podemos utilizar uma lib conhecida como <code>num_cpus</code>, basta adicionar ela ao <code>[dependencies]</code> do Cargo.toml <code>num_cpus = &quot;1.0&quot;</code> e substituir em nosso código da seguinte maneira:</p>
<pre><pre class="playground"><code class="language-rust">#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new()
            .service(readiness)
            .service(ping)
            .default_service(web::to(|| HttpResponse::NotFound()))
    })
    .workers(num_cpus::get() + 2)
    .bind((&quot;localhost&quot;, 4004))
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<h2 id="testando-os-endpoints"><a class="header" href="#testando-os-endpoints">Testando os endpoints</a></h2>
<p>Uma coisa importante antes de continuarmos é criarmos testes para os endpoints implementados, especialmente agora que já aprendemos como funciona o a criação de rotas e controllers. No caso de rotas e controllers é mais eficiente começar com testes de integração, inclusive por já termos implementado as rotas anteriormente. Assim, precisamos criar alguns arquivos para executar nossos testes de integração. O primeiro arquivo que precisamos é o arquivo <code>lib</code> dentro de <code>tests</code>, <code>tests/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate todo_server;

mod todo_api_web;
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, agora precisamos criar o módulo <code>todo_api_web</code> com um módulo interno <code>controller</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/todo_api_web/mod.rs
mod controller;
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos começar a criar os testes de controller no arquivo <code>tests/todo_api_web/controller.rs</code>. O primeiro teste que vamos escrever é a verificação se o conteúdo de texto da rota <code>/ping</code> é <code>pong</code>. Para isso, precisamos utilizar um módulo de suporte para testes do actix chamado <code>actix_web::test</code> e incorporar como <code>[dev-dependencies]</code> duas libs que nos apoiarão no uso de testes, a <code>bytes = &quot;0.5.3&quot;</code> para processar os bytes da resposta gerada no endpoint, e a <code>actix-service = &quot;1.0.5&quot;</code>, que apoia nos testes para chamar um mock de <code>App</code> do actix na rota desejada. Sugiro isolar os testes dos controllers <code>pong</code> e <code>readiness</code> em um módulo conforme a seguir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod ping_readiness {
    use todo_server::todo_api_web::controller::{ping};

    use actix_web::{test, App};

    #[actix_web::test]
    async fn test_ping_pong() {
        let mut app = test::init_service(App::new().service(ping)).await;

        let req = test::TestRequest::get().uri(&quot;/ping&quot;).to_request();
        let resp = test::call_service(&amp;mut app, req).await;
        let result = test::read_body(resp).await;
        assert_eq!(std::str::from_utf8(&amp;result).unwrap(), &quot;pong&quot;);
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>O teste apresentado possui uma macro de teste diferente do usual no Rust. Em vez de ser <code>#[test]</code>, utilizamos uma macro de teste que disponibiliza o runtime de actix com <code>#[actix_web::test]</code>. Além disso, note que agora nossa função de teste passa a ser <code>async</code> e utilizamos vários <code>await</code> dentro do teste.</p>
<p>Agora vamos explicar as partes do teste: <code>test::init_service</code> disponibiliza um mock de serviço do Actix que recebe como argumento um tipo <code>App</code> com a rota, <code>/ping&quot;</code>, e designa a essa rota um controller, <code>.service(ping)</code>. Além disso, criamos uma instância de <code>Request</code> para teste com <code>test::TestRequest</code> utilizando o método <code>get()</code> na <code>uri(&quot;/ping&quot;)</code>. Depois disso, a <code>resp</code> corresponde a ler a resposta que esse serviço <code>app</code> daria para o <code>Request</code> <code>req</code>. Como a resposta de <code>read_response</code> são <code>bytes</code>, convertemos para string e comparamos com o resultado esperado pelo endpoint.</p>
<p>Com o teste de <code>pong</code> implementado, podemos criar o teste de <code>readiness</code>. No teste de <code>readiness</code> não nos interessa saber o corpo da resposta, assim a sugestão é somente saber se a execução retornou um status <code>Accepted</code>. Para esse teste, vamos utilizar o recurso da crate <code>actix-service</code>, que nos possibilita fazer chamadas a um serviço através de <code>&lt;App&gt;.call(&lt;Request&gt;).await</code>. Assim podemos utilizar o <code>call</code> para retornar uma response, na qual podemos acessar o <code>status()</code>. O bloco de testes fica assim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod ping_readiness {
    use todo_server::todo_api_web::controller::{ping, readiness};

    use actix_web::{test, App, http::StatusCode};

    ...

    #[actix_web::test]
    async fn test_readiness() {
        let mut app = test::init_service(App::new().service(readiness)).await;

        let req = test::TestRequest::get().uri(&quot;/~/ready&quot;).to_request();
        let resp = test::call_service(&amp;mut app, req).await;
        assert_eq!(resp.status(), StatusCode::ACCEPTED);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com tudo testado, o próximo passo é configurar nosso serviço para criar uma tarefa todo.</p>
<ul>
<li>O código deste capítulo está na bibliografia e solicitações de mudança serão bem vindas para manter o código exemplo atualizado.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criando-tarefas"><a class="header" href="#criando-tarefas">Criando tarefas</a></h1>
<p>O primeiro passo para criar nossa tarefa será entender o que é uma tarefa. A ideia de uma tarefa é conter informações sobre ela e que outras pessoas do time tenham visibilidade do que se trata a tarefa. Assim vamos começar por modelar o domínio de entrada e saída. Usaremos a <code>struct</code> do Rust para modelar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Task {
    is_done: bool,
    title: String
}

enum State {
    Todo,
    Doing,
    Done,
}

struct TodoCard {
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;Task&gt;,
    state: State
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, nossa struct principal é a <code>TodoCard</code>, que possui os campos <code>String</code> <code>title</code> e <code>description</code>, correspondentes ao título da tarefa e a sua descrição. Depois disso, podemos ver que existe um campo do tipo <code>Uuid</code> (inclua a crate <code>uuid</code> com as <code>features</code> <code>serde</code> e <code>v4</code> ativadas em seu <code>Cargo.toml</code>), que é um <code>owner</code>, ou seja, a pessoa dona da tarefa. Cada tarefa possui um conjunto de subtarefas a fazer, que podem estar completas ou não. Essas subtarefas são chamadas de <code>Task</code>, e é uma struct que possui um título, <code>title</code>, e um estado booleano que chamamos de <code>is_done</code>. Em seguida temos o estado da tarefa no fluxo de cards, <code>state</code>, que corresponde ao enum <code>State</code>, com os campos <code>Todo</code>, <code>Doing</code> e <code>Done</code>. O primeiro passo do serviço será algo bastante simples, receber um <code>POST</code> JSON com o <code>TodoCard</code> e respondermos um <code>TodoCardId</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoCardId {
    id: Uuid
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Uuid</strong></p>
<p>A crate Uuid possui várias configurações, mas para o que vamos utilizar precisamos de compatibilidade com <code>Serde</code> e a versão 4. Serde para garantir que ela é serializável e desserializável para JSON, e versão 4, pois é o formato que vamos utilizar. Assim, essas configurações são adicionadas ao <code>[dependencies]</code> do <code>Cargo.toml</code> como <code>uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }</code>.</p>
</blockquote>
<p>Um exemplo de <code>POST</code> em json de uma <code>TodoCard</code> seria:</p>
<pre><code class="language-json">{
    &quot;title&quot;: &quot;This is a card&quot;,
    &quot;description&quot;: &quot;This is the description of the card&quot;,
    &quot;owner&quot;: &quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;,
    &quot;tasks&quot;: [
        {
            &quot;title&quot;: &quot;title 1&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 2&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 3&quot;,
            &quot;is_done&quot;: false
        }
    ],
    &quot;state&quot;: &quot;Doing&quot;
}
</code></pre>
<p>Agora que modelamos nosso <code>TodoCard</code> podemos começar sua implementação com testes.</p>
<h2 id="criando-o-primeiro-teste-de-todocard"><a class="header" href="#criando-o-primeiro-teste-de-todocard">Criando o primeiro teste de <code>TodoCard</code></a></h2>
<p>O novo teste envolve uma série de alterações no código, como criar um novo <code>scope</code> para rotas de <code>api</code>, enviar <code>payloads</code> e responder objetos JSON. Assim, a estratégia desse teste vai envolver enviar um <code>TodoCard</code> para ser criado e termos como resposta um JSON contendo o id desse <code>TodoCard</code>. Lembrando que agora que vamos manipular JSON, precisamos poder serializar e desserializar eles, e para isso devemos incluir a biblioteca <code>serde</code> no Cargo.toml:</p>
<pre><code class="language-toml">// ...
[dependencies]
actix-web = &quot;2.0&quot;
actix-rt = &quot;1.0&quot;
uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
num_cpus = &quot;1.0&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
actix-service = &quot;1.0.5&quot;
</code></pre>
<p>Assim, podemos escrever nosso teste sem conflito de dependências em <code>tests/todo_api_web/controller.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod create_todo {
    use todo_server::todo_api_web::{controller::todo::create_todo, model::todo::TodoIdResponse};

    use actix_web::{http::header::CONTENT_TYPE, test, web, App, body};
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        String::from(
            &quot;{
                \&quot;title\&quot;: \&quot;This is a card\&quot;,
                \&quot;description\&quot;: \&quot;This is the description of the card\&quot;,
                \&quot;owner\&quot;: \&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442\&quot;,
                \&quot;tasks\&quot;: [
                    {
                        \&quot;title\&quot;: \&quot;title 1\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 2\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 3\&quot;,
                        \&quot;is_done\&quot;: false
                    }
                ],
                \&quot;state\&quot;: \&quot;Doing\&quot;
            }&quot;,
        )
    }

    #[actix_web::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(App::new().service(create_todo)).await;

        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(post_todo().as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Duas características já se destacam, <code>controller::todo::create_todo</code> e <code>model::TodoIdResponse</code>, que correspondem ao recursos que de fato estão sendo testados. <code>TodoIdResponse</code> corresponde ao Json com o id de criação da <code>TodoCard</code>, sua definição é a seguinte:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct TodoIdResponse {
    id: Uuid,
}
<span class="boring">}
</span></code></pre></pre>
<p>Perceba que utilizamos as macros de <code>Serialize, Deserialize</code> para sua fácil conversão entre JSON e String. Além disso, <code>TodoIdResponse</code> possui um campo <code>id</code> que é do tipo <code>Uuid</code>, um <code>Uuid</code> do tipo <code>v4</code>, conforme definimos no <code>Cargo.toml</code>. Agora temos também o controller <code>create_todo</code>, que receberá um <code>POST</code> do tipo JSON, fará sua inserção no banco de dados e retornará seu id. Felizmente, para este primeiro momento, não precisamos fazer a inserção no banco, pois o teste espera somente um tipo de retorno <code>id</code>. </p>
<p>Outro ponto importante é o uso da biblioteca <code>use serde_json::from_str;</code>. Essa função em especial serve para converter uma <code>&amp;str</code> em uma das structs serializáveis, conforme a linha <code>let id: TodoIdResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();</code>. Note que como a função não sabe para qual struct deve converter a resposta <code>resp</code>, tivemos de definir seu tipo na declaração do valor id, <code>id: TodoIdResponse</code>. O JSON do <code>payload</code> do <code>POST</code> está definido como uma string na função auxiliar de teste <code>post_todo</code>.</p>
<p>A seguir possuímos a definição do teste e o uso do runtime do actix, seguidos da definição do <code>App</code>, que vamos utilizar para mockar o serviço e suas rotas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//definição do teste
#[actix_web::test]
async fn valid_todo_post() {
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Definição do App
let mut app = test::init_service(
    App::new().service(create_todo)
).await;
<span class="boring">}
</span></code></pre></pre>
<p>Note duas mudanças na definição do <code>App</code>: nossa rota possui um padrão diferente <code>/api/create</code> e o controller <code>create_todo</code> está sendo passado para um método <code>service()</code>. Outro detalhe é que estamos utilizando mais recursos na criação do request:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let req = test::TestRequest::post()
    .uri(&quot;/api/create&quot;)
    .insert_header((CONTENT_TYPE, ContentType::json()))
    .set_payload(post_todo().as_bytes().to_owned())
    .to_request();
<span class="boring">}
</span></code></pre></pre>
<p>Veja que <code>TestRequest</code> agora instancia um tipo <code>POST</code> antes de adicionar informações ao seu builder, <code>TestRequest::post()</code>. As duas outras mudanças são a adição das funções <code>header</code> e <code>set_payload</code>, <code>.header(&quot;Content-Type&quot;, ContentType::json()).set_payload(post_todo().as_bytes().to_owned())</code>. <code>header</code> define o tipo de conteúdo que estamos enviando e sua ausência nesse caso pode implicar em uma resposta com o status <code>400</code>. <code>set_payload</code> recebe um array de bytes com o conteúdo do <code>payload</code>, ou seja <code>post_todo</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp = test::call_service(&amp;mut app, req).await;
    let body = resp.into_body();
    let bytes = body::to_bytes(body).await.unwrap();
    let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
    assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
<span class="boring">}
</span></code></pre></pre>
<p>Depois podemos ler a resposta normalmente, <code>let resp = test::call_service(&amp;mut app, req).await;</code>, obter o body da response em bytes <code>let body = resp.into_body();let bytes = body::to_bytes(body).await.unwrap();</code> e transformar essa resposta em uma struct conhecida pelo serviço, <code>from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();</code>. O último passo é garantir que a resposta contendo o <code>TodoIdResponse</code> seja de fato um id válido e para isso utilizamos a macro <code>assert!</code> em <code>assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());</code>. Note a função auxiliar <code>get_id</code>, se nosso teste estivesse dentro do nosso módulo em vez de na pasta de testes de integração, seria possível anotar ela com <code>#[cfg(test)]</code> e economizar espaço no executável e tempo de compilação. Eu optei por deixá-la visível e testar o controller nos testes de integração, mas a escolha é sua:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TodoIdResponse {
    // #[cfg(test)]
    pub fn get_id(self) -&gt; String {
        format!(&quot;{}&quot;, self.id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementando-o-controller-do-teste-anterior"><a class="header" href="#implementando-o-controller-do-teste-anterior">Implementando o controller do teste anterior</a></h3>
<p>Agora, com o teste implementado, precisamos entender quais são as coisas que necessitamos implementar:</p>
<ol>
<li>Controller <code>create_todo</code>.</li>
<li>O controller recebe um Json do tipo <code>TodoCard</code> , que precisa ser deserializável com a macro <code>#[derive(Deserialize)]</code>.</li>
<li>Um struct <code>TodoIdResponse</code> que precisa ser serializável com <code>#[derive(Serialize)]</code>.</li>
</ol>
<p>Como os itens 2 e 3 já foram mencionados na seção anterior, vou mostrar como eles ficaram com as macros de serialização e desserialização. Além disso, inclui a macro de <code>Debug</code>, pois pode ser útil durante o desenvolvimento, se você achar necessário retirá-la no futuro pode ajudar a economizar espaço do binário.</p>
<ul>
<li>Para utilizar as macros de serde, lembre-se de incluir <code>#[macro_use] extern crate serde;</code> em <code>lib.rs</code> e em <code>main.rs</code> (versões mais antigas do Rust).</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/model/mod.rs
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug)]
struct Task {
    is_done: bool,
    title: String,
}

#[derive(Serialize, Deserialize, Debug)]
enum State {
    Todo,
    Doing,
    Done,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct TodoCard {
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;Task&gt;,
    state: State,
}

#[derive(Serialize, Deserialize)]
pub struct TodoIdResponse {
    id: Uuid,
}

impl TodoIdResponse {
    // #[cfg(test)]
    pub fn get_id(self) -&gt; String {
        format!(&quot;{}&quot;, self.id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para o item 1, <code>create_todo</code> controller, devemos novamente criar uma função <code>async</code>, que tem como tipo de resposta uma implementação da trait <code>Responder</code>, a <code>impl Responder</code>, como fizemos com <code>pong</code> e <code>readiness</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/todo.rs
use crate::todo_api_web::model::todo::TodoIdResponse;
use actix_web::{ http::header::ContentType, post, web, HttpResponse, Responder};
use uuid::Uuid;

#[post(&quot;/api/create&quot;)]
pub async fn create_todo(_payload: web::Payload) -&gt; impl Responder {
    let new_id = Uuid::new_v4();
    let str = serde_json::to_string(&amp;TodoIdResponse::new(new_id)).unwrap();
    HttpResponse::Created()
        .content_type(ContentType::json())
        .body(str)
}
<span class="boring">}
</span></code></pre></pre>
<p>As primeiras coisas que podemos perceber são a create de <code>Uuid</code> para gerar novos <code>uuids</code> com <code>Uuid::new_v4()</code>, e os tipos de entrada e de saída, <code>TodoCard, TodoIdResponse</code>, respectivamente. O actix possui uma forma interna de desserializar objetos JSON que é definido no módulo <code>web</code> com <code>web::Json&lt;T&gt;</code> e é em <code>T</code> que vamos incluir nossa struct <code>TodoCard</code>. Veja que o tipo de retorno <code>TodoIdResponse</code> está sendo serializado pelo <code>serde_json</code> e retornado ao <code>body</code>. Note também que adicionamos o header <code>Content-type</code> através da função <code>.content_type(ContentType::json())</code>. Assim já seria suficiente para nosso teste passar, mas se quisermos testar essa rota com um <code>curl</code> é preciso adicionar ao <code>App</code> de <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HttpServer::new(|| {
    App::new()
        .service(readiness)
        .service(ping)
        .service(create_todo)
        .default_service(web::to(|| HttpResponse::NotFound()))
})
<span class="boring">}
</span></code></pre></pre>
<h3 id="refatorando-as-rotas"><a class="header" href="#refatorando-as-rotas">Refatorando as rotas</a></h3>
<p>No nosso teste anterior, percebemos que nossas rotas da <code>main.rs</code> são desconectadas das rotas do teste (<code>tests/todo_api_web/controller</code>), pois iniciamos um servidor de teste (<code>test::init_service</code>) que pode possuir uma rota aleatória, já que iniciamos um novo <code>App</code> dentro dele. Assim, basta direcionarmos a rota a um controller correto e fazer o request ser direcionado para essa rota que tudo ocorrerá bem. Para resolver isso, a sugestão é refatorarmos o <code>App</code> de forma que suas rotas sejam configuradas em um único lugar e possam ser utilizadas tanto na <code>main.rs</code> quanto nos testes. Para isso, vamos refatorar nosso <code>main</code> para extrair todo o <code>web::scope</code> de forma que as configurações venham de um módulo de rotas. Assim, devemos criar um módulo de rotas em <code>src/todo_api_web/routes.rs</code> e adicionar o seguinte código:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web, HttpResponse};
use crate::todo_api_web::controller::{
    pong, readiness,
    todo::create_todo
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
                .service(
                    web::scope(&quot;api/&quot;)
                        .route(&quot;create&quot;, web::post().to(create_todo))
                )
                .route(&quot;ping&quot;, web::get().to(pong))
                .route(&quot;~/ready&quot;, web::get().to(readiness))
                .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound()))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Basicamente estamos extraindo todas as rotas para uma nova função que alterará o está do configuração do serviço dentro de  <code>App</code> com a função <code>config.service</code>. Isso impacta também nosso <code>main</code>, pois agora somente vamos precisar declarar a função <code>app_routes</code>:</p>
<pre><pre class="playground"><code class="language-rust">// main.rs
mod todo_api_web;
use todo_api_web::routes::app_routes;

use actix_web::{App, HttpServer};
use num_cpus;

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new().configure(app_routes) 
    })
    .workers(num_cpus::get() + 2)
    .bind((&quot;localhost&quot;, 4004))
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<p>Agora podemos fazer a mesma refatoração nos testes, <code>tests/todo_api_web/controller</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ping_readiness {
    use todo_server::todo_api_web::routes::app_routes;

    use actix_web::{body, http::StatusCode, test, web, App};

    #[actix_web::test]
    async fn test_ping_pong() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;

        let req = test::TestRequest::get().uri(&quot;/ping&quot;).to_request();
        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();

        assert_eq!(bytes, web::Bytes::from_static(b&quot;pong&quot;));
    }

    #[actix_web::test]
    async fn test_readiness() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
        let req = test::TestRequest::get().uri(&quot;/~/ready&quot;).to_request();
        let resp = test::call_service(&amp;mut app, req).await;

        assert_eq!(resp.status(), StatusCode::ACCEPTED);
    }
}

mod create_todo {
    use todo_server::todo_api_web::{controller::todo::create_todo, model::todo::TodoIdResponse};

    use actix_web::{body, http::header::CONTENT_TYPE, test, web, App};
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        String::from(
            &quot;{
                \&quot;title\&quot;: \&quot;This is a card\&quot;,
                \&quot;description\&quot;: \&quot;This is the description of the card\&quot;,
                \&quot;owner\&quot;: \&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442\&quot;,
                \&quot;tasks\&quot;: [
                    {
                        \&quot;title\&quot;: \&quot;title 1\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 2\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 3\&quot;,
                        \&quot;is_done\&quot;: false
                    }
                ],
                \&quot;state\&quot;: \&quot;Doing\&quot;
            }&quot;,
        )
    }

    #[actix_web::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(App::new().service(create_todo)).await;

        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(post_todo().as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Com estas alterações podemos perceber que um teste falha ao executarmos <code>cargo test</code>, esse é o teste <code>test todo_api_web::controller::ping_readiness::test_readiness_ok</code>, que falha com um <code>404</code>. Isso se deve ao fato de que a rota que estamos enviando o request de <code>readiness</code> estava errada esse tempo todo, pois escrevemos <code>/readiness</code>, enquanto a rota real é <code>/~/ready</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get(&quot;/~/ready&quot;)]
pub async fn readiness() -&gt; impl Responder {
    let process = std::process::Command::new(&quot;sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&quot;echo hello&quot;)
        .output();
    match process {
        Ok(_) =&gt; HttpResponse::Accepted(),
        Err(_) =&gt; HttpResponse::InternalServerError(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso próximo passo é incluir nosso <code>TodoCard</code> em nossa base de dados.</p>
<h2 id="configurando-a-base-de-dados"><a class="header" href="#configurando-a-base-de-dados">Configurando a base de dados</a></h2>
<p>A base de dados que vamos utilizar agora é o DyanmoDB. O objetivo de utilizar essa base de dados é salvar as <code>TodoCards</code> para podermos buscá-las no futuro, assim o primeiro passo é configurar e modelar a base de dados para que nosso servidor a reconheça. A instância que vamos utilizar é derivada de um contêiner docker cuja imagem é <code>amazon/dynamodb-local</code> e pode ser executada com <code>docker run -p 8000:8000 amazon/dynamodb-local</code>. Observe que a porta que o DynamoDB está expondo é a <code>8000</code>. Eu gosto muito de utilizar Makefiles, pois eles facilitam a vida quando precisamos rodar vários comandos, especialmente em serviços diferentes. Assim, criei o seguinte Makefile para executar o DynamoDB:</p>
<pre><code class="language-sh">db:
	docker run -p 8000:8000 amazon/dynamodb-local

</code></pre>
<h3 id="escrevendo-no-banco-de-dados"><a class="header" href="#escrevendo-no-banco-de-dados">Escrevendo no banco de dados</a></h3>
<p>Como essa primeira feature envolve exploração, primeiro vou apresentar a lógica de como fazemos para depois escrever os testes e generalizações. O próximo passo para termos a lógica do banco de dados é criar um novo módulo em <code>lib.rs</code> (e no <code>main.rs</code>) chamado <code>todo_api</code>, que por sua vez possuirá o módulo <code>db</code>, que vai gerenciar todas as relações com o DynamoDB. Antes de seguir com o servidor em si, vou comentar a atual função <code>main</code> e substituir por outra simples que sera descrita posteriormente, que utiliza somente o módulo <code>todo_api</code> para executar a criação de uma <code>TodoCard</code> no banco de dados, depois disso podemos conectar as partes novamente.</p>
<p>Para podermos nos comunicar facilmente com o DynamoDB em Rust, existem a biblioteca oferecida pela AWS, chamada <code>aws-sdk-dynamodb</code>. Basta adicioná-las às dependências no <code>Cargo.toml</code>. (Atualmente a sdk Rust da AWS está em Developer Preview e não deve ser usada em produção).</p>
<pre><code class="language-toml">[dependencies]
actix-web = &quot;2.0&quot;
actix-rt = &quot;1.0&quot;
actix-http = &quot;1.0.1&quot;
uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
num_cpus = &quot;1.0&quot;
aws-config = &quot;0.49.0&quot;
aws-sdk-dynamodb = &quot;0.19.0&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
actix-service = &quot;1.0.5&quot;
</code></pre>
<p>Com a biblioteca <code>aws-sdk-dynamodb</code> disponível, podemos começar a pensar em como nos comunicar com o DynamoDB. Podemos fazer isso adicionando um módulo <code>helpers</code> dentro de <code>todo_api/db</code> e criando uma função que retorna o cliente:</p>
<p>Nota: Para utilizar o dynamodb localmente, deve ser criado um arquivo de configuração contendo uma região e credenciais (que não precisam ser validas) da AWS em <code>~/.aws/config</code> contendo:</p>
<pre><code class="language-code">[profile localstack]
region=us-east-1
aws_access_key_id=AKIDLOCALSTACK
aws_secret_access_key=localstacksecret
</code></pre>
<p>Agora precisamos criar uma tabela, para nosso caso não vou utilizar uma migracão pois acredito que em um cenário real este banco de dados será configurado por outro serviço, algo mais próximo a um ambiente cloud. Assim, vamos criar a função <code>create_table</code> em <code>todo_api/db/helpers.rs</code>, que fará a configuração da tabela para nós:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::http::Uri;
use aws_sdk_dynamodb::{
    model::{
        AttributeDefinition, KeySchemaElement, KeyType, ProvisionedThroughput, ScalarAttributeType,
    },
    Client, Endpoint,
};

pub static TODO_CARD_TABLE: &amp;str = &quot;TODO_CARDS&quot;;

pub async fn create_table() {
    let config = aws_config::load_from_env().await;
    let dynamodb_local_config = aws_sdk_dynamodb::config::Builder::from(&amp;config)
        .endpoint_resolver(
            Endpoint::immutable(Uri::from_static(&quot;http://localhost:8000&quot;)),
        )
        .build();

    let client = Client::from_conf(dynamodb_local_config);

    let table_name = TODO_CARD_TABLE.to_string();
    let ad = AttributeDefinition::builder()
        .attribute_name(&quot;id&quot;)
        .attribute_type(ScalarAttributeType::S)
        .build();

    let ks = KeySchemaElement::builder()
        .attribute_name(&quot;id&quot;)
        .key_type(KeyType::Hash)
        .build();

    let pt = ProvisionedThroughput::builder()
        .read_capacity_units(1)
        .write_capacity_units(1)
        .build();

    match client
        .create_table()
        .table_name(table_name)
        .key_schema(ks)
        .attribute_definitions(ad)
        .provisioned_throughput(pt)
        .send()
        .await
    {
        Ok(output) =&gt; {
            println!(&quot;Output: {:?}&quot;, output);    
        }
        Err(error) =&gt; {
            println!(&quot;Error: {:?}&quot;, error);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para testar precisamos executar o comando <code>make db</code>. Iremos seguir a <a href="https://docs.aws.amazon.com/sdk-for-rust/latest/dg/dynamodb-local.html">documentação</a> do aws-sdk-rust para configurar o DynamoDB local. Em outro terminal, precisamos setar uma variavel de ambiente para a <code>aws-config</code> utilizar o profile <code>localstack</code> que adicionamos em <code>~/.aws/config</code>, para isso usamos <code>export AWS_PROFILE=localstack</code> (no osx ou linux). Depois atualizamos a main com o cdigo abaixo e executamos em seguida, no mesmo terminal aonde setamos a variavel de ambiente <code>AWS_PROFILE</code> executamos <code>cargo build &amp;&amp; cargo run</code>. </p>
<pre><pre class="playground"><code class="language-rust">// main.rs
use todo_api::db::helpers::create_table;

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    create_table();
}
</code></pre></pre>
<p>Executando esta sequência de comandos, recebemos o seguinte output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Output: CreateTableOutput CreateTableOutput {
	table_description: Some(TableDescription {
		attribute_definitions: Some([AttributeDefinition {
			attribute_name: Some(&quot;id&quot;),
			attribute_type: Some(S)
		}]),
		table_name: Some(&quot;TODO_CARDS&quot;),
		key_schema: Some([KeySchemaElement {
			attribute_name: Some(&quot;id&quot;),
			key_type: Some(Hash)
		}]),
		table_status: Some(Active),
		creation_date_time: Some(DateTime {
			seconds: 1665206254,
			subsecond_nanos: 461999893
		}),
		provisioned_throughput: Some(ProvisionedThroughputDescription {
			last_increase_date_time: Some(DateTime {
				seconds: 0,
				subsecond_nanos: 0
			}),
			last_decrease_date_time: Some(DateTime {
				seconds: 0,
				subsecond_nanos: 0
			}),
			number_of_decreases_today: Some(0),
			read_capacity_units: Some(1),
			write_capacity_units: Some(1)
		}),
		table_size_bytes: 0,
		item_count: 0,
		table_arn: Some(&quot;arn:aws:dynamodb:ddblocal:000000000000:table/TODO_CARDS&quot;),
		table_id: None,
		billing_mode_summary: None,
		local_secondary_indexes: None,
		global_secondary_indexes: None,
		stream_specification: None,
		latest_stream_label: None,
		latest_stream_arn: None,
		global_table_version: None,
		replicas: None,
		restore_summary: None,
		sse_description: None,
		archival_summary: None,
		table_class_summary: None
	})
}
<span class="boring">}
</span></code></pre></pre>
<p>Tabela criada! Mas se executarmos <code>cargo run</code> de novo, receberemos um erro dizendo que não é possível criar uma tabela que já existe:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Error: ServiceError {
	err: CreateTableError {
		kind: ResourceInUseException(ResourceInUseException {
			message: Some(&quot;Cannot create preexisting table&quot;)
		}),
		meta: Error {
			code: Some(&quot;ResourceInUseException&quot;),
			message: Some(&quot;Cannot create preexisting table&quot;),
			request_id: Some(&quot;543a624e-7f21-4dd2-80f2-520ae078152b&quot;),
			extras: {}
		}
	},
	raw: Response {
		inner: Response {
			status: 400,
			version: HTTP / 1.1,
			headers: {
				&quot;date&quot;: &quot;Sat, 08 Oct 2022 05:33:45 GMT&quot;,
				&quot;content-type&quot;: &quot;application/x-amz-json-1.0&quot;,
				&quot;x-amzn-requestid&quot;: &quot;543a624e-7f21-4dd2-80f2-520ae078152b&quot;,
				&quot;content-length&quot;: &quot;112&quot;,
				&quot;server&quot;: &quot;Jetty(9.4.48.v20220622)&quot;
			},
			body: SdkBody {
				inner: Once(Some(b &quot;{\&quot;__type\&quot;:\&quot;com.amazonaws.dynamodb.v20120810#ResourceInUseException\&quot;,\&quot;Message\&quot;:\&quot;Cannot create preexisting table\&quot;}&quot;)),
				retryable: true
			}
		},
		properties: SharedPropertyBag(Mutex {
			data: PropertyBag,
			poisoned: false,
			..
		})
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Para corrigir esse erro, sugiro modificar o método <code>create_table</code> para verificar se existem tabelas com a função <code>client.list_tables().send()</code>. Para isso, fazemos a seguinte modificação:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::http::Uri;
use aws_sdk_dynamodb::{
    model::{
        AttributeDefinition, KeySchemaElement, KeyType, ProvisionedThroughput, ScalarAttributeType,
    },
    Client, Endpoint
};

pub static TODO_CARD_TABLE: &amp;str = &quot;TODO_CARDS&quot;;

pub async fn create_table() {
    let config = aws_config::load_from_env().await;
    let dynamodb_local_config = aws_sdk_dynamodb::config::Builder::from(&amp;config)
        .endpoint_resolver(
            Endpoint::immutable(Uri::from_static(&quot;http://localhost:8000&quot;)),
        )
        .build();

    let client = Client::from_conf(dynamodb_local_config);

    match client.list_tables().send().await {
        Ok(list) =&gt; {
            match list.table_names {
                Some(table_vec) =&gt; {
                    if table_vec.len() &gt; 0 {
                        println!(&quot;Error: {:?}&quot;, &quot;Table already exists&quot;);
                    } else {
                        create_table_input(&amp;client).await
                    }
                }
                None =&gt; create_table_input(&amp;client).await,
            };
        }
        Err(_) =&gt; {
            create_table_input(&amp;client).await;
        }
    }
}

fn build_key_schema() -&gt; KeySchemaElement {
    KeySchemaElement::builder()
        .attribute_name(&quot;id&quot;)
        .key_type(KeyType::Hash)
        .build()
}

fn build_provisioned_throughput() -&gt; ProvisionedThroughput {
    ProvisionedThroughput::builder()
        .read_capacity_units(1)
        .write_capacity_units(1)
        .build()
}

fn build_attribute_definition() -&gt; AttributeDefinition {
    AttributeDefinition::builder()
        .attribute_name(&quot;id&quot;)
        .attribute_type(ScalarAttributeType::S)
        .build()
}

async fn create_table_input(client: &amp;Client) {
    let table_name = TODO_CARD_TABLE.to_string();
    let ad = build_attribute_definition();
    let ks = build_key_schema();
    let pt = build_provisioned_throughput();

    match client
        .create_table()
        .table_name(table_name)
        .key_schema(ks)
        .attribute_definitions(ad)
        .provisioned_throughput(pt)
        .send()
        .await
    {
        Ok(output) =&gt; {
            println!(&quot;Output: {:?}&quot;, output);
        }
        Err(error) =&gt; {
            println!(&quot;Error: {:?}&quot;, error);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que, quando verificamos as listas existentes na tabela, surgiram várias situações possíveis e para facilitar a criação da tabela, extraímos sua lógica para <code>create_table_input</code>. A primeira situação é <code>Err</code>, que possivelmente representa algum problema de listagem de tabelas na base, indicando ausência de tabelas, que nos permite criar tabelas. O segundo caso, dentro do <code>Ok</code> é um <code>None</code>, que pode significar os mais diversos problemas. Depois disso obtemos a listagem em <code>Some</code>, mas esta listagem pode estar vazia, sendo um caso para criar tabela, o <code>else</code>, e se a listagem for maior que zero, não criamos a tabela.</p>
<h3 id="inserindo-conteúdo-na-tabela"><a class="header" href="#inserindo-conteúdo-na-tabela">Inserindo conteúdo na tabela</a></h3>
<p>Para inserirmos a tabela, vamos precisar de uma struct de <code>rusoto_dynamo</code> chamada <code>PutItemInput</code>, que nos permitirá inserir o JSON que recebemos na tabela, porém o JSON que recebemos em <code>TodoCard</code> não possui o id do card. Para podermos utilizar o <code>PutItemInput</code> como definimos na tabela, vamos criar um <code>model</code> que possua um id.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/mod.rs
use rusoto_dynamodb::AttributeValue;
use std::collections::HashMap;
use uuid::Uuid;

#[derive(Debug, Clone)]
struct TaskDb {
    is_done: bool,
    title: String,
}

#[derive(Debug, Clone)]
enum StateDb {
    Todo,
    Doing,
    Done,
}

#[derive(Debug, Clone)]
pub struct TodoCardDb {
    id: Uuid,
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;TaskDb&gt;,
    state: StateDb,
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos criar uma função que permita transformar um <code>TodoCard</code> em um <code>TodoCardDb</code>, em <code>src/todo_api/model/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::model::{State, TodoCard};
use actix_web::web;

impl TodoCardDb {
    pub fn new(card: web::Json&lt;TodoCard&gt;) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            title: card.title.clone(),
            description: card.description.clone(),
            owner: card.owner,
            tasks: card
                .tasks
                .iter()
                .map(|t| TaskDb {
                    is_done: t.is_done,
                    title: t.title.clone(),
                })
                .collect::&lt;Vec&lt;TaskDb&gt;&gt;(),
            state: match card.state {
                State::Doing =&gt; StateDb::Doing,
                State::Done =&gt; StateDb::Done,
                State::Todo =&gt; StateDb::Todo,
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, podemos fazer nosso <code>controller</code> momentaneamente gerenciar todas as ações com o banco de dados:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use uuid::Uuid;
use crate::todo_api_web::model::{TodoCard, TodoIdResponse};
use crate::todo_api::model::{TodoCardDb};

pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = TodoCardDb::new(info);
    let client = get_client().await;
    match put_todo(&amp;client, todo_card).await {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(&quot;Failed to serialize todo card&quot;))
    }
}

/// A partir daqui vamos extrair logo mais
use aws_sdk_dynamodb::{Client};
use crate::{
    todo_api::db::helpers::{TODO_CARD_TABLE},
};
use super::helpers::get_client;

pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt;  Option&lt;uuid::Uuid&gt; {
    match client.put_item()
    .table_name(TODO_CARD_TABLE.to_string())
    .set_item(Some(todo_card.clone().into()))
    .send()
    .await {
        Ok(_) =&gt; {
            Some(todo_card.id)
        },
        Err(_) =&gt; {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que nosso controller ficou muito mais funcional agora. Ele recebe um JSON do tipo <code>TodoCard</code>, transforma esse JSON em um <code>TodoCardDb</code> e envia para a função <code>put_todo</code> inserir no banco de dados. Caso ocorra algum problema com a inserção fazemos pattern matching com o <code>None</code> e retornamos algo como <code>HttpResponse::BadRequest()</code> ou <code>HttpResponse::InternalServerError()</code>, mas caso o retorno seja um id em <code>Some</code>, retornamos um JSON contendo <code>TodoIdResponse</code>. Note que foi necessário adicionar a função <code>body</code> ao <code>HttpResponse::BadRequest()</code> para garantir que os dois pattern matchings tivessem o mesmo tipo de retorno <code>Response</code>, em vez de <code>ResponseBuilder</code>. </p>
<p>Se você estiver utilizando o <code>rust-analyzer</code> do rust, vai perceber que o <code>into</code> de <code>item: todo_card.clone().into(),</code> está destacado, isso se deve ao fato de que precisamos implementar a função <code>into</code> para o tipo <code>TodoCardDB</code> de forma que retorne <code>HashMap&lt;String, AttributeValue&gt;</code>. Para isso, utilizamos a declaração <code>impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb</code> com a seguinte implementação:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/mod.rs
use std::collections::HashMap;

impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb {
    fn into(self) -&gt; HashMap&lt;String, AttributeValue&gt; {
        let mut todo_card = HashMap::new();
        todo_card.insert(&quot;id&quot;.to_string(), val!(S =&gt; self.id.to_string()));
        todo_card.insert(&quot;title&quot;.to_string(), val!(S =&gt; self.title));
        todo_card.insert(&quot;description&quot;.to_string(), val!(S =&gt; self.description));
        todo_card.insert(&quot;owner&quot;.to_string(), val!(S =&gt; self.owner.to_string()));
        todo_card.insert(&quot;state&quot;.to_string(), val!(S =&gt; self.state.to_string()));
        todo_card.insert(&quot;tasks&quot;.to_string(), val!(L =&gt; task_to_db_val(self.tasks)));
        todo_card
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Se você está utilizando <code>rls</code> vai perceber que o <code>state.to_string()</code> e o <code>task_to_db_val</code> estão destacados como errados, assim como a macro <code>val!</code>. Vamos falar do <code>val!</code> logo, mas primeiro vamos entender como funciona a criação do tipo <code>AttributeValue</code> para ser inserido dentro do banco. A função <code>into</code> espera como retorno um tipo <code>HashMap&lt;String, AttributeValue&gt;</code>, no qual <code>AttributeValue</code> é uma struct com a seguinte estrutura:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AttributeValue {
    pub b: Option&lt;Bytes&gt;,
    pub bool: Option&lt;bool&gt;,
    pub bs: Option&lt;Vec&lt;Bytes&gt;&gt;,
    pub l: Option&lt;Vec&lt;AttributeValue&gt;&gt;,
    pub m: Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;,
    pub n: Option&lt;String&gt;,
    pub ns: Option&lt;Vec&lt;String&gt;&gt;,
    pub null: Option&lt;bool&gt;,
    pub s: Option&lt;String&gt;,
    pub ss: Option&lt;Vec&lt;String&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>AttributeValue</code></p>
<p>Os tipos <code>T</code> dentro do <code>Option&lt;T&gt;</code> são os tipos possíveis dentro do DynamoDB. Veja que alguns tipos são bem fáceis de perceber como <code>bool</code>, <code>Vec&lt;AttributeValue&gt;</code> e <code>HashMap&lt;String, AttributeValue&gt;</code>, isto é, um valor booleano, um vetor de atributos do dynamo e um mapa com keys strings e valores como atributos, respectivamente. Outros valores podem ser confusos, como as chaves <code>s</code>, <code>ss</code>, <code>n</code> e <code>ns</code>. As chaves dos tipos <code>b</code> e <code>bs</code> são para valores binários como <code>&quot;B&quot;: &quot;dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk&quot;</code>, além disso o tipo <code>n</code> serve para representar um tipo numérico, enquanto o tipo <code>s</code> serve para tipos String. Os tipos <code>ss</code> e <code>ns</code> são as versões vetores de <code>s</code> e de <code>n</code>, respectivamente.</p>
</blockquote>
<p>Para resovermos a falha de compilação em <code>state.to_string()</code> precisamos implementar a trait <code>std::fmt::Display</code> que nos permite transformar o valor de <code>state</code> em uma String:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl std::fmt::Display for StateDb {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, &quot;{:?}&quot;, self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos verificar a função <code>task_to_db_val</code>, cujo objetivo é transformar um vetor do tipo <code>TaskDb</code> em um vetor de <code>AttributeValue</code>. Essa transformação nos permite inserir as <code>tasks</code> como um único campo contendo um vetor de objetos, como se diria na linguagem JSON, <code>TaskDB</code>. A função <code>task_to_db_val</code> é bastante simples, pois recebe uma <code>tasks</code> do tipo <code>Vec&lt;TaskDb&gt;</code> e aplica um mapa sobre cada <code>TaskDb</code> para substituí-las por um <code>AttributeValue</code> da chave <code>m</code>, <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code>, e depois coleciona todos esses <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code> em um vetor <code>Vec&lt;AttributeValue&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn task_to_db_val(tasks: Vec&lt;TaskDb&gt;) -&gt; Vec&lt;AttributeValue&gt; {
    tasks
        .iter()
        .map(|t| {
            let mut tasks_hash = HashMap::new();
            tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; t.title.clone()));
            tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; t.is_done));
            val!(M =&gt; tasks_hash)
        })
        .collect::&lt;Vec&lt;AttributeValue&gt;&gt;()
}
<span class="boring">}
</span></code></pre></pre>
<p>Ainda falta falarmos da <code>val!</code>. <code>val!</code> é uma macro criada para transformar os valores de nossa struct em valores do DynamoDB. Inseri essa macro em um novo módulo chamado <code>adapter</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
#[macro_export]
macro_rules! val {
    (B =&gt; $bval:expr) =&gt; {{
        AttributeValue::Bool($bval)
    }};
    (L =&gt; $val:expr) =&gt; {{
        AttributeValue::L($val)
    }};
    (S =&gt; $val:expr) =&gt; {{
        AttributeValue::S($val)
    }};
    (M =&gt; $val:expr) =&gt; {{
        AttributeValue::M($val)
    }};
}
<span class="boring">}
</span></code></pre></pre>
<p>Para que essa macro esteja disponível dentro do módulo <code>todo_api</code>, precisamos utilizar <code>#[macro_use]</code> na declaração dos módulos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
pub mod adapter;
pub mod db;
pub mod model;
<span class="boring">}
</span></code></pre></pre>
<p>Agora tudo deve estar funcionando. Podemos executar <code>make db</code> e <code>cargo run</code> para fazer um <code>curl</code> em <code>http://localhost:4000/api/create</code> com o seguinte JSON:</p>
<pre><code class="language-json">{
	&quot;title&quot;: &quot;title&quot;,
	&quot;description&quot;: &quot;descrition&quot;,
	&quot;state&quot;: &quot;Done&quot;,
	&quot;owner&quot;: &quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;,
	&quot;tasks&quot;: [
        {
			&quot;is_done&quot;: true,
			&quot;title&quot;: &quot;blob&quot;
			
		}
    ]
}
</code></pre>
<p>E vamos receber um <code>Uuid</code> como resposta e o status <code>201</code>:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;ae1cb12c-6c67-4337-bd7b-b557d7568c60&quot;
}
</code></pre>
<h3 id="organizando-nosso-código"><a class="header" href="#organizando-nosso-código">Organizando nosso código</a></h3>
<p>Nosso controller possui um conjunto de códigos que não fazem sentido dentro do contexto de controller, no caso a função <code>put_todo</code>. A primeira coisa que vamos fazer é criar um módulo <code>todo</code> dentro de <code>todo_api/db</code> que conterá toda a lógica de banco de dados para o <code>todo</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::helpers::get_client;
use crate::todo_api::db::helpers::TODO_CARD_TABLE;
use aws_sdk_dynamodb::Client;

pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    match client
        .put_item()
        .table_name(TODO_CARD_TABLE.to_string())
        .set_item(Some(todo_card.clone().into()))
        .send()
        .await
    {
        Ok(_) =&gt; Some(todo_card.id),
        Err(_) =&gt; None,
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>E agora podemos simplificar muito nosso controller com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::db:: {helpers::get_client, todo::put_todo};
use crate::todo_api::model::TodoCardDb;
use crate::todo_api_web::model::todo::{TodoCard, TodoIdResponse};
use actix_web::{http::header::ContentType, post, web, HttpResponse, Responder};

#[post(&quot;/api/create&quot;)]
pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = TodoCardDb::new(info);
    let client = get_client().await;
    match put_todo(&amp;client, todo_card).await {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
        .content_type(ContentType::json())
            .body(
                serde_json::to_string(&amp;TodoIdResponse::new(id))
                    .expect(&quot;Failed to serialize todo card&quot;),
            ),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que para declarar todos os módulos internos utilizei o <code>use crate::{// ...}</code>, pois ajuda na organização. Além disso, na minha opinião, a função <code>new</code> de <code>TodoCardDb</code> é um adapter e pode estar mal localizada. Uma possível solução para isso seria mover e renomear a função <code>new</code> para o módulo adapter com nome de <code>todo_json_to_db</code>, mas isso implicaria em tornar todos os campos de <code>TodoCardDb</code> públicos, assim como de <code>TaskDb</code>. Por isso, essa parte da refatoração fica a seu critério de estilo, mas vou fazer para exemplificar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
// ...
use actix_web::web;
use uuid::Uuid;
use crate::{
    todo_api_web::model::{State, TodoCard},
    todo_api::model::{StateDb, TodoCardDb, TaskDb}
};

pub fn todo_json_to_db(card: web::Json&lt;TodoCard&gt;) -&gt; TodoCardDb {
    TodoCardDb {
        id: Uuid::new_v4(),
        title: card.title.clone(),
        description: card.description.clone(),
        owner: card.owner,
        tasks: card
            .tasks
            .iter()
            .map(|t| TaskDb {
                is_done: t.is_done,
                title: t.title.clone(),
            })
            .collect::&lt;Vec&lt;TaskDb&gt;&gt;(),
        state: match card.state {
            State::Doing =&gt; StateDb::Doing,
            State::Done =&gt; StateDb::Done,
            State::Todo =&gt; StateDb::Todo,
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A compilação falha pois <code>StateDB</code> e <code>TaskDB</code> são privados, assim como quase todos campos de <code>TodoCardDb</code>, para isso modificamos o módulo <code>todo_api/model</code> para:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[derive(Debug, Clone)]
pub struct TaskDb {
    pub is_done: bool,
    pub title: String,
}

#[derive(Debug, Clone)]
pub enum StateDb {
    Todo,
    Doing,
    Done,
}

#[derive(Debug, Clone)]
pub struct TodoCardDb {
    pub id: Uuid,
    pub title: String,
    pub description: String,
    pub owner: Uuid,
    pub tasks: Vec&lt;TaskDb&gt;,
    pub state: StateDb,
}

impl TodoCardDb {
    #[allow(dead_code)]
    pub fn get_id(self) -&gt; Uuid {
        self.id
    }
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Também precisamos mudar o controller para utilizar nossa nova função:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use crate::{
    todo_api::{
        db::todo::put_todo,
        adapter
    },
    todo_api_web::model::{TodoCard, TodoIdResponse}
};


pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = adapter::todo_json_to_db(info);

    match put_todo(todo_card) {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(&quot;Failed to serialize todo card&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Uma última refatoração que podemos fazer é a função <code>task_to_db_val</code>, já que sua função é essencialmente transformar <code>TaskDb</code> em um tipo <code>AttributeValue</code>. Assim, podemos implementar uma função que faça isso com <code>TaskDb</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb {
    fn into(self) -&gt; HashMap&lt;String, AttributeValue&gt; {
        let mut todo_card = HashMap::new();
        todo_card.insert(&quot;id&quot;.to_string(), val!(S =&gt; self.id.to_string()));
        todo_card.insert(&quot;title&quot;.to_string(), val!(S =&gt; self.title));
        todo_card.insert(&quot;description&quot;.to_string(), val!(S =&gt; self.description));
        todo_card.insert(&quot;owner&quot;.to_string(), val!(S =&gt; self.owner.to_string()));
        todo_card.insert(&quot;state&quot;.to_string(), val!(S =&gt; self.state.to_string()));
        todo_card.insert(&quot;tasks&quot;.to_string(), 
            val!(L =&gt; self.tasks.into_iter().map(|t| t.to_db_val()).collect::&lt;Vec&lt;AttributeValue&gt;&gt;()));
        todo_card
    }
}

impl TaskDb {
    fn to_db_val(self) -&gt; AttributeValue {
        let mut tasks_hash = HashMap::new();
            tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; self.title.clone()));
            tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; self.is_done));
            val!(M =&gt; tasks_hash)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora faltam alguns testes.</p>
<h2 id="aplicando-testes-a-nosso-endpoint"><a class="header" href="#aplicando-testes-a-nosso-endpoint">Aplicando testes a nosso endpoint</a></h2>
<p>Creio que uma boa abordagem agora seja começar pelos testes mais unitários, por isso vamos começar pelo adapter. Nosso primeiro teste será com a função <code>converts_json_to_db</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use std::collections::HashMap;

    use super::*;
    use crate::{
        todo_api::model::{StateDb, TaskDb, TodoCardDb},
        todo_api_web::model::todo::{State, Task, TodoCard},
    };
    use actix_web::web::Json;

    #[test]
    fn converts_json_to_db() {
        let id = uuid::Uuid::new_v4();
        let owner = uuid::Uuid::new_v4();
        let json = Json(TodoCard {
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: owner,
            state: State::Done,
            tasks: vec![Task {
                is_done: true,
                title: &quot;title&quot;.to_string(),
            }],
        });
        let expected = TodoCardDb {
            id: id,
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: owner,
            state: StateDb::Done,
            tasks: vec![TaskDb {
                is_done: true,
                title: &quot;title&quot;.to_string(),
            }],
        };
        assert_eq!(todo_json_to_db(json, id), expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que, para facilitar a testabilidade, mudamos a assinatura da função para receber um <code>id</code>, <code>todo_json_to_db(json, id)</code>. Isso se deve ao fato de que gerar id randomicamente não ajuda os testes e testar campo a campo não parece uma boa solução. Além disso, adicionamos a macro <code>PartialEq</code> nas structs <code>StateDb</code>, <code>TaskDb</code> e <code>TodoCardDb</code> para fins de comparabilidade. Agora precisamos testar a função <code>to_db_val</code> de <code>TaskDb</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn task_db_to_db_val() {
        let actual = TaskDb {
            title: &quot;blob&quot;.to_string(),
            is_done: true,
        }
        .to_db_val();
        let mut tasks_hash = HashMap::new();
        tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; &quot;blob&quot;.to_string()));
        tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; true));
        let expected = val!(M =&gt; tasks_hash);
        assert_eq!(actual, expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A lógica do teste <code>task_db_to_db_val</code> é basicamente a mesma que a implementação da função, mas já vale como um simples teste unitário. Agora podemos testar a função <code>into</code>, que também teria a mesma implementação da própria função, note que estamos utilizando apenas um id:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
    fn todo_card_db_to_db_val() {
        let id = uuid::Uuid::new_v4();
        let actual: HashMap&lt;String, AttributeValue&gt; = TodoCardDb {
            id: id,
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: id,
            state: StateDb::Done,
            tasks: vec![TaskDb {
                is_done: true,
                title: &quot;title&quot;.to_string(),
            }],
        }
        .into();
        let mut expected = HashMap::new();
        expected.insert(&quot;id&quot;.to_string(), val!(S =&gt; id.to_string()));
        expected.insert(&quot;title&quot;.to_string(), val!(S =&gt; &quot;title&quot;.to_string()));
        expected.insert(
            &quot;description&quot;.to_string(),
            val!(S =&gt; &quot;description&quot;.to_string()),
        );
        expected.insert(&quot;owner&quot;.to_string(), val!(S =&gt; id.to_string()));
        expected.insert(&quot;state&quot;.to_string(), val!(S =&gt; StateDb::Done.to_string()));
        expected.insert(
            &quot;tasks&quot;.to_string(),
            val!(L =&gt; vec![TaskDb {is_done: true, title: &quot;title&quot;.to_string()}.to_db_val()]),
        );
        assert_eq!(actual, expected);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos <code>cargo test</code> enquanto o <code>make db</code> roda, teremos duas situações: uma em que a base de dados já está configurada e tudo ocorre normalmente e outra em que ela não está configurada e o teste falha. Para resolvermos esse problema, bastaria adicionar o <code>create_table</code> ao cenário de teste assim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> #[actix_web::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
<span class="boring">}
</span></code></pre></pre>
<p>É bem claro para mim que um teste que precisa executar o contêiner do banco de dados para passar é bastante frágil. Assim vamos precisar fazer algumas modificações para tornar o teste passável. A mudança que vamos fazer é, na minha opinião, uma forma mais elegante de fazer mocks em rust, pois ela não necessita criar uma trait e uma struct para mockar uma função específica, basta definirmos que para modo de compilação em test, <code>#[cfg(test)]</code>, a função terá outro comportamento, geralmente evitando efeitos colaterais com base de dados. Agora, o que vai mudar é que nosso teste de controller deixará de estar presente na pasta <code>tests</code> e passará a ser um módulo <code>#[cfg(test)]</code> junto ao controller:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod create_todo {
    use crate::todo_api_web::{
        model::TodoIdResponse,
        routes::app_routes
    };

    use actix_web::{
        test, App,
    };
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        // ...
    }

     #[actix_web::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, agora precisamos fazer com que nossa interação com o banco de dados seja &quot;mockada&quot;, para isso reescrevi o módulo <code>src/todo_api/db/todo.rs</code> para conter duas formas de compilacão &quot;com testes&quot; e  &quot;sem testes&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[cfg(not(test))]
pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    use crate::todo_api::db::helpers::TODO_CARD_TABLE;

    match client
        .put_item()
        .table_name(TODO_CARD_TABLE.to_string())
        .set_item(Some(todo_card.clone().into()))
        .send()
        .await
    {
        Ok(_) =&gt; Some(todo_card.id),
        Err(e) =&gt; {
            println!(&quot;{:?}&quot;, e);
            None
        }
    }
}

#[cfg(test)]
pub async fn put_todo(_client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    Some(todo_card.id)
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que <code>put_todo</code> com <code>cfg(test)</code> ativado pula a etapa <code>match client.put_item().table_name(TODO_CARD_TABLE.to_string()).set_item(Some(todo_card.clone().into())).send().await</code> e simplesmente retorna  um <code>Option&lt;Uuid&gt;</code>. </p>
<p>Outro modo de fazer esse teste, utilizando <code>cfg</code>, é utilizar <code>features</code>, mas por ser um pouco mais sensível deixei para apresentar depois. Neste repositório, vamos utilizar <code>features</code> para testar os controllers, o que deixará o código mais limpo, porém mais difícil de gerenciar, podendo fazer com que uma feature indesejada suba para a produção. Assim, recomendo fortemente que os builds de produção utilizem a flag <code>--release</code> e que os <code>cfg</code> mapeie corretamente isso. Para utilizar essa feature, uma boa prática é adicioná-la ao campo <code>[features]</code> do <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;todo-server&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Julia Naomi &lt;jnboeira@outlook.com&gt;&quot;]
edition = &quot;2018&quot;

[features]
dynamo = []

// ...
</code></pre>
<p>Além disso, precisamos gerar a nova função, muito semelhante ao <code>cfg(test)</code> de antes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::model::TodoCardDb;
use aws_sdk_dynamodb::Client;

#[cfg(feature = &quot;dynamo&quot;)]
pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    use crate::todo_api::db::helpers::TODO_CARD_TABLE;

    match client
        .put_item()
        .table_name(TODO_CARD_TABLE.to_string())
        .set_item(Some(todo_card.clone().into()))
        .send()
        .await
    {
        Ok(_) =&gt; Some(todo_card.id),
        Err(e) =&gt; {
            println!(&quot;{:?}&quot;, e);
            None
        }
    }
}

#[cfg(not(feature = &quot;dynamo&quot;))]
pub async fn put_todo(_client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    Some(todo_card.id)
}
<span class="boring">}
</span></code></pre></pre>
<p>E movemos novamente nosso teste para a pasta <code>tests</code>. Para executar todos os testes corretamente usamos <code>cargo teste --features &quot;dynamo&quot;</code>, é sempre bom adicionar este comando a um Makefile.</p>
<pre><code class="language-sh">db:
	docker run -p 8000:8000 amazon/dynamodb-local

test:
	cargo test --features &quot;dynamo&quot;
</code></pre>
<p>O último passo para nossos testes é gerar ums função de teste que nos permita retirar a grosseria que é a função de teste <code>post_todo</code>. Assim, faremos uma função que le um arquivo <code>json</code> e retorna uma string contendo seu conteúdo. Vamos chamá-la de <code>read_json</code> e vai receber como argumento uma string com o nome do arquivo. A primeira mudança que faremos é adicionar <code>mod helpers</code> no arquivo <code>tests/lib.rs</code>. Depois vamos criar o módulo <code>tests/helpers.rs</code> e adicionar a função <code>read_json</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Read;

pub fn read_json(file: &amp;str) -&gt; String {
    let path = String::from(&quot;dev-resources/&quot;) + file;
    let mut file = File::open(&amp;path).unwrap();
    let mut data = String::new();
    file.read_to_string(&amp;mut data).unwrap();
    data
}
<span class="boring">}
</span></code></pre></pre>
<p>Com a função <code>read_json</code> pronta, podemos adicionar o Json <code>post_todo.json</code> na pasta (que vamos criar junto) <code>dev-resources</code> do projeto:</p>
<pre><code class="language-json">{
    &quot;title&quot;: &quot;This is a card&quot;,
    &quot;description&quot;: &quot;This is the description of the card&quot;,
    &quot;owner&quot;: &quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;,
    &quot;tasks&quot;: [
        {
            &quot;title&quot;: &quot;title 1&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 2&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 3&quot;,
            &quot;is_done&quot;: false
        }
    ],
    &quot;state&quot;: &quot;Doing&quot;
}
</code></pre>
<p>Agora, podemos remover a função <code>post_todo()</code> do módulo <code>create_todo</code> encontrado no módulo <code>tests/todo_api_web/controller.rs</code> e adicionar o <code>use</code> da função <code>read_json</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod create_todo {
    // ...
    use crate::helpers::read_json;

    #[actix_web::test]
    async fn valid_todo_post() {
        ...
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>No próximo capítulo vamos aprender a obter todos os <code>TodoCard</code> que criamos na base de dados para depois podermos melhorar as configurações do serviço, por exemplo logs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="obtendo-todas-as-todo-cards-inseridas"><a class="header" href="#obtendo-todas-as-todo-cards-inseridas">Obtendo todas as Todo Cards inseridas</a></h1>
<p>Existem muitas abordagens para como vamos adicionar um novo endpoint no nosso sistema, mas a abordagem que eu gostaria de tratar aqui é a de começar de cima para baixo, ou seja, criamos um endpoint <code>GET</code> que lista todas as <code>TodoCard</code> e nos retorna elas no formato Json. Dessa vez vamos começar escrevendo um teste para este novo endpoint:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod read_all_todos {
    use todo_server::todo_api_web::{
        routes::app_routes
    };

    use actix_web::{
        test, App,
        http::StatusCode,
    };

    #[actix_web::test]
    async fn test_todo_index_ok() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
    
        let req = test::TestRequest::get().uri(&quot;/api/index&quot;).to_request();
    
        let resp = test::call_service(&amp;mut app, req).await;
        assert_eq!(resp.status(), StatusCode::OK);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Felizmente, nosso teste falha retornanto um <code>NOT_FOUND</code> e nos obriga a implementar a nova rota, <code>index</code> em <code>src/todo_api_web/routes.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(ping)
            .service(readiness)
            .service(create_todo)
            .service(show_all_todo)
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora estamos utilizando uma nova função controller chamada de <code>show_all_todo</code>, ela precisa ser incorporada no escopo da função, fazemos isso através de <code>use crate::todo_api_web::controller::todo::show_all_todo</code> e recebemos um aviso de que ela não existe, assim devemos implementá-la no módulo <code>src/todo_api_web/controller/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo() -&gt; impl Responder {
    HttpResponse::Ok()
}
<span class="boring">}
</span></code></pre></pre>
<p>Como nosso teste checa apenas o retorno do status <code>200</code>, isso é suficiente. Nosso próximo passo é implementar um teste um pouco mais robusto. Esse teste consiste em garantir que o JSON recebido possua um vetor de tamanho 1 após um post em <code>api/create</code> ser enviado:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod read_all_todos {
    use serde_json::from_str;
    use todo_server::todo_api_web::{model::todo::TodoCardsResponse, routes::app_routes};

    use actix_web::{body, http::StatusCode, test, App};

    use crate::helpers::read_json;

    #[actix_web::test]
    async fn test_todo_index_ok() {
        // ...
    }

    #[actix_web::test]
    async fn test_todo_cards_count() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
    
        let post_req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();
        
        let _ = test::call_service(&amp;mut app, post_req).await;
        let get_req = test::TestRequest::get().uri(&quot;/api/index&quot;).to_request();
        let resp_body = test::call_service(&amp;mut app, get_req).await.into_body();
        let bytes = body::to_bytes(resp_body).await.unwrap();
        let todo_cards = from_str::&lt;TodoCardsResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        
        assert_eq!(todo_cards.cards.len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para fazer isso vamos criar uma struct serializável para o formato Json. Essa struct se encontrará em <code>sr/todo_api_web/model/mod.rs</code> e se chamará <code>TodoCardsResponse</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct TodoCardsResponse {
    pub cards: Vec&lt;String&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que no momento não precisamos nos preocupar com o tipo de resposta, somente com a struct e seus campos. Agora precisamos fazer nosso controller retornar um vetor com uma String:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//src/todo_api_web/controller/todo.rs
#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo() -&gt; impl Responder {
    HttpResponse::Ok().content_type(ContentType::json()).body(
        serde_json::to_string(&amp;TodoCardsResponse {
            cards: vec![String::from(&quot;test&quot;)],
        })
        .expect(&quot;Failed to serialize todo cards&quot;)
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>Com este teste pronto, nosso próximo teste fica bastante simples, pois agora precisamos fazer um teste quase igual, mas que garanta que o retorno seja um <code>TodoCard</code> com as informações que postamos. Note que como este teste conterá um mock da resposta do banco de dados, podemos simplesmente adicionar um <code>Uuid</code> pré-determinado no mock. Vou criar uma função de teste, no módulo de <code>helpers</code> que retorna um vetor com uma <code>TodoCard</code>, <code>mock_get_todos</code>.</p>
<blockquote>
<p>Note que <code>TodoCard</code> não possui um id, assim temos duas opções: a primeira é criar um <code>TodoCardResponse</code>, que contém um Id e a segunda é modificarmos a <code>TodoCard</code> para conter um campo <code>id: Option&lt;Uuid&gt;</code>. Nós vamos seguir a segunda abordagem, cuja única mudança será adicionar <code>id: None,</code> no teste <code>converts_json_to_db</code> encontrado em <code>src/todo_api/adapter/mod.rs</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use todo_server::todo_api_web::model::todo::{State, Task, TodoCard};

// ...

pub fn mock_get_todos() -&gt; Vec&lt;TodoCard&gt; {
    vec![TodoCard {
        id: Some(uuid::Uuid::from_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
        title: String::from(&quot;This is a card&quot;),
        description: String::from(&quot;This is the description of the card&quot;),
        owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
        tasks: vec![
            Task {
                title: String::from(&quot;title 1&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 2&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 3&quot;),
                is_done: false,
            },
        ],
        state: State::Doing,
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>Com nossa função implementada, podemos criar o novo cenário de teste no submódulo <code>read_all_todos</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> #[actix_web::test]
async fn test_todo_cards_with_value() {
    let mut app = test::init_service(App::new().configure(app_routes)).await;

    let post_req = test::TestRequest::post()
        .uri(&quot;/api/create&quot;)
        .insert_header((CONTENT_TYPE, ContentType::json()))
        .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
        .to_request();

    let _ = test::call_service(&amp;mut app, post_req).await;
    let req = test::TestRequest::with_uri(&quot;/api/index&quot;).to_request();
    let resp_body = test::call_service(&amp;mut app, req).await.into_body();
    let bytes = body::to_bytes(resp_body).await.unwrap();
    let todo_cards: TodoCardsResponse =
        from_str(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();

    assert_eq!(todo_cards.cards, mock_get_todos());
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que agora os tipos de <code>todo_cards.cards, mock_get_todos()</code> são incompatíveis, assim, devemos modificar a a struct <code>TodoCardsResponse</code> para:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, PartialEq)]
pub struct TodoCardsResponse {
    pub cards: Vec&lt;TodoCard&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Também é necessário, para fins de teste, implementarmos a trait <code>PartialEq</code> para todas as structs, e enums, derivadas de <code>TodoCardsResponse</code>. Com essa mudança, precisamos modificar a lógica do nosso controller já que agora é necessário que ele busque <code>TodoCard</code>s no banco. Faremos isso pela função <code>get_todos</code>, que retornará <code>Vec&lt;TodoCard&gt;</code>. Caso o <code>match</code> retorne, não podemos enviar um erro <code>500</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo() -&gt; impl Responder {
    let client = get_client().await;
    let resp = get_todos(&amp;client).await;
    match resp {
        None =&gt; HttpResponse::InternalServerError().body(&quot;Failed to read todo cards&quot;),
        Some(cards) =&gt; HttpResponse::Ok()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;TodoCardsResponse { cards }).expect(ERROR_SERIALIZE)),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar a função <code>get_todos</code>, mas antes vamos implementar a versão de teste (<code>feature = dynamo</code>) da função em <code>src/todo_api/db/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dynamo&quot;)]
pub async fn get_todos(_client: &amp;Client) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use crate::todo_api_web::model::todo::{State, Task};

    Some(vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
        title: String::from(&quot;This is a card&quot;),
        description: String::from(&quot;This is the description of the card&quot;),
        owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
        tasks: vec![
            Task {
                title: String::from(&quot;title 1&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 2&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 3&quot;),
                is_done: false,
            },
        ],
        state: State::Doing,
    }])
}
<span class="boring">}
</span></code></pre></pre>
<p>Ao rodarmos o teste (comente o <code>#[cfg(feature = &quot;dynamo&quot;)]</code>), obtemos sucesso! Agora podemos partir para a leitura da base de dados de fato. Nossa função de <code>get_todos</code> vai precisar de algumas mudanças como receber um <code>client</code> e executar um <code>scan</code> no banco de dados na tabela <code>TODO_CARD_TABLE</code>. Em caso de <code>Err</code> no <code>match</code> retornamos <code>None</code> e em caso de sucesso precisamos passar a função por um <code>adapter</code> que transforma um <code>scan_output</code> em um vetor de <code>TodoCard</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dynamo&quot;))]
pub async fn get_todos(client: &amp;Client) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use crate::todo_api::adapter;

    let scan_output = client
        .scan()
        .table_name(TODO_CARD_TABLE.to_string())
        .limit(100i32)
        .send()
        .await;

    match scan_output {
        Ok(dbitems) =&gt; Some(adapter::scanoutput_to_todocards(
            dbitems.items().unwrap().to_vec(),
        )),
        Err(_) =&gt; None,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que limitamos o scan a <code>100i32</code>, isso se deve ao fato de que o Dynamo não vai responder mais de 100 itens. Se você precisar de mais, é importante realizar filtros no scan. Antes de implementarmos o <code>adapter</code>, seria bom dar uma olhada em como é o resultado do scan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[
    {
        &quot;id&quot;: S(&quot;7d9b9e38-199e-46e1-939c-80e0b10e1674&quot;), 
        &quot;owner&quot;: S(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;), 
        &quot;description&quot;: S(&quot;descrition&quot;), 
        &quot;title&quot;: S(&quot;title&quot;), 
        &quot;tasks&quot;: L([M({&quot;title&quot;: S(&quot;blob&quot;), 
        &quot;is_done&quot;: Bool(true)})]), 
        &quot;state&quot;: S(&quot;Done&quot;)
    }
]
<span class="boring">}
</span></code></pre></pre>
<p>Onde S, L e Bool sao do tipo <code>aws_sdk_dynamodb::model::AttributeValue</code>. Agora podemos começar a implementar a função <code>scanoutput_to_todocards</code> e, para isso, vamos escrever o primeiro teste com apenas um <code>items</code> em <code>src/todo_api/adapters/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod scan_to_cards {
    use aws_sdk_dynamodb::model::AttributeValue;

    use super::scanoutput_to_todocards;
    use crate::todo_api_web::model::todo::{State, Task, TodoCard};

    fn scan_with_one() -&gt; Option&lt;Vec&lt;std::collections::HashMap&lt;String, AttributeValue&gt;&gt;&gt; {
        let tasks = vec![
            (&quot;is_done&quot;.to_string(), AttributeValue::Bool(true)),
            (&quot;title&quot;.to_string(), AttributeValue::S(&quot;blob&quot;.to_string())),
        ];
        let tasks_hash = HashMap::&lt;String, AttributeValue&gt;::from_iter(tasks);

        let values = vec![
            (&quot;title&quot;.to_string(), AttributeValue::S(&quot;title&quot;.to_string())),
            (
                &quot;description&quot;.to_string(),
                AttributeValue::S(&quot;description&quot;.to_string()),
            ),
            (
                &quot;owner&quot;.to_string(),
                AttributeValue::S(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;.to_string()),
            ),
            (
                &quot;id&quot;.to_string(),
                AttributeValue::S(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;.to_string()),
            ),
            (&quot;state&quot;.to_string(), AttributeValue::S(&quot;Done&quot;.to_string())),
            (
                &quot;tasks&quot;.to_string(),
                AttributeValue::L(vec![AttributeValue::M(tasks_hash)]),
            ),
        ];
        let hash = HashMap::&lt;String, AttributeValue&gt;::from_iter(values);

        Some(vec![hash])
    }

    #[test]
    fn scanoutput_has_one_item() {
        let scan = scan_with_one();
        let todos = vec![TodoCard {
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            state: State::Done,
            id: Some(uuid::Uuid::parse_str(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;).unwrap()),
            owner: uuid::Uuid::parse_str(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;).unwrap(),
            tasks: vec![Task {
                is_done: true,
                title: &quot;blob&quot;.to_string(),
            }],
        }];

        assert_eq!(scanoutput_to_todocards(scan).unwrap(), todos)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos finalmente implementar nossa função <code>scanoutput_to_todocards</code> para o caso de 1 <code>items</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scanoutput_to_todocards(scan: Vec&lt;HashMap&lt;String, AttributeValue&gt;&gt;) -&gt; Vec&lt;TodoCard&gt; {
    let item = scan[0].to_owned();
    let id = item.get(&quot;id&quot;).unwrap().as_s().unwrap();
    let owner = item.get(&quot;owner&quot;).unwrap().as_s().unwrap();
    let title = item.get(&quot;title&quot;).unwrap().as_s().unwrap();
    let description = item.get(&quot;description&quot;).unwrap().as_s().unwrap();
    let state = item.get(&quot;state&quot;).unwrap().as_s().unwrap();
    let tasks = item.get(&quot;tasks&quot;).unwrap().as_l().unwrap();

    vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(id).unwrap()),
        owner: uuid::Uuid::parse_str(owner).unwrap(),
        title: title.to_string(),
        description: description.to_string(),
        state: State::from(state),
        tasks: tasks
            .iter()
            .map(|t| Task {
                title: t
                    .as_m()
                    .unwrap()
                    .get(&quot;title&quot;)
                    .unwrap()
                    .as_s()
                    .unwrap()
                    .to_string(),
                is_done: *t.as_m().unwrap().get(&quot;is_done&quot;).unwrap().as_bool().unwrap(),
            })
            .collect::&lt;Vec&lt;Task&gt;&gt;(),
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>Em <code>scanoutput_to_todocards</code>, estamos navegando por dentro dos tipos de <code>AttributeValue</code> e, quando o tipo é um <code>HashMap</code>, utilizamos <code>get</code>. Agora podemos testar o caso para um <code>scan</code> com dois conjuntos de <code>AttributeValue</code>. Para isso, vamos isolar a criação dos <code>HashMap</code> em <code>scan_with_one</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attr_values() -&gt; HashMap&lt;String, AttributeValue&gt; {
    let mut tasks_hash = HashMap::new();
    tasks_hash.insert(&quot;is_done&quot;.to_string(), AttributeValue::Bool(true));
    tasks_hash.insert(&quot;title&quot;.to_string(), AttributeValue::S(&quot;blob&quot;.to_string()));
    let mut hash = HashMap::new();
    hash.insert(&quot;title&quot;.to_string(), AttributeValue::S(&quot;title&quot;.to_string()));
    hash.insert(
        &quot;description&quot;.to_string(),
        AttributeValue::S(&quot;description&quot;.to_string()),
    );
    hash.insert(
        &quot;owner&quot;.to_string(),
        AttributeValue::S(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;.to_string()),
    );
    hash.insert(
        &quot;id&quot;.to_string(),
        AttributeValue::S(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;.to_string()),
    );
    hash.insert(&quot;state&quot;.to_string(), AttributeValue::S(&quot;Done&quot;.to_string()));
    hash.insert(
        &quot;tasks&quot;.to_string(),
        AttributeValue::L(vec![AttributeValue::M(tasks_hash)]),
    );
    hash
}

<span class="boring">}
</span></code></pre></pre>
<p>Assim a função <code>scan_with_one</code> fica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_with_one() -&gt; ScanOutput {
    let hash = attr_values();

    let mut output = ScanOutput::builder().build();
    output.consumed_capacity = None;
    output.count = 1;
    output.items = Some(vec![hash]);
    output.scanned_count = 1;
    output.last_evaluated_key = None;

    output
}
<span class="boring">}
</span></code></pre></pre>
<p>E podemos fazer a <code>scan_with_two</code> ser:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_with_two() -&gt; ScanOutput {
    let hash = attr_values();
    let mut output = ScanOutput::builder().build();

    output.consumed_capacity = None;
    output.count = 2;
    output.items = Some(vec![hash.clone(), hash]);
    output.scanned_count = 2;
    output.last_evaluated_key = None;

    output
}
<span class="boring">}
</span></code></pre></pre>
<p>E assim já implementamos o seguinte teste (lembre-se de adicionar a trait <code>Clone</code> a <code>TodoCard</code> e seus derivados):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn scanoutput_has_two_items() {
    let scan = scan_with_two();
    let todo = TodoCard {
        title: &quot;title&quot;.to_string(),
        description: &quot;description&quot;.to_string(),
        state: State::Done,
        id: Some(uuid::Uuid::parse_str(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;).unwrap()),
        owner: uuid::Uuid::parse_str(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;).unwrap(),
        tasks: vec![Task {
            is_done: true,
            title: &quot;blob&quot;.to_string(),
        }],
    };
    let todos = vec![todo.clone(), todo];

    assert_eq!(scanoutput_to_todocards(scan).unwrap(), todos)
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso teste falha e agora nos permite modificar a função <code>scanoutput_to_todocards</code> para retornar um vetor com todos os <code>TodoCard</code>s contidos em um scan output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scanoutput_to_todocards(output: ScanOutput) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    Some(
        output
            .items()?
            .into_iter()
            .map(|item| {
                let id = item.get(&quot;id&quot;).unwrap().as_s().unwrap();
                let owner = item.get(&quot;owner&quot;).unwrap().as_s().unwrap();
                let title = item.get(&quot;title&quot;).unwrap().as_s().unwrap();
                let description = item.get(&quot;description&quot;).unwrap().as_s().unwrap();
                let state = item.get(&quot;state&quot;).unwrap().as_s().unwrap();
                let tasks = item.get(&quot;tasks&quot;).unwrap().as_l().unwrap();

                TodoCard {
                    id: Some(uuid::Uuid::parse_str(id).unwrap()),
                    owner: uuid::Uuid::parse_str(owner).unwrap(),
                    title: title.to_string(),
                    description: description.to_string(),
                    state: State::from(state),
                    tasks: tasks
                        .iter()
                        .map(|t| Task {
                            title: t
                                .as_m()
                                .unwrap()
                                .get(&quot;title&quot;)
                                .unwrap()
                                .as_s()
                                .unwrap()
                                .to_string(),
                            is_done: *t.as_m().unwrap().get(&quot;is_done&quot;).unwrap().as_bool().unwrap(),
                        })
                        .collect::&lt;Vec&lt;Task&gt;&gt;(),
                }
            })
            .collect(),
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>A mudança que fizemos é bastante simples. Ela simplesmente consiste em transformar a variável <code>item</code> em um argumento da closure de <code>map</code>. Dessa forma, scan vira um iterável com <code>scan.items.unwrap().into_iter()</code> e, depois do <code>map</code>, colecionamos todos os valores com <code>.collect::&lt;Vec&lt;TodoCard&gt;&gt;()</code>. Pronto, <code>adapter</code> feito. Agora podemos utilizar esse <code>adapter</code> na função <code>get_todos</code>. Para testar a mudança, podemos executar a aplicação novamente e testar:</p>
<p><img src="part-1/../imagens/get_todos.png" alt="Obtendo todos nossos TodoCards." /></p>
<p>No próximo capítulo, vamos parar um pouco com a criação de endpoints e entender melhor como tornar nosso serviço mais viável para produção</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tornando-nosso-serviço-mais-realístico"><a class="header" href="#tornando-nosso-serviço-mais-realístico">Tornando nosso serviço mais realístico</a></h1>
<p>Agora vamos aplicar uma série de mudanças em nosso servidor para deixá-lo mais robusto. Algumas dessas mudanças incluem sistemas de logs, conteinerizar a aplicação, tornar ela fault tolerante, headers padrões e mais. Para isso, vamos começar com o mais simples e indispensável, o sistema de logs.</p>
<h2 id="aplicando-logs"><a class="header" href="#aplicando-logs">Aplicando logs</a></h2>
<p>O primeiro passo para começarmos a entender logs em Rust é darmos uma olhada na crate responsável por isso. A crate que vamos utilizar é a <code>log = &quot;0.4.8&quot;</code>, que implementa sua lógica de logs de acordo com a ideia de que um log consiste em um <code>alvo</code>, um <code>nível</code> e um <code>corpo</code>. O alvo é uma string que define o caminho do módulo no qual o requerimento do log é necessário. O nível é a severidade do log, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code> e <code>trace</code>, e o corpo é o conteúdo que o log apresenta. </p>
<p>A crate que vamos utilizar nos disponibiliza cinco macros para isso: <code> error!, warn!, info!, debug!, trace!</code>, dentre as quais <code>error</code> é a mais severa e <code>trace</code> a menos severa. As macros funcionam de forma muito similar ao <code>println!</code>, assim a forma de utilizá-las é bastante intuitiva. Outra questão importante é que o sistema de logs deve ser inicializado apenas uma vez por outra crate, a mais comum delas é a <code>env_logger = &quot;0.9.0&quot;</code>. Um exemplo rápido de como ficaria a combinação dessas duas é:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate log;

fn main() {
    env_logger::init();

    info!(&quot;starting up&quot;);

    // ...
}
</code></pre></pre>
<h3 id="inicializando-o-sistema-de-logs"><a class="header" href="#inicializando-o-sistema-de-logs">Inicializando o sistema de Logs</a></h3>
<p>Para inicializar nosso sistema de logs, precisamos adicionar a crate <code>env_logger</code> ao nosso <code>[dependencies]</code> do <code>Cargo.toml</code>, o <code>env_logger = &quot;0.9.0&quot;</code>. Com a crate disponível, podemos importar o <code>env_logger</code> para o contexto do arquivo <code>main.rs</code> com <code>use env_logger;</code> e inicializá-lo com <code>env_logger::init()</code> conforme o código a seguir:</p>
<pre><pre class="playground"><code class="language-rust">// ...
use env_logger;

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    env_logger::init();
    // ...
}
</code></pre></pre>
<p>Com isso o código parece compilar, mas não conseguimos ver logs no console quando executamos um <code>curl</code>. Isso se deve ao fato de que precisamos informar ao <code>actix_web</code> que queremos que logs de algum nível sejam disponibilizados. Para isso, devemos incluir a linha <code>std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);</code> antes de <code>env_logger::init();</code> na função <code>main</code> para habilitar logs de <code>error</code> a <code>info</code>. Além disso, precisamos disponibilizar o middleware <code>Logger</code> com a forma como queremos o log, note que o middleware pertence à crate <code>actix_web</code>em <code>use actix_web::middleware::Logger;</code>:</p>
<pre><pre class="playground"><code class="language-rust">// ...
use actix_web::middleware::Logger;
use env_logger;
// ...

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);
    env_logger::init();
    create_table().await;
    
    HttpServer::new(|| {
        App::new()
            .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;))
            .configure(app_routes)
            .default_service(web::to(|| HttpResponse::NotFound()))
    })
    .workers(num_cpus::get() - 2)
    .bind((&quot;localhost&quot;, 4004))
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<p>Se fizermos um <code>POST curl</code> agora no endpoint <code>/api/create</code> vamos ver o seguinte log no terminal aonde o servidor está rodando:</p>
<pre><code>[2020-02-08T01:41:32Z INFO  actix_web::middleware::logger] IP:127.0.0.1:54089 DATETIME:2020-02-07T22:41:32-03:00 REQUEST:&quot;POST /api/create HTTP/1.1&quot; STATUS: 201 DURATION:33.976000
</code></pre>
<p>Note que o formato após os colchetes <code>[...]</code> é igual ao que definimos no middleware de <code>Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;)</code>, assim podemos entender alguns dos parâmetros que estamos passando:</p>
<ul>
<li><code>%a</code> é o IP do request.</li>
<li><code>%t</code> é o DateTime do request.</li>
<li><code>%r</code> é o método (<code>POST</code> no caso) seguido do endpoint (<code>/api/create</code>) e o protocolo usado.</li>
<li><code>%s</code> é o status de retorno do request.</li>
<li><code>%D</code> é a duração total do request, em milisegundos.</li>
</ul>
<p>Algumas outras variáveis disponíveis nesse middleware são:</p>
<ul>
<li><code>%t</code> horário no qual o request começou a ser processado.</li>
<li><code>%P</code> o ID do processo filho que serviu o request.</li>
<li><code>%b</code> tamanho da resposta em bytes (inclui os headers).</li>
<li><code>%T</code> duração do request em segundos com fração float de <code>.06f</code>.</li>
<li><code>%{FOO}i</code> headers[‘FOO’] do request.</li>
<li><code>%{FOO}o</code> headers[‘FOO’] da response.</li>
<li><code>%{FOO}e</code> valor da variável de ambiente <code>FOO</code>, <code>os.environ[&quot;FOO&quot;]</code>.
Algumas outras variávels disponíveis neste middleware são:</li>
</ul>
<h3 id="adicionando-logs"><a class="header" href="#adicionando-logs">Adicionando logs</a></h3>
<p>Para adicionar os logs ao nosso código, vamos utilizar duas macros <code>error!</code> e <code>debug!</code>. Para isso, precisamos adicionar <code>log = &quot;0.4&quot;</code> ao nosso <code>[dependencies]</code> no <code>Cargo.toml</code>. A função de <code>debug</code> deverá nos apoiar com resultados no ambiente de desenvolvimento, enquanto a função de <code>error!</code> será exibir os erros no console. Para isso, usaremos o código <code>use log::{error, debug};</code>. Um bom local para inicializar é no <code>create_table</code>, a primeira função que nosso código executa. Para modo debug, utilize a env <code>std::env::set_var(&quot;RUST_LOG&quot;, &quot;debug&quot;);</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::{debug, error};
// ...
pub async fn create_table() {
    let client = get_client().await;
    match client.list_tables().send().await {
        Ok(list) =&gt; {
            match list.table_names {
                Some(table_vec) =&gt; {
                    if table_vec.len() &gt; 0 {
                         error!(&quot;Table already exists and has more then one item&quot;);
                    } else {
                        create_table_input(&amp;client).await
                    }
                }
                None =&gt; create_table_input(&amp;client).await,
            };
        }
        Err(_) =&gt; {
            create_table_input(&amp;client).await;
        }
    }
}

async fn create_table_input(client: &amp;Client) {
    let table_name = TODO_CARD_TABLE.to_string();
    let ad = build_attribute_definition();
    let ks = build_key_schema();
    let pt = build_provisioned_throughput();

    match client
        .create_table()
        .table_name(table_name)
        .key_schema(ks)
        .attribute_definitions(ad)
        .provisioned_throughput(pt)
        .send()
        .await
    {
        Ok(output) =&gt; {
            debug!(&quot;Table created {:?}&quot;, output);
        }
        Err(error) =&gt; {
            error!(&quot;Could not create table due to error: {:?}&quot;, error);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Outro lugar em que podemos aplicar logs é no arquivo <code>src/todo_api/db/todo.rs</code>, pois as funções de <code>put</code> e <code>get</code> são bastante suscetíveis a erros. Assim podemos modificar o arquivo para:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use log::{debug, error};

#[cfg(not(feature = &quot;dynamo&quot;))]
pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    match client
        .put_item()
        .table_name(TODO_CARD_TABLE.to_string())
        .set_item(Some(todo_card.clone().into()))
        .send()
        .await
    {
        Ok(_) =&gt; {
            debug!(&quot;item created with id {:?}&quot;, todo_card.id);
            Some(todo_card.id)
        }
        Err(e) =&gt; {
            error!(&quot;error when creating item {:?}&quot;, e);
            None
        }
    }
}


#[cfg(not(feature = &quot;dynamo&quot;))]
pub async fn get_todos(client: &amp;Client) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    // ...
    match scan_output {
        Ok(dbitems) =&gt; {
            let res = adapter::scanoutput_to_todocards(dbitems)?.to_vec();
            debug!(&quot;Scanned {:?} todo cards&quot;, dbitems);
            Some(res)
        }
        Err(e) =&gt; {
            error!(&quot;Could not scan todocards due to error {:?}&quot;, e);
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que nos casos de <code>Err</code> agora estamos logando o motivo com <code>e</code>. O último passo para este momento é adicionar logs aos controllers em <code>src/todo_api_web/controllers/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::{error};
// ...

#[post(&quot;/api/create&quot;)]
pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let id = Uuid::new_v4();
    let todo_card = adapter::todo_json_to_db(info, id);
    let client = get_client().await;
    match put_todo(&amp;client, todo_card).await {
        None =&gt; {
            error!(&quot;Failed to create todo card&quot;);
            HttpResponse::BadRequest().body(ERROR_CREATE)
        }
        Some(id) =&gt; HttpResponse::Created()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(ERROR_SERIALIZE)),
    }
}

#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo() -&gt; impl Responder {
    let client = get_client().await;
    let resp = get_todos(&amp;client).await;
    match resp {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::InternalServerError().body(ERROR_READ)
        }
        Some(cards) =&gt; HttpResponse::Ok()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;TodoCardsResponse { cards }).expect(ERROR_SERIALIZE)),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que adicionamos somente a opção de <code>error</code> já que o <code>None =&gt; {...}</code> é a única resposta que pode conter diversas razões, pelo fato do <code>Some</code> já estar mapeado em <code>put_todo</code> e <code>get_todos</code>.</p>
<h2 id="incluindo-docker"><a class="header" href="#incluindo-docker">Incluindo Docker</a></h2>
<p>Como o foco deste livro não é docker e ele não é um requisito para entender o livro, vou mostrar o código e explicar um pouco o que está acontecendo. Assim vamos começar por um <code>Dockerfile</code> extremamente simples.</p>
<pre><code class="language-Dockerfile">FROM rustlang/rust:nightly

RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app

COPY . /usr/src/app

CMD [&quot;cargo&quot;, &quot;build&quot;, &quot;-q&quot;]
</code></pre>
<p>A primeira diretiva, a <code>FROM</code>, tem como objetivo definir a imagem base para nosso contêiner. Nesse caso, estamos utilizando uma versão <code>nightly</code> do Rust, pois a versão stable não era compatível com a versão da minha máquina quando escrevi este livro. Depois disso, temos a diretiva <code>RUN</code>, que executa algum comando, no nosso caso a criação da pasta <code>/usr/src/app</code>, e já definimos essa pasta como o diretório que vamos utilizar com <code>WORKDIR</code>. Depois disso, copiamos todo nosso código para nosso diretório com <code>COPY</code> e executamos um comando do cargo, o <code>build</code>, para construir nossa aplicação, <code>cargo build -q</code> com <code>CMD</code>. Outra opção de <code>Dockerfile</code> com otimização para builds repetidos é:</p>
<pre><code class="language-Dockerfile">FROM rust:latest

RUN mkdir -p /usr/src/
WORKDIR /usr/src/
RUN USER=root cargo new --bin app
WORKDIR /app

COPY ./Cargo.lock ./Cargo.lock
COPY ./Cargo.toml ./Cargo.toml
COPY ./tests ./tests

RUN cargo build --release
RUN rm src/*.rs

COPY ./src ./src

CMD [&quot;cargo&quot;, &quot;build&quot;, &quot;--release&quot;]
</code></pre>
<p>O objetivo desse segundo <code>Dockerfile</code> é diminuir o tempo de execução do contêiner ao cachear as dependências do app e somente atualizar o cache a partir do <code>COPY ./src ./src</code>.</p>
<p>Com este container pronto, podemos começar a pensar em como utilizar os dois containers (DynamoDB e <code>todo_server</code>) em conjunto. Faremos isso com <code>docker-compose.yml</code>:</p>
<pre><code class="language-yml">version: '3.8'
services:
  dynamodb-local:
    command: &quot;-jar DynamoDBLocal.jar -sharedDb -dbPath ./data&quot;
    image: amazon/dynamodb-local
    container_name: dynamodb-local
    ports:
      - &quot;8000:8000&quot;
    volumes:
      - &quot;./docker/dynamodb:/home/dynamodblocal/data&quot;
    working_dir: /home/dynamodblocal
  web:
    build:
      context: .
      dockerfile: Dockerfile
    command: cargo run
    ports:
      - &quot;4000:4000&quot;
    depends_on:
      - &quot;dynamodb-local&quot;
    links:
      - &quot;dynamodb-local&quot;
    environment:
      # Since we are using dynamodb local, the IAM authentication mechanism is not used at all. 
      # That is, whichever credentials you provide, it will be accepted
      AWS_ACCESS_KEY_ID: 'MYID'
      AWS_SECRET_ACCESS_KEY: 'MYSECRET'
      AWS_REGION: 'us-east-1'
      DYNAMODB_ENDPOINT: 'dynamodb-local'
</code></pre>
<p>Nosso <code>docker-compose</code> precisa de duas chaves principais: <code>version</code>, que corresponde à versão do compose, <code>services</code>, que corresponde aos contêineres que vamos rodar. Em <code>services</code>, precisamos declarar dois contêineres <code>web</code>, os quais conterão nossa aplicação e o contêiner <code>dynamodb</code>, que conterá a imagem do <strong>DynamoDB</strong> e veio (desse tutorial)[https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.DownloadingAndRunning.html]. O contêiner <code>dynamodb</code> possui as seguintes chaves:</p>
<ul>
<li><code>container_name</code>: é o nome do contêiner, no nosso caso <code>dynamodb</code>.</li>
<li><code>image</code>: a fonte da imagem que estamos utilizando, no caso do DynamoDB é <code>amazon/dynamodb-local</code>.</li>
<li><code>ports</code>: o mapeamento de portas de dentro do contêiner para fora, <code>8000:8000</code>.</li>
<li><code>volumes</code>: volumes disponíveis para o dynamo utilizar, <code>dynamodata:/home/dynamodblocal/</code>.</li>
<li><code>working_dir</code>: diretório no qual o dynamo executará, <code>/home/dynamodblocal/</code>.</li>
<li><code>command</code>: para inicializar o dynamo <code>&quot;-jar DynamoDBLocal.jar -sharedDb -dbPath .&quot;</code>.</li>
</ul>
<p>Depois disso temos o <code>web</code> que irá rodar a todo API, que não vou repetir algumas chaves:</p>
<ul>
<li><code>build</code>: o contexto de criação da imagem, <code>context: .</code>. No caso, estamos passando um dockerfile chamado <code>Dockerfile</code> <code>dockerfile: Dockerfile</code>.</li>
<li><code>command</code>: executamos o comando <code>cargo run</code> para essa aplicação.</li>
<li><code>environment</code>: para executar o DynamoDB dessa forma precisamos adicionar algumas variáveis de ambiente para que o <code>client</code> configure suas credenciais,
de acordo com https://docs.aws.amazon.com/sdk-for-rust/latest/dg/dynamodb-local.html.
<ul>
<li><code>AWS_ACCESS_KEY_ID=AKIDLOCALSTACK</code></li>
<li><code>AWS_SECRET_ACCESS_KEY=localstacksecret</code></li>
<li><code>AWS_REGION=us-east-1</code></li>
<li><code>DYNAMODB_ENDPOINT=dynamodb-local</code> 
Usaremos a variável de ambiente <code>DYNAMODB_ENDPOINT</code> para saber qual address iremos usar quando inicializarmos
o dynamodb client na nossa API. Faremos a seguinte mudança na função <code>get_client</code>:</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/db/helpers.rs
pub async fn get_client() -&gt; Client {
    let config = aws_config::load_from_env().await;

    let addr = if let Ok(db_endpoint) = std::env::var(&quot;DYNAMODB_ENDPOINT&quot;) {
        format!(&quot;http://{}:8000&quot;, db_endpoint)
    } else {
        &quot;http://0.0.0.0:8000&quot;.to_string()
    };

    let dynamodb_local_config = aws_sdk_dynamodb::config::Builder::from(&amp;config)
        .endpoint_resolver(Endpoint::immutable(addr.parse().expect(&quot;Invalid URI&quot;)))
        .build();
    Client::from_conf(dynamodb_local_config)
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>depends_on</code>: define a ordem na qual os serviços devem ser inicializados, assim <code>dynamodb</code> é inicializado antes de <code>web</code></li>
<li><code>links</code>: forma legada de fazer com que dois serviços estejam conectados, atualmente bastaria o <code>networks</code>, mas coloquei como exemplo. No caso de <code>links</code> e <code>networks</code> estarem definidos, é preciso que ambos estejam na mesma rede.</li>
</ul>
<p>Se tivéssemos as configurações de produção, poderíamos criar a feature <code>compose</code> para utilizar com o <code>docker-compose</code>. Se executarmos o código agora com <code>docker-compose up --build</code> e, em seguida, um <code>curl</code>, tudo voltará a funcionar como antes. Outra coisa que podemos fazer agora é atualizar nosso Makefile para incluir o <code>docker-compose</code>:</p>
<pre><code class="language-sh">db:
	docker run -p 8000:8000 amazon/dynamodb-local

test:
	cargo test --features &quot;dynamo&quot;

run-local:
	cargo run --features &quot;dynamo&quot;

run:
	docker-compose up --build

down:
	docker-compose down
</code></pre>
<h2 id="headers-padrões"><a class="header" href="#headers-padrões">Headers padrões</a></h2>
<p>Outro ponto que acredito ser importante é o uso de headers para identificar os requests nos logs. Costumo ver o padrão de um header chamado <code>x-request-id</code> cujo valor é um <code>uuid</code>. Para implementarmos esse padrão com o actix, precisamos utilizar um middleware que felizmente a equipe do actix já disponibilizou para nós, o <code>actix_web::middleware::DefaultHeaders</code>. Para isso, precisamos disponibilizá-lo no escopo com <code>use</code> e depois passar essa informação para um <code>wrap</code>. A forma de utilizar esses headers padrões é <code>DefaultHeaders::new().header(&quot;X-Version&quot;, &quot;0.2&quot;)</code>, isto é, criamos um novo header com <code>DefaultHeaders::new()</code> e depois chamamos a função <code>header</code> para adicionar um header com os argumentos-chave e valor do tipo string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/main.rs
// ...
HttpServer::new(|| {
    App::new()
        .wrap(DefaultHeaders::new().add((&quot;x-request-id&quot;, Uuid::new_v4().to_string())))
        .wrap(Logger::new(
            &quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;,
        ))
        .configure(app_routes)
    })
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, precisamos definir o header no <code>Logger</code>, para isso usamos a chave <code>X-REQUEST-ID:%{x-request-id}o</code> após a <code>DURATION</code>, pois somente assim o valor de <code>x-request-id</code> será logado:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
HttpServer::new(|| {
    App::new()
        .wrap(DefaultHeaders::new().add((&quot;x-request-id&quot;, Uuid::new_v4().to_string())))
        .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D X-REQUEST-ID:%{x-request-id}o&quot;))
        .configure(app_routes)
    })
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Um exemplo de resposta seria:</p>
<pre><code>[2020-02-08T23:10:58Z INFO  actix_web::middleware::logger] IP:172.21.0.1:52686 DATETIME:2020-02-08T23:10:58Z REQUEST:&quot;POST /api/create HTTP/1.1&quot; STATUS: 201 DURATION:166.921700 X-REQUEST-ID=bd15de62-1ba6-4d43-89ca-4f89418
</code></pre>
<h2 id="adicionando-o-cliente-ao-estado-da-api"><a class="header" href="#adicionando-o-cliente-ao-estado-da-api">Adicionando o cliente ao estado da API</a></h2>
<p>Nosso próximo passo vem de uma necessidade de refactor e preparação para o código futuro. Esse refactor consiste em retirar a declaração de <code>let cliente = client();</code> de todos os códigos envolvendo banco de dados e passá-los como argumentos. Uma das vantagens disso é caso decidamos ter mais clientes de algum tipo de serviço como outros bancos de dados ou S3. Para fazermos isso, vamos criar uma nova struct chamada <code>Clients</code> que conterá o campo <code>dynamo</code> e depois a passaremos como argumento para o <code>HttpServer</code> via função <code>data</code>.</p>
<p>Assim, nosso primeiro passo é descrever a o modelo de <code>Clients</code> em <code>src/todo_api_web/model/http.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use aws_sdk_dynamodb::Client;

use crate::todo_api::db::helpers::get_client;

#[derive(Clone)]
pub struct Clients {
    pub dynamo: Client,
}

impl Clients {
    pub async fn new() -&gt; Self {
        Self {
            dynamo: get_client().await,
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos utilizar a função <code>app_data</code> em <code>HttpServer</code> para passar Clients como argumento. Fazemos isso com <code>Clients::new()</code>:</p>
<pre><pre class="playground"><code class="language-rust">// ...
use todo_server::{
    todo_api::db::helpers::create_table,
    todo_api_web::{model::http::Clients, routes::app_routes},
};

#[actix_web::main]
async fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);
    env_logger::init();

    let client = web::Data::new(Clients::new().await);
    create_table(&amp;client.dynamo.clone()).await;

    HttpServer::new(move|| {
        App::new()
            .app_data(client.clone())
            .wrap(DefaultHeaders::new().add((&quot;x-request-id&quot;, Uuid::new_v4().to_string())))
            .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D X-REQUEST-ID:%{x-request-id}o&quot;))
            .configure(app_routes)
    })
    .workers(num_cpus::get() - 2)
    .max_connections(30000)
    .bind((&quot;0.0.0.0&quot;, 4000))
    .unwrap()
    .run()
    .await
}
// ...
</code></pre></pre>
<p>Com isso temos <code>Clients</code> disponível no nos nossos controllers, para isso adicionamos o estado com <code>state: web::Data&lt;Clients&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use crate::todo_api_web::model::http::Clients;

#[post(&quot;/api/create&quot;)]
pub async fn create_todo(state: web::Data&lt;Clients&gt;, info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let id = Uuid::new_v4();
    let todo_card = adapter::todo_json_to_db(info, id);
    let client = state.dynamo.clone();
//...
}

#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo(state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let client = state.dynamo.clone();
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>As funcões <code>put_todo</code> e <code>get_todos</code> ja esperam um argumento do tipo <code>aws_sdk_dynamodb::Client</code> então
não será preciso modificar elas.</p>
<p>Feito isso, devemos adicionar o novo client a todos os testes de integração, pois esse argumento é esperado nas funções de controller. Um exemplo seria:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[actix_web::test]
    async fn test_todo_cards_count() {
        let client = web::Data::new(Clients::new().await);
        let mut app =
            test::init_service(App::new().app_data(client.clone()).configure(app_routes)).await;
    //...
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="serializando-o-response"><a class="header" href="#serializando-o-response">Serializando o Response</a></h3>
<p>Até o momento estávamos utilizando o formato de criação de <code>HttpResponse</code> da seguinte maneira <code>HttpResponse::Ok().content_type(&quot;application/json&quot;).body(serde_json::to_string(&amp;struct).expect(&quot;Failed to serialize todo cards&quot;))</code>, mas existe uma forma que pode simplificar nossa vida por nos permitir delegar a chamada de <code>serde_json</code>. Esse formato substitui o <code>.body(...)</code> por <code>.json(...)</code>. A vantagem de se utilizar esse formato é que ele reduz a quantidade de código que nós devemos manter, delegando ao actix essa responsabilidade. Nos capítulos introdutórios do livro, falamos que o actix estava com muita vantagem em relação a outros frameworks nos benchmarks da TechEmpower, porém, no caso de serialização JSON, existem alguns frameworks C/C++ à sua frente, inclusive a crate <code>hyper</code>. O Objetivo de <code>body</code> é principalmente enviar mensagens sem dados estruturados ou estruturados em outros formatos como <a href="https://crates.io/crates/edn-rs">Edn</a>.</p>
<p>Com esse pequeno refactor, nossos controllers de <code>todo</code> serão modificados para o seguinte formato:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_web_api/controller/todo.rs
// ...
#[post(&quot;/api/create&quot;)]
pub async fn create_todo(state: web::Data&lt;Clients&gt;, info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let id = Uuid::new_v4();
    let todo_card = adapter::todo_json_to_db(info, id);
    let client = state.dynamo.clone();

    match put_todo(&amp;client, todo_card).await {
        None =&gt; {
            error!(&quot;Failed to create todo card {}&quot;, ERROR_CREATE);
            HttpResponse::BadRequest().body(ERROR_CREATE)
        }
        Some(id) =&gt; HttpResponse::Created()
            .content_type(ContentType::json())
            .json(TodoIdResponse::new(id)),
    }
}

#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo(state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let client = state.dynamo.clone();
    let resp = get_todos(&amp;client).await;
    match resp {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::InternalServerError().body(ERROR_READ)
        }
        Some(cards) =&gt; HttpResponse::Ok()
            .content_type(ContentType::json())
            .json(TodoCardsResponse { cards }),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com isso, nosso código está pronto para receber novos clientes e nós podemos começar a pensar em autenticação.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autenticação"><a class="header" href="#autenticação">Autenticação</a></h1>
<p>Criaremos funções do serviço para registrar e para fazer login no nosso serviço. Além disso, implementaremos um middleware que protege nossos endpoints de usuários não autenticados. Para realizar isso vamos utilizar a crate <code>Diesel</code> para lidar com a base de dados, que será o Postgres. Para isso precisamos seguir alguns passos (também em https://diesel.rs/guides/getting-started):</p>
<ol>
<li>Instale a <code>diesel_cli</code>, pois este binário ajuda a gerenciar o projeto. Utilize <code>cargo install diesel_cli</code> para isso. Para compilar o <code>diesel_cli</code> é preciso ter a lib <code>libpq</code>, no MacOS podemos fazer isso com <code>brew install postgresql</code>, <code>brew install libpq</code> e depois <code>cargo install diesel_cli --no-default-features --features postgres</code> para instalar somente o conector de <code>postgres</code>. </li>
<li>Ter um container disponível <code>docker run -i --rm --name auth-db -p 5432:5432 -e POSTGRES_USER=auth -e POSTGRES_PASSWORD=secret -d postgres</code></li>
<li>Para utilizar o <code>diesel_cli</code> executamos o comando <code>diesel setup</code>, mas para isso precisamos da url do postgress em um arquivo <code>.env</code>. Para isso precisamos executar <code>echo DATABASE_URL=postgres://auth:secret@localhost/auth_db &gt; .env</code>. Agora executamos <code>diesel setup --migration-dir src/migrations</code> para estabelecer a conexão.</li>
<li>Depois podemos criar nossas migrações com <code>diesel migration generate create_auth</code>, note a pasta <code>migrations</code> com duas subpastas cada uma contendo um <code>up.sql</code> e um <code>down.sql</code>.</li>
<li>Na segunda pasta vamos criar a tabela <code>auth_user</code> em <code>up.sql</code>:</li>
</ol>
<pre><code class="language-sql">-- up.sql
CREATE TABLE auth_user (
    email VARCHAR(100) NOT NULL PRIMARY KEY,
    id UUID NOT NULL,
    password VARCHAR(64) NOT NULL, --bcrypt hash
    expires_at TIMESTAMP NOT NULL
);
</code></pre>
<pre><code class="language-sql">--down.sql
DROP TABLE auth_user;
</code></pre>
<ol start="6">
<li>Agora basta executar as migrations com <code>diesel migration run --migration-dir src/migrations</code>, caso você queira reverter as migrations basta executar <code>diesel migration redo</code>. Note a criação de um arquivo <code>src/schema.rs</code> em nosso projeto:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table! {
    auth_user (email) {
        email -&gt; Varchar,
        id -&gt; Uuid,
        password -&gt; Varchar,
        expires_at -&gt; Timestamp,
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A macro table! gera código baseado no schema da base de dados que representes todas as tabelas e colunas.</p>
</blockquote>
<ol start="7">
<li>Tipicamente um schema não é criado na mão e sim gerado pelo binário <code>diesel</code>. Quando executamos <code>diesel setup</code>, um arquivo <code>diesel.toml</code> é criado para indicar ao <code>Diesel</code> para manter o arquivo <code>src/schema.rs</code> por nós.</li>
</ol>
<blockquote>
<p>Nota sobre Diesel em Produção</p>
<p>Quando em produção você talvez prefira executar suas migrações na inicialização da aplicação. Assim, a <a href="https://docs.diesel.rs/master/diesel_migrations/macro.embed_migrations.html_">crate Diesel disponibiliza a macro</a> <code>embed_migrations!</code>, permitindo embedar os scripts de migração como parte final do binário. Para usá-la, basta usar um snippet similar ao abaixo no início de suas <code>main</code> e as migrações serão executadas.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!(&quot;../../migrations/postgresql&quot;);

fn run_migrations(connection: &amp;mut impl MigrationHarness&lt;DB&gt;) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync + 'static&gt;&gt; {
   connection.run_pending_migrations(MIGRATIONS)?;

   Ok(())
}
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<h2 id="configurando-o-postgres-com-rust"><a class="header" href="#configurando-o-postgres-com-rust">Configurando o Postgres com Rust</a></h2>
<p>Agora podemos começar a evoluir a autenticação do nosso servidor, para isso devemos adicionar algumas crates ao <code>[dependencies]</code> do Cargo.toml:</p>
<pre><code class="language-toml">actix = &quot;0.11.0&quot;
chrono = { version = &quot;0.4.23&quot;, features = [&quot;serde&quot;] }
diesel = {version = &quot;2.0.2&quot;, features = [&quot;chrono&quot;, &quot;postgres&quot;, &quot;r2d2&quot;, &quot;uuid&quot;]}
dotenv = &quot;0.15.0&quot;
r2d2 = &quot;0.8.10&quot;
</code></pre>
<p>A abordagem que vamos seguir aqui é diferente da apresentada no guia do diesel, consulte bibliografia para obter o link, pois vamos tentar tirar proveito do sistema de actors do actix (caso você queira, é um bom exercício aplicar a mesma estratégia ao <code>Client</code>). Assim, em nosso módulo <code>src/todo_api/db/helpers.rs</code> vamos criar uma struct <code>DbExecutor</code>, com um tipo de conexão de pool, que vai implementar a trait <code>Actor</code> do actix:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, SyncContext};
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool};

pub struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;);

impl Actor for DbExecutor {
    type Context = SyncContext&lt;Self&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Actors</p>
<p>Actors se comunicam exclusivamente pela troca de mensagens. Assim, o actor que envia a mensagem irá, opcionalmente, esperar pela respostas. Além disso, actors não são referenciados diretamente, mas sim pelos seus endereços. Qualquer tipo no Rust pode se tornar um actor, o único requerimento é que implemente a trait <code>Actor</code>.</p>
</blockquote>
<p>Depois disso precisamos adicionar a struct <code>DbExecutor</code> ao nosso <code>Clients</code>, porém nosso <code>DbExecutor</code> vai precisar precisar ser envelopado em um <code>Addr&lt;T&gt;</code>, que corresponde ao endereço do actor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/model/http.rs
use actix::prelude::Addr;
use crate::todo_api::db::helpers::{client, DbExecutor};

#[derive(Clone)]
pub struct Clients {
    pub dynamo: aws_sdk_dynamodb::Client,
    pub postgres: Addr&lt;DbExecutor&gt;,
}

impl Clients {
    pub fn new(pg: Addr&lt;DbExecutor&gt;) -&gt; Self {
        Self { 
            dynamo: client(),
            postgres: pg
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos de uma função que crie o <code>Addr&lt;DbExecutor&gt;</code> para podemos enviar como argumento ao <code>new</code>. Essa função se chamara <code>db_executor_address</code> e estará localizada em <code>src/todo_api/db/helpers.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Addr, SyncContext, SyncArbiter};
// ...
use diesel::{
    r2d2::{ConnectionManager, Pool},
    pg::PgConnection
};
use std::env;

// ...

pub struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;);

impl Actor for DbExecutor {
    type Context = SyncContext&lt;Self&gt;;
}

pub fn db_executor_address() -&gt; Addr&lt;DbExecutor&gt; {
    let database_url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);

    let manager = ConnectionManager::&lt;PgConnection&gt;::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect(&quot;Failed to create pool.&quot;);

    SyncArbiter::start(4, move || DbExecutor(pool.clone()))
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos modificar a função <code>Clients::new</code> para que não seja preciso passar <code>Addr&lt;DbExecutor&gt;</code> como argumento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::db::helpers::{client, DbExecutor, db_executor_address};
use actix::prelude::Addr;
use aws_sdk_dynamodb::Client;

#[derive(Clone)]
pub struct Clients {
    pub dynamo: aws_sdk_dynamodb::Client,
    pub postgres: Addr&lt;DbExecutor&gt;,
}

impl Clients {
    pub fn new() -&gt; Self {
        Self {
            dynamo: client(),
            postgres: db_executor_address(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ao executar o código obtemos uma falha, pois <code>DATABASE_URL</code> não está setada, agora precisamos utilizar as configurações do postgres para o <code>docker-compose</code>:</p>
<pre><code class="language-yml"># ...
services:
# ...
  web:
  environment:
      # ...
      DATABASE_URL: 'postgres://auth:secret@postgres:5432/auth_db'
  postgres:
    container_name: &quot;postgres&quot;
    image: postgres
    ports:
      - &quot;5432:5432&quot;
    environment:
      - POSTGRES_USER=auth
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=auth_db
# ...
</code></pre>
<p>Para isso precisamos remover nosso <code>env_logger</code> do nosso código e Cargo.toml. Além disso, a definição da variável de ambiente do log passa para o arquivo <code>.env</code>:</p>
<pre><code>DATABASE_URL=postgres://auth:secret/auth_db
RUST_LOG=actix_web=info
</code></pre>
<p>Agora precisamos executar as migrações no docker compose, para isso vamos utilizar <code>embed_migrations!</code> migrations como falamos anteriormente. A macro <code>embed_migrations!</code> está disponível na crate <code>diesel_migrations = &quot;2.0.0&quot;</code>, adicione ela a seu <code>[dependencies]</code> do Cargo.toml. E agora precisamos que o código execute a migração. Para isso adicionamos a função <code>run_migrations</code> em <code>create_table</code>, no módulo <code>src/todo_api/db/helpers.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Addr, SyncArbiter, SyncContext};
use diesel::{
    prelude::*,
    r2d2::{ConnectionManager, Pool},
};
use diesel_migrations::run_pending_migrations;
use log::{debug, error};
use std::env;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!(&quot;src/migrations&quot;);

// ...

pub async fn create_table(client: &amp;Client) {
    let database_url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);
    let mut pg_conn = PgConnection::establish(&amp;database_url)
        .expect(&amp;format!(&quot;Error connecting to {}&quot;, database_url));

    run_migrations(&amp;mut pg_conn);
    match client.list_tables().send().await {
        Ok(list) =&gt; {
            match list.table_names {
                Some(table_vec) =&gt; {
                    if table_vec.len() &gt; 0 {
                        println!(&quot;Error: {:?}&quot;, &quot;Table already exists&quot;);
                    } else {
                        create_table_input(&amp;client).await
                    }
                }
                None =&gt; create_table_input(&amp;client).await,
            };
        }
        Err(_) =&gt; {
            create_table_input(&amp;client).await;
        }
    }
}

fn run_migrations(pg_conn: &amp;mut PgConnection) {
    match pg_conn.run_pending_migrations(MIGRATIONS) {
        Ok(_) =&gt; debug!(&quot;auth database created&quot;),
        Err(_) =&gt; error!(&quot;auth database creation failed&quot;),
    };
}
// ...
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Cuidado pois esta configuração do docker-compose pode consumir muita memória. Pode ser interessante executar um <code>docker system prune --volumes</code> caso seu docker falhe. </li>
</ul>
<h2 id="criando-o-endpoint-de-cadastro-de-usuários"><a class="header" href="#criando-o-endpoint-de-cadastro-de-usuários">Criando o endpoint de cadastro de usuários</a></h2>
<p>Nosso próximo passo é modelar o domínio de autenticação em <code>todo_api</code>, chamaremos nossa struct de <code>User</code> e incluiremos no módulo <code>src/todo_api/model/auth.rs</code>. A primeira coisa que devemos fazer é declarar <code>mod schema</code> em <code>main.rs</code> e <code>lib.rs</code>, e por motivos de agilidade utilizar <code>#[macro_use] extern crate diesel_migrations;</code> e <code>#[macro_use] extern crate diesel;</code> para disponibilizar as macros utilizads em <code>schema.rs</code>. Depois disso, podemos criar nossa struct <code>User</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::schema::*;

#[derive(Debug, Serialize, Deserialize, Queryable, Insertable)]
#[diesel(table_name = auth_user)]
pub struct User {
    email: String,
    id: uuid::Uuid,
    password: String,
    expires_at: chrono::NaiveDateTime,
}
<span class="boring">}
</span></code></pre></pre>
<p>Utilizamos a linha <code>use crate::schema::*;</code> para disponibilizar a tabela <code>auth_user</code> neste contexto para que a &quot;anotação&quot; <code>table_name</code> funcione. Além disso, aplicamos as macros <code>Queryable, Insertable</code> para que possamos utilizar nossa struct com o postgres. Agora sabemos que vamos receber 2 argumentos para criar um user, que serão <code>email</code> e <code>password</code>, com isso podemos presupor que vamos precisar implementar uma função que gere um tipo <code>User</code> destes dois argumentos, algo como <code>fn from(email: String, password: String) -&gt; User</code>. Assim, podemos implementar um teste para esta funcão. Para este teste vamos ter que adicionar a crate <code>regex = &quot;1.3.4&quot;</code> ao nosso <code>[dev-dependencies]</code> do Cargo.toml:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;
    use regex::Regex;

    #[test]
    fn user_is_correctly_created() {
        let user = User::from(String::from(&quot;email&quot;), String::from(&quot;password&quot;));
        let rx = Regex::new(&quot;[0-9]{4}-[0-1]{1}[0-9]{1}-[0-3]{1}[0-9]{1} [0-2]{1}[0-9]{1}:[0-6]{1}[0-9]{1}:[0-6]{1}[0-9]{1}&quot;).unwrap();

        assert_eq!(user.email, String::from(&quot;email&quot;));
        assert_eq!(user.password, String::from(&quot;password&quot;));
        assert!(uuid::Uuid::parse_str(&amp;user.id.to_string()).is_ok());
        assert!(rx.is_match(&amp;format!(&quot;{}&quot;, user.expires_at.format(&quot;%Y-%m-%d %H:%M:%S&quot;))));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Neste teste estamos testando se <code>email</code> e <code>password</code> são exatamente como enviamos, se o <code>Uuid</code> é gerado como <code>Uuid</code> e se o formato da data está de acordo coma  regex <code>&quot;[0-9]{4}-[0-1]{1}[0-9]{1}-[0-3]{1}[0-9]{1} [0-2]{1}[0-9]{1}:[0-6]{1}[0-9]{1}:[0-6]{1}[0-9]{1}&quot;</code>. Agora podemos implementar a funcão <code>from</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        use chrono::{DateTime, Duration, Utc};

        let utc: DateTime&lt;Utc&gt; = Utc::now() + Duration::days(1);

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que está funcão começa com <code>use chrono::</code>, isso se deve ao fato de estas structs ainda não serem necessárias em outras partes do código. Depois disso vemos a linha <code>let utc: DateTime&lt;Utc&gt; = Utc::now() + Duration::days(1);</code>, que é depois inserida em <code>expires_at</code>, ela referencia a ideia de que o token vai sobreviver apenas até este período, que é deste instante até mais um dia. Podemos ainda simplificar esta função para extrair o <code>DateTime&lt;Utc&gt;</code> com <code>one_day_from_now()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora <code>one_day_from_now</code> está definida no módulo <code>src/todo_api/db/helpers.rs</code> como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Duration, Utc};
// ...
pub fn one_day_from_now() -&gt; DateTime&lt;Utc&gt; {
    Utc::now() + Duration::days(1)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="adaptando-o-request-para-um-modelo-de-banco-de-dados"><a class="header" href="#adaptando-o-request-para-um-modelo-de-banco-de-dados">Adaptando o request para um modelo de banco de dados.</a></h3>
<p>Agora precisamos de um modelo que represente o request HTTP de <code>signup</code>. Iremos criar o módulo <code>src/todo_api_web/model/auth.rs</code> com a struct <code>SignUp</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct SignUp {
    pub email: String,
    pub password: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ambos campos são <code>pub</code>, isso é porque vamos precisar deles no <code>adapter</code>. Felizmente não podemos guardar o <code>password</code> como texto em nosso banco de dados, para isso vamos utilizar uma crate chamada bcrypt, adicionando <code>bcrypt = &quot;0.13&quot;</code> ao nosso <code>[dependencies]</code> do Cargo.toml (caso você se interesse por criptografia e queira outras opções, sugiro olhar também as crates <code>argonautica</code> e <code>libreauth</code>). Faremos está conversão no módulo <code>src/todo_api/adapter/auth.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::model::auth::User;
use crate::todo_api_web::model::auth::SignUp;
use bcrypt::{hash, DEFAULT_COST};

pub fn signup_to_hash_user(su: SignUp) -&gt; User {
    let hashed_pw = hash(su.password, DEFAULT_COST);
    User::from(su.email, hashed_pw.unwrap())
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora importamos duas coisas ao escopo, a função <code>hash</code> e <code>DEFAULT_COST</code>. <code>bcrypt</code> possui 3 principais funções e um padrão de custo, que é <code>DEFAULT_COST</code> e definido como <code>12u32</code>. As funções são:</p>
<ol>
<li><code>hash</code> recebe um password do tipo genérico <code>P</code>, no nosso caso <code>password</code> do tipo <code>String</code> e um custo, no caso <code>DEFAULT_COST</code>.</li>
<li><code>verify</code> verifica se o <code>password</code> enviado é igual a <code>hash</code>enviada.</li>
<li><code>bcrypt</code> é similar ao <code>hash</code>, porém o segundo argumento é um <code>salt</code> do tipo <code>&amp;[u8]</code></li>
</ol>
<p>Quanto ao custo, quanto maior o valor de custo, mais lento o hashing. Existe um benchmark com diferentes custos que apresenta uma relação de custo por velocidade:</p>
<ul>
<li>Custo = 4: test bench_cost_4       ... bench:   1,197,414 ns/iter (+/- 112,856)</li>
<li>Custo = 10: test bench_cost_10      ... bench:  73,629,975 ns/iter (+/- 4,439,106)</li>
<li>Custo = 12: test bench_cost_default ... bench: 319,749,671 ns/iter (+/- 29,216,326)</li>
<li>Custo = 14: test bench_cost_14      ... bench: 1,185,802,788 ns/iter (+/- 37,571,986)</li>
</ul>
<p>Creio que podemos escrever um teste simples para <code>signup_to_hash_user</code> como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;
    use crate::todo_api_web::model::auth::SignUp;

    #[test]
    fn asser_signup_becomes_user() {
        let email = &quot;my@email.com&quot;;
        let pass = &quot;this Is a cr4zy p@ssw0rd&quot;;
        let signup = SignUp {
            email: String::from(email), 
            password: String::from(pass)
        };
        let user = signup_to_hash_user(signup);
        user.is_user_valid(email, pass)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este teste que criamos funciona da seguinte maneira, ele cria um <code>SignUp</code> com valores fixos e passa para a função adapter <code>signup_to_hash_user</code>, depois disso validamos que os inputs passados para <code>SignUp</code> formam um <code>User</code> válido com <code>.is_user_valid(email, pass)</code>. Agora a função <code>is_user_valid</code> é um pouco diferente do que já vimos, pois ela é uma função que compila apenas para testes com <code>#[cfg(test)]</code>, e possui <code>asserts</code> internos. Os asserts foram movidos para o arquivo de <code>src/todo_api/model/auth.rs</code> pois os campos de <code>User</code> são privados:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    // ...

    #[cfg(test)]
    pub fn is_user_valid(self, email: &amp;str, password: &amp;str) {
        use bcrypt::verify;

        assert_eq!(self.email, String::from(email));
        assert!(verify(password, &amp;self.password).unwrap());
        assert!(self.id.to_string().len() == 36);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com está função de teste podemos testar os valores internos de 1 User, comparando se o <code>email</code> interno é igual ao <code>email</code> recebido, se a string de <code>password</code> é um caso possível para <code>user.password</code> e se o <code>id</code> tem o tamanho de um <code>Uuid</code> do tipo <code>v4</code>. </p>
<h3 id="comunicando-signup-com-o-banco"><a class="header" href="#comunicando-signup-com-o-banco">Comunicando <code>SignUp</code> com o banco</a></h3>
<p>Agora temos <code>SignUp</code> e podemos converter em <code>User</code> com a função adapter <code>signup_to_hash_user</code>, falta inserir <code>User</code> no banco de dados para podermos criar nosso endpoint de <code>signup</code>. O primeiro passo para isso é criarmos a função <code>insert_new_user</code> em <code>src/todo_api/db/auth.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

pub fn insert_new_user(user: User, conn: &amp;mut PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let new_user = diesel::insert_into(auth_user)
        .values(&amp;user)
        .execute(conn);

    match new_user {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::UserNotCreated)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Na versão que estamos usando da lib diesel, connection tem que ser <a href="https://github.com/Diesel-rs/Diesel/blob/master/guide_drafts/migration_guide.md#mutable-connections-required">mutáveis</a></p>
<p>Vamos explicar o que se passa neste módulo. Precisamos de <code>PgConnection</code> para disponibilizar uma conexão a nosso <code>execute</code>, que é o executor da nossa query. <code>prelude::*</code> serve para disponibilizar funções como <code>execute</code>. Além disso, criamos um módulo para conter todos nossos erros de banco de dados em <code>src/todo_api/db/error.rs</code>, que possui o enum <code>DbError</code> que veremos a seguir. Depois disso, temos <code>use crate::schema::auth_user::dsl::*;</code>, que disponibiliza a table <code>auth_user</code> para utilizar em <code>insert_into(auth_user)</code>. Temos, também, <code>diesel::insert_into(auth_user).values(&amp;user).execute(conn)</code> que insere na tabale <code>auth_user</code> com <code>insert_into</code>, define seus valores de inserção com <code>values</code>, recebendo a struct <code>User</code>, e executa a query com <code>execute</code>, ou com <code>get_result</code> caso você queria algum dos valores existente no banco após a inserção. Por último aplicamos um <code>match</code> ao tipo <code>Result</code> de <code>new_user</code>, caso o tipo seja <code>Ok</code> retornamos um sucesso, caso o tipo seja <code>Err</code>, retornamos o erro <code>DbError::UserNotCreated</code>. Agora vamos para a implementação da trait <code>Error</code> em <code>DbError</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
pub enum DbError {
    UserNotCreated
}

impl std::fmt::Display for DbError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            DbError::UserNotCreated =&gt; write!(f, &quot;User could not be created&quot;)
        }        
    }
}

impl Error for DbError {
    fn description(&amp;self) -&gt; &amp;str {
        match self {
            DbError::UserNotCreated =&gt; &quot;User could not be created, check for possible conflits&quot;
        } 
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; {
        Some(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Por enquanto temos somente um item em <code>DbError</code>, <code>UserNotCreated</code>. E agora precisamos implementar a trait <code>std::error::Error</code> para que nosso enum possa ser utilizado como um tipo erro em nosso projeto. A trait <code>Error</code> exige duas funções <code>description</code> e <code>cause</code>. <code>cause</code> é importante caso nosso erro receba algum argumento, pois nos permite retornar coisas específica com <code>&amp;dyn</code>, já description é o texto que veremos quando, por exemplo, logarmos o erro. Além disso, notamos que a trait <code>Error</code> exige a implementação de <code>std::fmt::Display</code>, que corresponde ao <code>to_string()</code>. Agora podemos criar uma versão de teste desta função da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/db/auth.rs
#[cfg(test)]
mod test {
    use diesel::debug_query;
    use diesel::pg::Pg;
    use crate::schema::auth_user::dsl::*;

    #[test]
    fn insert_user_matches_url() {
        use crate::todo_api::model::auth::User;

        let user = User::from(String::from(&quot;email@my.com&quot;), String::from(&quot;pswd&quot;));
        let query = diesel::insert_into(auth_user).values(&amp;user);
        let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
                -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot;, \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;]&quot;;
        assert_eq!(sql, debug_query::&lt;Pg, _&gt;(&amp;query).to_string());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Eu acredito que testes que comparam strings caractere a caractere é uma péssima ideia, mas a comunidade Diesel parece gostar, quando formos testar a nível de integração usaremos outra estratégia. Notamos a presença de <code>debug_query</code> e <code>Pg</code>, ambos são responsáveis por nos permitir debugar a query que que montamos com <code>diesel::insert_into(auth_user).values(&amp;user)</code> sem executá-la. Depois fazemos um assert de nossa query com <code>let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \ -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot; \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;]&quot;;</code> que é uma string com o valor que esperamos para o sql. Note que estamos acessando os campos <code>id</code> e <code>expires_at</code> neste teste, para fazermos isso mudamos a implementação de <code>User</code> um pouco:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
#[derive(Debug, Serialize, Deserialize, Queryable, Insertable)]
#[table_name = &quot;auth_user&quot;]
pub struct User {
    #[cfg(test)] pub email: String,
    #[cfg(not(test))] email: String,
    #[cfg(test)] pub id: uuid::Uuid,
    #[cfg(not(test))] id: uuid::Uuid,
    #[cfg(test)] pub password: String,
    #[cfg(not(test))] password: String,
    #[cfg(test)] pub expires_at: chrono::NaiveDateTime,
    #[cfg(not(test))] expires_at: chrono::NaiveDateTime,
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Fizemos com que os campos sejam públicos para teste e privado para todos os outros ambientes. Agora implementaremos o endpoint em si.</p>
<blockquote>
<p>Formatando <code>expires_at</code> e a crate Chrono</p>
<p>Muitas vezes é complicado acertar diretamente qual o formato que você quer que sua string contendo a data tenha, por isso, aqui está um bom referencial para o tipo <code>UTC</code> do Chrono:</p>
<ul>
<li><code>assert_eq!(dt.format(&quot;%Y-%m-%d %H:%M:%S&quot;).to_string(), &quot;2014-11-28 12:00:09&quot;);</code></li>
<li><code>assert_eq!(dt.format(&quot;%a %b %e %T %Y&quot;).to_string(), &quot;Fri Nov 28 12:00:09 2014&quot;);</code></li>
<li><code>assert_eq!(dt.format(&quot;%a %b %e %T %Y&quot;).to_string(), dt.format(&quot;%c&quot;).to_string());</code></li>
<li><code>assert_eq!(dt.to_string(), &quot;2014-11-28 12:00:09 UTC&quot;);</code></li>
<li><code>assert_eq!(dt.to_rfc2822(), &quot;Fri, 28 Nov 2014 12:00:09 +0000&quot;);</code></li>
<li><code>assert_eq!(dt.to_rfc3339(), &quot;2014-11-28T12:00:09+00:00&quot;);</code></li>
<li><code>assert_eq!(format!(&quot;{:?}&quot;, dt), &quot;2014-11-28T12:00:09Z&quot;);</code></li>
</ul>
</blockquote>
<h3 id="definindo-o-endpoint"><a class="header" href="#definindo-o-endpoint">Definindo o endpoint</a></h3>
<p>Nosso primeiro passo é definir um teste para este endpoint e a partir deste teste podemos implementar a solução:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod  auth {
    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use actix_service::Service;
    use todo_server::todo_api_web::{
        routes::app_routes
    };
    use dotenv::dotenv;
    use crate::helpers::{read_json};
    use todo_server::todo_api_web::model::http::Clients;

    #[actix_rt::test]
    async fn signup_returns_created_status() {
        dotenv().ok();
        let app =
            test::init_service(App::new().app_data(Clients::new()).configure(app_routes)).await;

        let signup_req = test::TestRequest::post()
            .uri(&quot;/auth/signup&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;signup.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = app.call(signup_req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::CREATED);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso teste define <code>signup_req</code> como o request que vamos enviar para <code>app.call(signup_req)</code>, mas este request possui uma nova <code>URI</code> <code>&quot;/auth/signup&quot;</code> e um novo arquivo Json com o conteúdo de post <code>&quot;signup.json&quot;</code>. Precisamos então definir este arquivo em <code>dev-resources</code> e implementar a rota. Note que o <code>assert</code> neste caso é somente para verificar se o usuário foi criado. O arquivo <code>signup.json</code> possui o seguinte formato:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;,
    &quot;password&quot;: &quot;My cr4azy p@ssw0rd&quot;
}
</code></pre>
<blockquote>
<p>Reconfigurando os testes</p>
<p>Ao executarmos os testes agora termos um retorno de <code>InternalServerError</code>, isso se deve ao fato de que <code>DbExecutor</code> não consegue encontrar a <code>DATABASE_URL</code> que está associada ao banco. Isso se deve pelo fato de estarmos utilizando uma url diferente para o docker compose e outra para testes locais. Além disso, Postgres é mais complicado que DynamoDB no sentido de que o cliente realmente tenta estabelecer uma conexão para iniciar e para isso precisamos de uma base de dados falsa executando. Além disso, essa base deve estar migrada para as queries ocorrerem sem problemas. Assim, nosso <code>make test</code> fica mais complicado:</p>
<pre><code class="language-Makefile">db:
	docker run -i --rm --name auth-db -p 5432:5432 -e POSTGRES_USER=auth -e POSTGRES_PASSWORD=secret -d postgres

test: db
  diesel setup --migration-dir src/migrations
  diesel migration run --migration-dir src/migrations
	cargo test --features &quot;dbtest&quot;
	diesel migration redo
 
clear-db:
  docker ps -a | awk '{ print $1,$2 }' | grep postgres | awk '{print $1 }' | xargs -I {} docker stop {}
</code></pre>
<p>Note que a partir da agora para rodar os testes precisamos de um container postgres configurado (<code>setup</code> e <code>migration run</code>) para podermos executar nossos testes sem quebrar o <code>DbExecutor</code>. Pode ser necessário adicionar um <code>sleep 3</code> depois de <code>test: db</code> para dar tempo do container executar. A última linha iniciada em <code>docker ps</code> serve para remover o container que executamos. Além disso, <code>DbExecutor</code> depende de <code>dotenv</code>, assim, devemos incluir <code>dotenv().ok()</code> antes de executar os testes e incorporar o <code>dotenv</code> no escopo com <code>use dotenv::dotenv;</code>. </p>
</blockquote>
<p>Agora que configuramos o teste, precisamos fazer a configuração de rotas, <code>app_routes</code> passa a ser:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user}
};
use actix_web::{web, HttpResponse};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(ping)
            .service(readiness)
            .service(create_todo)
            .service(show_all_todo)
            .service(
                web::scope(&quot;/auth&quot;)
                    .service(signup_user)
            )
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Ainda precisamos implementar o controller <code>signup_user</code> no módulo de controllers <code>auth</code>, porém ao contrário do método que vinhamos utilizando para inserir <code>User</code> no nosso banco de dados, que é o default do Diesel, vamos tirar proveito do sistema de actors do Actix e implementar um handler para permitir a comunição entre nosso serviço e o <code>Diesel</code> por mensagens. Assim, devemos mudar nossa struct <code>SignUp</code> para que ela implemente as traits <code>Handler</code> e <code>Message</code>, que vão nos permitir enviar mensagens para o <code>DbExecutor</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::prelude::*;
use crate::todo_api::{
    db::{
        error::DbError,
        helpers::DbExecutor,
    },
    adapter
};
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct SignUp {
    pub email: String,
    pub password: String,
}

impl Message for SignUp {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;SignUp&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: SignUp, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::schema::auth_user::dsl::*;
        use crate::diesel::RunQueryDsl;

        let user = adapter::auth::signup_to_hash_user(msg);
        let new_user = diesel::insert_into(auth_user)
            .values(&amp;user)
            .execute(&amp;mut self.0.get().expect(&quot;Failed to open connection&quot;));

        match new_user {
            Ok(_) =&gt; Ok(()),
            Err(_) =&gt; Err(DbError::UserNotCreated)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para a trait <code>Message</code> devemos implementar o tipo de retorna da comunicação, como no nosso caso não vamos retornar nada deixamos o <code>()</code> e caso ocorra um erro, retornamos o que já implementamos, <code>DbError</code>. Depois disso implementamos o <code>Handler</code> para <code>DbExecutor</code> com o tipo de mensagem <code>SignUp</code>, que possui a função <code>handle</code>. O primeiro argumento de <code>handle</code> é o prório <code>DbExecutor</code>, que está implementado como <code>struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;)</code>, o segundo argumento é a mensagem, no nosso caso <code>SignUp</code>, e o terceiro argumento é o contexto do actix. Note que a função <code>handle</code> é praticamente igual a <code>insert_new_user</code>, mas em vez de passarmos um <code>PgConnection</code> passamos um <code>PooledConnection</code>, uma referência ao <code>Pool</code> de conexões que criamos em <code>DbExecutor</code>, e para isso precisamos adicionar <code>use crate::diesel::RunQueryDsl;</code> que altera nosso <code>execute</code> para poder realizar erstá operação. Com isto encaminhado, agora podemos criar o controller. Este controller será um pouco diferente do que usamos usualmente, pois o adapter se encontra dentro do <code>Handler</code> e o controller simplesmente ficará responsável por fazer a comunicação via mensagem entre os actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use log::{error};
use crate::{
    todo_api_web::model::{
        http::Clients,
        auth::SignUp,
    }
};

pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    let signup = info.into_inner();

    let resp = state.postgres
        .send(signup)
        .await;

    match resp {
        Ok(_) =&gt; HttpResponse::Created(),
        Err(e) =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::InternalServerError()
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora estamos fazendo a conversão do tipo <code>web::Json&lt;SignUp&gt;</code> na nossa struct <code>SignUp</code> com <code>let signup = info.into_inner();</code> e enviando seu conteúdo para o <code>DbExecutor</code> através de:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp = state.postgres
    .send(signup)
    .await;
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos os testes agora veremos que eles falham, pois nosso teste tenta invocar o banco de dados de verdade, para isso, podemos utilizar a função que criamos anteriormente <code>insert_new_user</code> dentro do <code>Handler</code> para abstrair a lógica com o banco de dados e nos permitir utilizar features. Assim, a primeira mudança passa a ser o <code>handle</code> que utiliza o <code>insert_new_user</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler&lt;SignUp&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: SignUp, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::insert_new_user;

        let user = adapter::auth::signup_to_hash_user(msg);

        insert_new_user(user, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar uma solução de <code>insert_new_user</code>que utilize a feature <code>dynamo</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn insert_new_user(user: User, conn: &amp;mut PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let new_user = diesel::insert_into(auth_user)
        .values(&amp;user)
        .execute(conn);

    match new_user {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::UserNotCreated)
    }
}

#[cfg(feature = &quot;dynamo&quot;)]
pub fn insert_new_user(_user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;

    let user = User::from(String::from(&quot;my@email.com&quot;), String::from(&quot;My cr4azy p@ssw0rd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
            -- binds: [\&quot;my@email.com\&quot;, &quot;;
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(sql));
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(&quot;My cr4azy p@ssw0rd&quot;));

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Com o <code>#[cfg(feature = &quot;dynamo&quot;)]</code> fazemos uma query para <code>diesel_query</code> com os valores de <code>user</code> (não usamos <code>_user</code> pois seus campos são privados), como fizemos no módulo de testes e depois fazemos um assert que a query retornada de <code>debug_query::&lt;Pg, _&gt;(&amp;query).to_string()</code> contém a substring <code>sql</code> e que contém a substring de password <code>&quot;My cr4azy p@ssw0rd&quot;</code>. Depois disso retornamos <code>Ok(())</code> para conformar com o esperado do <code>Result</code>.</p>
<h2 id="validando-email-e-password"><a class="header" href="#validando-email-e-password">Validando email e password</a></h2>
<p>Agora vamos fazer algo pequeno, pois nosso objetivo é garantir que o email é no formato válido <code>\w{1,}@\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?</code> (regex significando qualquer conjunto de caracteres com mais de 1 elemento entre letras, números e <code>_</code>, seguido de <code>@</code>, repete o primeiro, seguido de ponto e 2 ou 3 caracteres de letras, seguido pela possível existência de ponto e 2 ou 3 caracteres de letras). Além disso, vamos garantir que o password contém umais de 32 caracteres, com letras maiúsculas e minúsculas, números e alguns caracterés especiais. </p>
<p>No controller <code>signup_user</code> adicionaremos uma validação da string de email com a crate Regex. Para isso definiremos nossa regex com <code>Regex::new</code> e depois compararemos com <code>is_match</code>. Caso a validação falhe, retornaremos <code>HttpResponse::BadRequest()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let signup = info.into_inner();
    if !email_regex.is_match(&amp;signup.email) {
        return HttpResponse::BadRequest();
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora usaremos uma regex que garante que a senha possua pelo menos uma letra maiúscula, pelo menos uma letra minúscula, pelo menos um número e pelo menos algum dos caracteres <code>@!=_#&amp;~[]{}?/</code> com uma tamanho entre 32 e 64 caracteres. Essa regex será <code>[[a-z]+[A-Z]+[0-9]+(\s@!=_#&amp;~\[\]\{\}\?\/)]{32,64}</code>. Cuidado que nosso teste deve falhar a partir de agora, para isso, modifiquei <code>signup.json</code> para:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;,
    &quot;password&quot;: &quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;
}
</code></pre>
<p>E atualizei <code>db/auth</code> para validar este novo password:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dynamo&quot;)]
pub fn insert_new_user(user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;

    let user = User::from(String::from(&quot;my@email.com&quot;), String::from(&quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
            -- binds: [\&quot;my@email.com\&quot;, &quot;;
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(sql));
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(&quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;));

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, podemos implementar a mudança no controller com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?\\/)]{32,64}&quot;).unwrap();
    
    let signup = info.into_inner();
    if !(email_regex.is_match(&amp;signup.email) &amp;&amp; pswd_regex.is_match(&amp;signup.password)) {
        return HttpResponse::BadRequest();
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Um bom exercício aqui seria criar alguns testes para o controller validar as novas regras do <code>email</code> e do <code>password</code>, lembrando que o teste de cenário válido já acontece a nível de integração. Alguns possíveis <code>emails</code> de teste são <code>&quot;my_email.com.br&quot;</code> ou <code>&quot;my@email.com.br.us&quot;</code>, além disso alguns casos interessantes de teste para <code>passwords</code> são <code>&quot;My Cr4zy p@ssw0rd&quot;</code>, <code>&quot;my cr4zy p@ssw0rd my cr4zy p@ssw0rd&quot;</code> e <code>&quot;My Crazy password My Crazy password&quot;</code>.</p>
<h2 id="implementando-login"><a class="header" href="#implementando-login">Implementando login</a></h2>
<p>O objetivo de nosso endpoint de login será retornar um token <code>jwt</code> com informações garantindo a validade do sistema. Assim, nosso endpoint receberá um <code>email</code> e um <code>password</code>, validará se o password é válido e retornará um token <code>jwt</code>, que passará a ser validado nos outros endpoints. </p>
<p>Podemos agora mudar a feature <code>dynamo</code> que atua sobre o Postgres e o DynamoDB para <code>db-test</code>. Para isso, devemos adicionar a feature a nosso Cargo.toml:</p>
<pre><code class="language-toml">[features]
db-test = []
</code></pre>
<p>E a nosso Makefile:</p>
<pre><code class="language-sh">test: db
	sleep 2
	diesel setup
	diesel migration run
	cargo test --features &quot;dbtest&quot;
	diesel migration redo

run-local:
	cargo run --features &quot;db-test&quot;
# ...
</code></pre>
<p>Por último, devemos modificar o arquivo <code>src/todo_api/db/auth.rs</code> para utilizar a nova feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

#[cfg(not(feature = &quot;db-test&quot;))]
pub fn insert_new_user(user: User, conn: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    // ...
}

#[cfg(feature = &quot;db-test&quot;)]
pub fn insert_new_user(user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    // ...

    Ok(())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Repita isso para os outros cenários.</p>
<h3 id="criando-o-endpoint-de-login"><a class="header" href="#criando-o-endpoint-de-login">Criando o endpoint de login</a></h3>
<p>A partir deste momento vou mudar a forma como apresento os testes, pois creio que já temos uma boa ideia de como eles funcionam. Assim, vou apresentar o teste que escrevi para cada endpoint, mas não resolverei eles mais de forma a relacionar o código sendo escrito ao teste que queremos resolver. Isso se deve ao fato de que eles são praticamente iguais. Assim, o teste deste endpoint seria apenas validar que o status é <code>200</code>, mas vamos mudar um pouco e esperar que a resposta venha com uma chave Json <code>token</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod  auth {
    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use todo_server::todo_api_web::{
        routes::app_routes
    };
    use crate::helpers::{read_json};
    use dotenv::dotenv;

    // ...
    #[actix_rt::test]
    async fn login_returns_token() {
        let mut app = test::init_service(
            App::new()
                .data(Clients::new())
                .configure(app_routes)
        ).await;

        let login_req = test::TestRequest::post()
            .uri(&quot;/auth/login&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;signup.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp_body = test::read_response(&amp;mut app, login_req).await;

        let jwt: String = String::from_utf8(resp_body.to_vec()).unwrap();
        
        assert!(jwt.contains(&quot;token&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso próximo passo será definir o endpoint <code>/auth/login</code> que receberá um <code>POST</code> com um Json representado pela struct <code>Login</code>, que contém os mesmos campos de <code>SignUp</code>. Faremos uma nova struct para podermos tirar mais proveito do sistema de actors do Actix.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user, login}
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(ping)
            .service(readiness)
            .service(create_todo)
            .service(show_all_todo)
            .service(
                web::scope(&quot;/auth&quot;)
                    .service(signup_user)
                    .service(login)
            )
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}

<span class="boring">}
</span></code></pre></pre>
<p>Aqui adicionamo uma rota <code>login</code> que envia o request para o controller <code>login</code>. Agora vamos ao controller <code>login</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?)]{32,64}&quot;).unwrap();
    
    let login_user = info.clone();
    if !(email_regex.is_match(&amp;login_user.email) &amp;&amp; pswd_regex.is_match(&amp;login_user.password)) {
        return HttpResponse::BadRequest().finish();
    }

    let resp = state.postgres
        .send(login_user)
        .await;

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(r_users) =&gt; {
            match r_users {
                Err(e) =&gt; {
                    error!(&quot;{:?}&quot;,e);
                    HttpResponse::NoContent().finish()
                },
                Ok(users) =&gt; {
                    let user = users.first().unwrap();
                    match user.verify(info.clone().password) {
                        Ok(true) =&gt; generate_jwt(user, state).await,
                        Ok(false) =&gt; HttpResponse::NoContent().finish(),
                        Err(_) =&gt; HttpResponse::NoContent().finish()

                    }
                }
            }
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que podemos notar no controller de <code>login</code> é o <code>is_match</code> das regex, lembrando que usar regex pode sempre ser algo perigoso e devemos ter muito cuidado. Isso é algo que claramente podemos extrair. Em seguida repetimos o processo de outros outros controllers e enviamos uma mensagem com <code>Login</code> em <code>state.postgres.send(login_user).await</code>, nesta chamada recebemos um vetor de <code>User</code> que passam nosso filtro, porém como estamos filtrando pela chave primária <code>email</code> não pode haver conflitos. creio que a estração das verificações de email e de senha por regex fica com a seguinte cara:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    let signup = info.into_inner();
    if !is_email_pswd_valids(&amp;signup.email, &amp;signup.password) {
        return HttpResponse::BadRequest();
    }

    // ...
}

pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    let login_user = info.clone();
    if !is_email_pswd_valids(&amp;login_user.email, &amp;login_user.password) {
        return HttpResponse::BadRequest().finish();
    }

    // ...
}

pub fn is_email_pswd_valids(email: &amp;str, pswd: &amp;str) -&gt; bool {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?)]{32,64}&quot;).unwrap();
    
    email_regex.is_match(email) &amp;&amp; pswd_regex.is_match(pswd)
}
<span class="boring">}
</span></code></pre></pre>
<p>A vantagem deste formato, é que executar os testes fica ainda mais fácil, pois passam a ser validações unitárias, e o motivo pelo qual deixei anteriormente como exercícios. Assim, os testes podem ser como a seguir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod valid_email_pswd {
    use super::is_email_pswd_valids;

    #[test]
    fn valid_email_and_pswd() {
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
    }

    #[test]
    fn invalid_emails() {
        assert!(!is_email_pswd_valids(&quot;my_email.com&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
        assert!(!is_email_pswd_valids(&quot;my@email.com.br.us&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
    }

    #[test]
    fn invalid_passwords() {
        assert!(!is_email_pswd_valids(&quot;my@email.com.br&quot;, &quot;My cr4zy P@ssw0rd&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;my cr4zy p@ssw0rd my cr4zy p@ssw0rd&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My crazy P@ssword My crazy P@ssword&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My cr4zy Passw0rd My cr4zy Passw0rd&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Também podemos observar que no controller <code>login</code> há uma série de <code>HttpResponse::NoContent().finish()</code> para qualquer caso de erro. Duas coisas para observarmos aqui, a primeira é a presença de <code>finish</code> que se deve ao método <code>generate_jwt</code> que retorna um <code>HttpResponse</code>, a segunda é que presumo que quando alguém tenta logar em um serviço e ocorro qualquer problema, o serviço deve responder um <code>2XX</code> sem nenhuma informação, por isso do <code>NoContent</code>.</p>
<p>Agora podemos seguir para o caso que todas as extrações de <code>resp</code> via pattern matching e chegar em <code>user.verify(info.clone().password)</code>. O objetivo de função é validar que o <code>password</code> de <code>info: web:Json&lt;Login&gt;</code> é um password possível para a hash de <code>user.password</code>. Como está função é somente uma camada em volta da função original, já testada, não é imprescindível implementar testes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
impl User {
    use bcrypt::{verify, BcryptResult};
    // ...

    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        verify(pswd,&amp;self.password)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que a resposta de <code>verify</code> é do tipo <code>BcryptResult</code>, ou seja, temos 3 cenários:</p>
<ol>
<li><code>Ok(true)</code> -&gt; Caso na qual o <code>password</code> enviado é uma hash válida. </li>
<li><code>Ok(false)</code> -&gt; Caso na qual o <code>password</code> não é válido.</li>
<li><code>Err</code> -&gt; Ocorreu algum erro de validação.</li>
</ol>
<p>O único dos casos que é importante para nós é o caso <code>1</code>, por isso é o caso que aplicamos a função <code>generate_jwt</code>, cujo objetivo será gerar um token <code>jwt</code>. Além disso, está função não funcionará para o teste que criamos pois não estamos utilizando uma hash real, assim uma solução para isso é simplesmente responder um tipo <code>BcryptResult&lt;bool&gt;</code> com conteúdo <code>true</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    // ...

    #[cfg(not(feature = &quot;dbtest&quot;))]
    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        verify(pswd,&amp;self.password)
    }

    #[cfg(feature = &quot;dbtest&quot;)]
    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        BcryptResult::Ok(true)
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Antes de continuar com <code>generate_jwt</code> precisamos explorar a implementação de <code>Login</code>, pois é o <code>Login</code> que é afetado pela função <code>state.postgres.send(login_user).await</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Login {
    pub email: String,
    pub password: String,
}

impl Message for Login {
    type Result = Result&lt;Vec&lt;User&gt;, DbError&gt;;
}

impl Handler&lt;Login&gt; for DbExecutor {
    type Result = Result&lt;Vec&lt;User&gt;, DbError&gt;;

    fn handle(&amp;mut self, msg: Login, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Login recebe um <code>email</code> e um <code>password</code> para depois procurar no banco de dados com <code>scan_user</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scan_user(user_email: String, conn: &amp;mut PgConnection) -&gt; Result&lt;Vec&lt;User&gt;,DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let items = auth_user
            .filter(email.eq(&amp;user_email))
            .load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users),
        Err(_) =&gt; Err(DbError::CannotFindUser)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>É bastante simples o que acontece aqui, filtramos na tabela <code>auth_user</code> por um <code>user_email</code> que seja igual ao que enviamos. Caso essa lista seja maior que 1, houve um problema no banco de dados, pois como <code>email</code> é uma chave primária não podem haver 2, ou mais, repetidos. Qualquer outro <code>Err</code> é um <code>DbError</code> de não encontrar o usuário ou problemas de conexão. Temos um <code>Ok</code> extra que valida se a lista é zero, e retorna o erro <code>CannotFindUser</code> como a cláusula <code>Err</code>. E o <code>Ok</code> restante é o caso que procuramos. Note que ainda temos um refactor a fazer aqui, este refactor é modificar o tipo de retorno <code>Result&lt;Vec&lt;User&gt;,DbError&gt;</code> para <code>Result&lt;User,DbError&gt;</code> utilizando um <code>.first().unwrap()</code>, já que temos certeza que esse <code>first</code> existe. Além disso, precisamos adaptar este código para o teste, já que a ação <code>user.filter(email.eq(&amp;user_email)).load::&lt;User&gt;(conn)</code> não deve existir. Fazemos essa adaptação retornando um <code>Ok</code> com um <code>User</code> contendo o email que enviamos. Na função <code>scan_user</code> com a feature <code>dbtest</code> ainda fazemos um assert na query que será gerada por <code>auth_user.filter(email.eq(&amp;user_email))</code> e validamos com o <code>debug_query</code>. Caso você prefira substituir o <code>password</code> por uma hash válida para a senha sendo enviada no teste, não seria mais necessário utilizar a <code>cfg feature</code> para <code>verify</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn scan_user(user_email: String, conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let items = auth_user
            .filter(email.eq(&amp;user_email))
            .load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users.first().unwrap().clone().to_owned()),
        Err(_) =&gt; Err(DbError::CannotFindUser)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn scan_user(user_email: String, _conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;
    let query = auth_user.filter(email.eq(&amp;user_email));
    let expected = &quot;SELECT \&quot;auth_user\&quot;.\&quot;email\&quot;, \&quot;auth_user\&quot;.\&quot;id\&quot;, \&quot;auth_user\&quot;.\&quot;password\&quot;, \&quot;auth_user\&quot;.\&quot;expires_at\&quot;, \&quot;auth_user\&quot;.\&quot;is_active\&quot; FROM \&quot;auth_user\&quot; WHERE \&quot;auth_user\&quot;.\&quot;email\&quot; = $1 -- binds: [\&quot;my@email.com\&quot;]&quot;.to_string();

    assert_eq!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string(), expected);
    Ok(User::from(user_email, &quot;this is a hash&quot;.to_string()))
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora nossa <code>resp</code> de <code>state.postgres.send(login_user).await</code> pode ser resolvida em uma <code>match</code>, na qual a cláusula de <code>Err</code> vai simplesmente retornar um <code>NoContent</code> a cláusula <code>Ok</code> vai aplicar um novo <code>match</code> em <code>verify</code>. De acordo com a resposta de verify, criamos o token. O caso <code>Err</code> é simplesmente um <code>NoContent</code> porque houve um problema na criação da hash, já o caso <code>Ok(false)</code> corresponde a senha incorreta. No caso <code>Ok(true)</code>, criamos o token em <code>generate_jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/auth.rs
pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    // ...

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(user) =&gt; {
            let usr = user.unwrap();
            match usr.verify(info.clone().password) {
                Ok(true) =&gt; generate_jwt(usr, state).await,
                Ok(false) =&gt; HttpResponse::NoContent().finish(),
                Err(_) =&gt; HttpResponse::NoContent().finish()
            }
        }
    }
}

// src/todo_api_web/model/auth.rs
impl Message for Login {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Login&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Login, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora falta implementarmos o <code>generate_jwt</code> para completarmos esse fluxo.</p>
<h3 id="gerando-um-token-jwt"><a class="header" href="#gerando-um-token-jwt">Gerando um token <code>JWT</code></a></h3>
<p>O objetivo de criarmos um token <code>JWT</code> é permitir que o usuário faça requisições para páginas que exigem autentição, e até autorização (é possível passar tokens de autorização), com um token de autenticação no header do request. Essa autenticação vai conter algumas informações cruciais que vão nos permitir validar este token no nosso banco de dados. As informação que vamos adicionar ao token neste momento são as contidas na struct <code>User</code> exceto <code>password</code>. </p>
<ul>
<li>É importante lembrar que o tópico de segurança é bastante complicado e não é o foco do livro, assim, a solução que vamos apresentar é útil, mas longe de ser uma solução aplicável em produção. </li>
</ul>
<p>Infelizmente, a função <code>generate_jwt</code> é cheio de efeitos colaterais e muito dificil de testar unitariamente, assim, vamos pular os testes dele por hora. Vamos manter essa função em um módulo <code>core</code>, a ideia desse módulo é conter a lógica associada à <code>src/todo_api</code>, mesmo que a função <code>generate_jwt</code> possua muitos efeitos colaterais e estará localizada em <code>src/todo_api/core/mod.rs</code>. O primeiro Efeito colaterial dele é criar uma nova data de expiração para daqui um dia com <code>crate::todo_api::db::helpers::one_day_from_now().naive_utc()</code>. Essa data será usada para criar uma struct que fará a atualização da data em <code>User</code>. Essa struct é chamada <code>UpdateDate</code> e contém dois campos <code>email</code> e <code>expires_at</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>JWT</strong></p>
<p>JWT, ou Json Web Token, é um padrão aberto baseado na <strong>RFC 7519</strong> que define uma forma compacta e auto contida de transmitir de forma segura entre duas partes em um formato Json. Este token pode ser assinado com uma chave secreta via <code>HMAC</code> ou chaves publicas/privadas via <code> RSA</code> ou <code>ECDSA.</code> Estes tokens podem ser encriptados ou não e os dois principais casos de uso são autorização e troca de informações. A estrutura de um JWT é <code>header</code>, <code>payload</code> e <code>assinatura</code>, assim o formato acaba sendo algo como <code>hhhhh.pppppp.aaaaa</code>. Usualmente o <code>header</code> possui duas partes o tipo, usualmente <code>&quot;typ&quot;: &quot;jwt&quot;</code> e o algoritmo que pode ser <code>HMAC SHA256 ou RSA</code>, algo como <code>&quot;alg&quot;: &quot;HS256&quot;</code>. <code>payload</code> é onde as informações que queremos trocar estão armazenadas. E assinatura, ou <code>signature</code>, é uma informação de como entender esses dados. Com o algoritmo <code>HMAC SHA256</code> a criação de um JWT o seguinte formato <code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code>, note que <code>payload</code> e <code>header</code> estão em um formato <code>base64</code>.</p>
</blockquote>
<p>Agora precisamos implementar a struct <code>UpdateDate</code>. Essa struct está estritamente associada a ao módulo <code>core</code> atuando somente como um complemento a lógica, por isso adicionel ela em <code>src/todo_api/core/model.rs</code>, mas se você achar mais adequado é correto também deixar <code>generate_jwt</code> em <code>src/todo_api/controller/core.rs</code> e <code>UpdateDate</code> em <code>src/todo_api/model/core.rs</code>. Agora, nossa struct também precisa poder se comunicar por mensagem com nosso postgres e para isso vamos implementar as traits <code>Message</code> e <code>Handle</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::prelude::*;
use crate::todo_api::{
    db::{
        error::DbError,
        helpers::DbExecutor,
    },
};

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct UpdateDate {
    pub email: String,
    pub expires_at: chrono::NaiveDateTime,
}

impl Message for UpdateDate {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;UpdateDate&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: UpdateDate, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::update_user_jwt_date;

        update_user_jwt_date(msg, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que o tipo <code>Result</code> da nossa <code>Message</code> é apenas um <code>Result</code> com um <code>Ok</code> vazio e um erro do tipo <code>DbError</code>, <code>Result&lt;(), DbError&gt;</code>. Neste caso precisamos somente saber se o update da data foi bem sucedido ou falho, com qual erro. Assim, a função <code>handle</code>simplesmente atualiza a <code>expires_at</code> no banco conforme a chave <code>email</code>. É importante também garantir que <code>expires_at</code> seja do tipo <code>chrono::NaiveDateTime</code> para não termos problemas com o tipo da tabela <code>auth_user</code>. Vamos agora olhar a função <code>update_user_jwt_date</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target).set(expires_at.eq(update_date.expires_at)).execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para <code>update_user_jwt_date</code> precisamos disponibilizar a <code>dsl</code> de <code>auth_user</code> para fazermos operações na tabela e fazemos isso com <code>use crate::schema::auth_user::dsl::*;</code>. A primeira linha de código é encontrar o <code>User</code> alvo através de um <code>filter</code> que procura a igualdade entre os campos <code>email</code> com <code>auth_user.filter(email.eq(update_date.email))</code> sendo definido em um <code>let target</code>. Depois disso fazemos um <code>update</code> nesse <code>target</code> com <code>diesel::update(target)</code> e com isso podemos fazer um <code>set</code> do campo <code>expires_at</code> com o valor de <code>expires_at</code> de <code>update_date</code> com <code>set(expires_at.eq(update_date.expires_at))</code>. O resultado disso será um tipo <code>Result&lt;(), DbError&gt;</code>, que podemos utilizar em um <code>match</code> para fazer pattern matching e retornar se o update foi bem sucedido. Para realizar o teste pulamos a parte do <code>target</code>e do <code>match</code>, retornando apenas um <code>Ok(())</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target)
        .set((expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active)))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn update_user_jwt_date(_update_date: UpdateDate, _conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>De volta a <code>generate_jwt</code> fazemos este update de forma a utilizar os recursos de <code>Actor</code> enviando uma mensagem para <code>UpdateDate</code> com <code>let resp = state.postgres.send(update_date);</code>. Note que esta função é <code>async</code> e não estamos esperando ela com o <code>await</code>, isso se deve ao fato de que as duas próximas tarefas não precisam que <code>resp</code> esteja concluída. Enquanto esperamos o momento oportuno para concretizar <code>resp</code> com <code>await</code> iniciamos a criação efeitva do token e sua preparação para o tipo de resposta <code>Jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
    };

    let resp = state.postgres
        .send(update_date.clone());

    let token_jwt = create_token(user, update_date);
    let jwt = crate::todo_api::core::model::Jwt::new(token_jwt);    

    match resp.await {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E o tipo <code>Jwt</code> localizado em <code>src/todo_api/core/model.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub struct Jwt{
    token: String
}

impl Jwt {
    pub fn new(jwt: String) -&gt; Self {
        Self {
            token: jwt
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Antes de concretizarmos <code>resp</code> com um <code>await</code> criamos o token com <code>create_token</code> e passamos este valor para a struct <code>Jwt</code> com <code>let jwt = crate::todo_api::core::model::Jwt::new(token_jwt);</code>. <code>create_token</code> é a função responsável por montar o token com os campos necessários.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_token(user: User, update_date: UpdateDate) -&gt; String {
    use serde_json::json;
    use jsonwebtokens::{Algorithm, AlgorithmID, encode};
    use chrono::Utc;

    let alg = Algorithm::new_hmac(AlgorithmID::HS256, &quot;secret&quot;).unwrap();
    let header = json!({ &quot;alg&quot;: alg.name(), &quot;typ&quot;: &quot;jwt&quot;, &quot;date&quot;:  Utc::now().to_string()});
    let payload = json!({ &quot;id&quot;: user.clone().get_id(), &quot;email&quot;: user.email, &quot;expires_at&quot;: update_date.expires_at });
    encode(&amp;header, &amp;payload, &amp;alg).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que fazemos em <code>create_token</code> é gerar o algoritmo com a struct <code>Algorithm</code>.  Como vamos utilizar um algoritmo <code>HMAC SHA256</code> chamamos a função <code>new_hmac</code> e passamos como argumento o id que tipo que vamos utilizar com <code>AlgorithmID::HS256</code> e o segredo que vai ser passado. Uma boa alternativa para não ter o segredo exposto assim é ler ele de uma variável de ambiente. Depois disso, definimos o <code>header</code> com o algoritmo, o tipo e a data de criação em <code>json!({ &quot;alg&quot;: alg.name(), &quot;typ&quot;: &quot;jwt&quot;, &quot;date&quot;:  Utc::now().to_string()});</code>, note o uso da macro <code>json!</code> vinda de <code>serde_json</code>. Da mesma forma que com header, criamos o <code>payload</code> com os campos que nos interessam, <code>id, email, expires_at</code>. Por último geramos o token passando todas estas informações como argumento para função <code>encode</code> em <code>encode(&amp;header, &amp;payload, &amp;alg).unwrap()</code>.</p>
<p>Para finalizar precisamos que <code>generate_jwt</code> responda um status com o conteúdo do token. Para isso fazemos um match em <code>resp</code> e retornamos <code>HttpResponse::InternalServerError().finish()</code> para o caso de <code>Err</code> e para o caso de <code>Ok</code> retornamos um <code>HttpResponse::Ok()</code> com um Json contendo a struct <code>Jst</code> serializada:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    // ...
    let resp = state.postgres.send(update_date.clone());
    let token_jwt = create_token(user, update_date);
    let jwt = crate::todo_api::model::core::Jwt::new(token_jwt);

    match resp.await {
        Ok(_) =&gt; {
            HttpResponse::Ok()
                .content_type(&quot;application/json&quot;)
                .json(jwt)
        }
        Err(e) =&gt; {
            error!(&quot;{:?}&quot;, e);
            HttpResponse::InternalServerError().finish()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Login pronto. Agora precisamos implementar o logout.</p>
<h2 id="implementando-o-logout"><a class="header" href="#implementando-o-logout">Implementando o logout</a></h2>
<p>Um login é útil, mas pode ser necessário apagarmos a sessão que temos com o serviço e para fazer isso é necessário realizar um <code>logout</code>, que atende pelo método <code>DELETE</code>. Nosso logout vai modificar nosso user de modo que tenhamos um campo booleano <code>is_active</code>. Este campo tem como responsabilidade dizer se o <code>user</code> enviado no token ainda está autenticado. Assim, vamos adicionar o campo <code>is_active</code> ao struct <code>User</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
// ...
#[derive(Debug, Serialize, Deserialize, Clone, Queryable, Insertable)]
#[table_name = &quot;auth_user&quot;]
pub struct User {
    pub email: String,
    pub id: uuid::Uuid,
    #[cfg(test)] pub password: String,
    #[cfg(not(test))] password: String,
    #[cfg(test)] pub expires_at: chrono::NaiveDateTime,
    #[cfg(not(test))] expires_at: chrono::NaiveDateTime,
    pub is_active: bool
}

impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
            is_active: false
        }
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Se observarmos o <code>rls</code> do editor vamos perceber o aviso de que <code>Insertable</code> está com problemas, este problema é que <code>is_active</code> não está mapeado. Para isso devemos criar uma migração com este campo, chamaremos ela de <code>valid_auth</code> e executaremos <code>diesel migration generate valid_auth</code> que criará uma nova pasta dentro de migrations, algo como <code>2020-02-22-011512_valid_auth</code>. Depois disso adicionaremos um <code>up.sql</code> e um <code>down.sql</code>:</p>
<pre><code class="language-sql">&lt;-- UP.sql --&gt;
ALTER TABLE auth_user
  ADD is_active BOOLEAN NOT NULL DEFAULT 'f';

&lt;-- DOWN.sql --&gt;
ALTER TABLE auth_user
  DROP is_active;
</code></pre>
<p>Esse script consiste em alterar a tabela <code>auth_user</code> para conter ou não o campo <code>is_active</code>. Com isso pronto executaremos <code>make db</code> e em seguida <code>diesel setup</code> para modificar o <code>schema.rs</code> que ficará assim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table! {
    auth_user (email) {
        email -&gt; Varchar,
        id -&gt; Uuid,
        password -&gt; Varchar,
        expires_at -&gt; Timestamp,
        is_active -&gt; Bool,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Lembre de adicionar <code>embed_migrations!();</code> depois de <code>table!(...)</code>. Antes de continuarmos com <code>logout</code> precisamos que o <code>login</code> ative a o campo <code>is_active</code> e para isso a struct <code>UpdateDate</code> precisa receber um novo campo booleano <code>is_active</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/core/model.rs
// ...
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct UpdateDate {
    pub email: String,
    pub expires_at: chrono::NaiveDateTime,
    pub is_active: bool
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Se rodarmos os testes agora veremos que o teste <code>insert_user_matches_url</code> de <code>src/todo_api/db/auth</code> falha pois não espera o campo <code>is_active</code>:</p>
<pre><code>esperado: &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) -- binds: [\&quot;email@my.com\&quot;, 0f3d625b-c85c-490c-b979-f20cbbd6a71d, \&quot;pswd\&quot;, 2020-02-23T19:31:34.896595]&quot;`,
encontrado: &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;, \&quot;is_active\&quot;) VALUES ($1, $2, $3, $4, $5) -- binds: [\&quot;email@my.com\&quot;, 0f3d625b-c85c-490c-b979-f20cbbd6a71d, \&quot;pswd\&quot;, 2020-02-23T19:31:34.896595, false]&quot;`
</code></pre>
<p>Assim, devemos editar o teste para conter o campo <code>is_active</code> com valor default <code>false</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insert_user_matches_url() {
    use crate::todo_api::model::auth::User;

    let user = User::from(String::from(&quot;email@my.com&quot;), String::from(&quot;pswd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;, \&quot;is_active\&quot;) VALUES ($1, $2, $3, $4, $5) \
            -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot;, \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;, false]&quot;;
    assert_eq!(&amp;sql, &amp;debug_query::&lt;Pg, _&gt;(&amp;query).to_string());
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos modificar também <code>core/mod.rs</code> para setar o campo <code>is_active</code> como true na função <code>generate_jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
        is_active: true,
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim como a função de <code>db/auth</code> <code>update_user_jwt_date</code>, que agora precisa setar o campo <code>is_active</code> como <code>true</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target)
        .set((expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active)))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora <code>diesel::update(target)</code> precisa atualizar 2 campos, e para isso é precisa enviar como parâmetro uma tupla contendo os dois campos a serem atualizados <code>(expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active))</code>. Com isso, podemos agora continuar com o <code>logout</code>.</p>
<p>Para nosso <code>logout</code> precisamos começar criando o endpoint <code>/auth/logout</code> com o método delete:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user, login, logout}
};
use actix_web::{web, HttpResponse};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(ping)
            .service(readiness)
            .service(create_todo)
            .service(show_all_todo)
            .service(
                web::scope(&quot;/auth&quot;)
                    .service(signup_user)
                    .service(login)
                    .service(logout)
            )
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>O teste para este cenário será:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn logout_accepted() {
    dotenv().ok();
    let mut app = test::init_service(
        App::new()
            .data(Clients::new())
            .configure(app_routes)
    ).await;

    let logout_req = test::TestRequest::delete()
        .uri(&quot;/auth/logout&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .header(&quot;x-auth&quot;, &quot;token&quot;)
        .set_payload(read_json(&quot;logout.json&quot;).as_bytes().to_owned())
        .to_request();

    let resp = test::call_service(&amp;mut app,logout_req).await;
    assert_eq!(resp.status(), StatusCode::ACCEPTED);
}
<span class="boring">}
</span></code></pre></pre>
<p>E <code>logout.json</code> será:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;
}
</code></pre>
<p>Agora com o teste pronto podemos passar para entender o controller de <code>logout</code>. Em <code>logout</code> vamos receber o email como parâmetro e um token válido, conforme o teste. Com o email vamos buscar a entidade a ser atualizada e no token vamos verificar a validade do token e se pertence ao usuário correto. Uma vez que as validações estiverem corretas, inativamos seu token com <code>is_active: false</code>. Não é tão crítico garantir o <code>logout</code> por não se tratar de um código em produção e por ser pouco sensível invalidar um token, caso você queira levar este código a produção, garanta a melhor estratégia com sua equipe de segurança. No nosso controller a primeira coisa que precisamos fazer é verificar se o conteúdo de <code>Logout</code> é um email de verdade, para evitar superficialmente <code>SQL Injection</code>. Fazemos isso com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Logout&gt;) -&gt; impl Responder {
    use regex::Regex;

    let logout_user = info.clone();
    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    
    if !email_regex.is_match(&amp;logout_user.email) {
        return HttpResponse::BadRequest().finish();
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Perceba que caso o campo email não coincida com a regex, nos retornamos <code>BadRequest</code>. Além disso, ainda falta implementarmos a struct <code>Logout</code> que nos permitirá trocar mensagens com o actor de <code>DbExecutor</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_web_api/model/auth.rs
// ...
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Logout {
    pub email: String,
}

impl Message for Logout {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Logout&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Logout, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Vale salientar que a função <code>scan_user</code> já possui implementação para a feature <code>db-test</code>. Além disso, é importante ressaltar que a struct <code>Logout</code> faz exatamente a mesma coisa que a struct <code>Login</code>, exceto pelo fato de que <code>Login</code> possui o campo <code>password</code>, por isso podemos simplificar a nosso <code>model</code> contendo apenas um tipo de <code>Login/Logout</code> com o campo <code>password</code> opcional. Assim <code>Login</code> pode se transformar em <code>Auth</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Auth {
    pub email: String,
    pub password: Option&lt;String&gt;,
}

impl Message for Auth {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Auth&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Auth, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, precisamos atualizar nosso <code>controller/auth</code> para utilizar <code>Auth</code> em vez de <code>Login</code> e <code>Logout</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    let login_user = info.clone();
    if !is_email_pswd_valids(&amp;login_user.email, &amp;login_user.password.clone().unwrap()) {
        return HttpResponse::BadRequest().finish();
    }

    let resp = state.postgres
        .send(login_user)
        .await;

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(user) =&gt; {
            let usr = user.unwrap();
            match usr.verify(info.clone().password.unwrap()) {
                Ok(true) =&gt; generate_jwt(usr, state).await,
                Ok(false) =&gt; HttpResponse::NoContent().finish(),
                Err(_) =&gt; HttpResponse::NoContent().finish()
            }
        }
    }
}

pub async fn logout(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Para continuarmos com <code>logout</code> precisamos receber o conteúdo do header em um request, fazemos isso adicionando o request aos argumentos de <code>logout</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {...}
<span class="boring">}
</span></code></pre></pre>
<p>Para acessarmos o conteúdo que enviamos agora vamos utilizar de uma função chamada <code>headers</code>, que retorna um mapa com todos os headers disponíveis. Nosso header de autorizaçnao terá uma cara um pouco diferente, pois se chamará <code>x-auth</code> e para obtermos ele basta chamarmos a função <code>get</code> que nos retornará um <code>Option</code> de <code>HeaderValue</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    use regex::Regex;

    let jwt = req.headers().get(&quot;x-auth&quot;);
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos fazer uma pequena mudança para tornar mais claro e organizado o controller. A função <code>is_email_pswd_valids</code> não pertence a este domínio, assim moveremos ela, e seus testes, para o módulo de core em <code>src/todo_api/core/mod.rs</code>, lembre-se de utilizar o <code>use crate::todo_api::core</code> no controller.</p>
<p>Em <code>logout</code> paramos no match do <code>email</code>, mas agora com a informação de email queremos receber informações de <code>User</code> para podermos fazer validações para o logout. Fazemos isso utilizando <code>let resp = state.postgres.send(logout_user.clone())</code> que se comporta de forma identica ao caso de <code>login</code>, e como não temos necessidade desta informação agora, podemos não utilizar o <code>await</code> imediatamente. O próximo passo é entender o estado associado ao valor <code>jwt</code>, fazemos isso em um <code>match</code>, na qual a cláusula <code>None</code> é uma resposta de <code>BadRequest</code> e a resposta <code>Some</code> vai agir sobre <code>jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...
    let resp = state.postgres
        .send(logout_user.clone());

    match jwt {
        None =&gt; return HttpResponse::BadRequest().finish(),
        Some(jwt) =&gt; {
            let jwt_value : JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap())).expect(&quot;failed to parse JWT Value&quot;);
            match validate_jwt_date(jwt_value.expires_at) {
                false =&gt; 
                    HttpResponse::Unauthorized().finish(),
                true =&gt; {
                    validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;))
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que devemos fazer em <code>Some</code> é decodificar o <code>jwt</code> com a função <code>decode_jwt</code>, que recebe como argumento um tipo <code>&amp;str</code> (<code>jwt.to_str().unwrap(</code>). Nosso uso de <code>decode_jwt</code> é bem simples, pois queremos apenas saber se o token ainda é válido, fazemos isso da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/core/mod.rs
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    use jsonwebtokens::raw::{TokenSlices, split_token, decode_json_token_slice};

    let TokenSlices {claims, .. } = split_token(jwt).unwrap();
    let claims = decode_json_token_slice(claims).expect(&quot;Failed to decode token&quot;);
    claims
}
<span class="boring">}
</span></code></pre></pre>
<p>A função <code>decode_jwt</code> consiste em separar os tokents do argumento <code>jwt</code> em partes como <code>claims</code> e <code>headers</code> e depois aplicar a função <code>decode_json_token_slice</code> para extrair o tipo <code>serde_json::value::Value</code> de <code>claims</code> e retornar <code>Value</code>. Essa implementação falharia nosso teste, assim precisamos retornar algum valor aleatório de <code>Value</code>, fazemos isso utilizando <code>serde_json::from_str</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;db-test&quot;)]
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    serde_json::from_str(&quot;{\&quot;expires_at\&quot;: \&quot;2020-11-02T00:00:00\&quot;, \&quot;id\&quot;: \&quot;bc45a88e-8bb9-4308-a206-6cc6eec9e6a1\&quot;, \&quot;email\&quot;: \&quot;my@email.com\&quot;}&quot;).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>Essa função não necessita grandes testes, já que ela não vai ser alterada com o tempo, mas é sempre bom testar que os valores batem. Assim, o módulo a seguire testa um token Jwt criado no site jwt.io e os valores de seu <code>claim</code> sendo transformado em Json pela macro <code>json!</code>. Depois disso, testamos a igualdade das partes. Com o teste a seguir vamos quebrar nossa pipeline de testes, pois este teste não utilzia a feature <code>dbtest</code> e é executado junto com todos os oturos testes. A solução mais simples para isso é separar testes unitários de testes de integração. Assim, criaremos um target <code>unit</code> no Makefile que executará <code>cargo test --lib</code>, e os testes de integração serão executados com <code>cargo test --test lib --features &quot;dbtest&quot;</code> que executará toda <code>lib</code> de <code>tests/lib</code>. Note os argumentos <code>--locked</code>, <code>--no-fail-fast</code> e <code>-- --test-threads 3</code>, que representam validar o <code>Cargo.lock</code>, não terminar o processo quando algum testes falha e executar os testes em 3 threads, repectivamente. Além disso, os testes <code>all_args_are_equal_is_accepted</code> e <code>all_args_are_not_equal_is_unauth</code> deverão ser movidos para a pasta de testes de integração <code>tests</code>, pois necessitam da feature <code>db-test</code>, coloquei eles em um módulo <code>todo_api_web/validation</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod decode_jwt {
    use super::decode_jwt;
    use serde_json::json;

    #[test]
    fn decodes_random_jwt() {
        let jwt = decode_jwt(&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6InRlc3QiLCJpYXQiOjE1MTYyMzkwMjJ9.tRF6jrkFnCfv6ksyU-JwVq0xsW3SR3y5cNueSTdHdAg&quot;);
        let expected = json!({&quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;test&quot;, &quot;iat&quot;: 1516239022 });

        assert_eq!(jwt, expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-sh">int: db
	sleep 2
	diesel setup
	diesel migration run
	cargo test --test lib --no-fail-fast --features &quot;dbtest&quot; -- --test-threads 3
	diesel migration redo


unit:
	cargo test --locked --no-fail-fast --lib -- --test-threads 3

test: unit int
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// todo_api_web/validation.rs
use todo_server::todo_api::core::{validate_jwt_info};
use todo_server::todo_api::model::auth::User;
use todo_server::todo_api_web::model::http::Clients;
use actix_web::http::StatusCode;

#[actix_rt::test]
async fn all_args_are_equal_is_accepted() {
    use dotenv::dotenv;
    dotenv().ok();

    let exec = Clients::new();
    let state = actix_web::web::Data::new(exec);

    let user = User::from(&quot;my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
    let email = &quot;my@email.com&quot;.to_string();

    let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
    assert_eq!(resp.status(), StatusCode::ACCEPTED);
}

#[actix_rt::test]
async fn all_args_are_not_equal_is_unauth() {
    use dotenv::dotenv;
    dotenv().ok();

    let exec = Clients::new();
    let state = actix_web::web::Data::new(exec);

    let user = User::from(&quot;not_my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
    let email = &quot;my@email.com&quot;.to_string();

    let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois de aplicarmos <code>decode_jwt</code> ao valor <code>jwt</code> transformamos este dado em algo manipulável coma struct que representa seu formato <code>JwtValue</code>, <code>let jwt_value :JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap()))</code>.  Com <code>jwt_value</code> em mãos podemos checar se a data está correta coma função <code>validate_jwt_date</code>, que verificar se a data do momento é inferior ou igual a <code>expires_at</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn validate_jwt_date(jwt_expires: chrono::NaiveDateTime) -&gt; bool {
    chrono::Utc::now().naive_utc() &lt;= jwt_expires
}
<span class="boring">}
</span></code></pre></pre>
<p>Com este teste implementado a função <code>#[cfg(feature = &quot;db-test&quot;)] decode_jwt</code> deve começar a falhar a partir do dia 2 de Novembro, assim, precisamos modificar ela para algo mais próximo de infinito, como mil anos deste momento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;db-test&quot;)]
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    serde_json::from_str(&quot;{\&quot;expires_at\&quot;: \&quot;3020-11-02T00:00:00\&quot;, \&quot;id\&quot;: \&quot;bc45a88e-8bb9-4308-a206-6cc6eec9e6a1\&quot;, \&quot;email\&quot;: \&quot;my@email.com\&quot;}&quot;).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>Voltando a <code>validate_jwt_date</code>, seu tipo de retorno é um booleano, que podemos fazer <code>match</code> para validar as respostas. Caso a resposta seja false, respondemos com <code>HttpResponse::Unauthorized().finish()</code> e caso seja verdadeiro chamamos um outra função que validará as informações internas, <code>validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;))</code>. Essa validação consiste em validar a coerência entre todos os <code>email</code>s, do Jwt, do Json enviado pelo <code>DELETE</code> e o salvo no banco. Note que o <code>email</code> salvo no banco é chamado através da concretização da future <code>resp</code> com <code>await</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn validate_jwt_info(jwt_email: String, req_email: String, user: Result&lt;User, DbError&gt;) -&gt; HttpResponse {
    match user {
        Err(_) =&gt; HttpResponse::Unauthorized().finish(),
        Ok(u) =&gt; {
            if u.email == jwt_email &amp;&amp; jwt_email == req_email {
                HttpResponse::Accepted().finish()
            } else {
                HttpResponse::Unauthorized().finish()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que fazemos em <code>validate_jwt_info</code> é um <code>match</code> de seu <code>Result</code>. Se ocorrer algum erro, o mais fácil é simplesmente responder que a pessoa não tem autorização. Caso não ocorram erros, velrificamos a igualdade entre os emails com <code>if u.email == jwt_email &amp;&amp; jwt_email == req_email </code>, retornando <code>HttpResponse::Accepted().finish()</code> em caso de sucesso e <code>HttpResponse::Unauthorized().finish()</code> em caso de falha. Outro ponto importante aqui é que <code>is_active</code> deve se tornar falso. E para isso precisamos criar uma nova struct <code>Inactivate</code> que comunicará com <code>DbExecutor</code> para inativar o email associado:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Inactivate {
    pub email: String,
    pub is_active: bool
}
<span class="boring">}
</span></code></pre></pre>
<p>Que pode ter uma função <code>new</code> que recebe o <code>email</code> é já cria a struct com <code>is_active = false</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Inactivate {
    pub fn new(email: String) -&gt; Self {
        Self {
            email: email,
            is_active: false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois disso precisamos implementar as traits <code>Message</code> e <code>Handle</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Message for Inactivate {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;Inactivate&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: Inactivate, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::inactivate_user;

        inactivate_user(msg, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Quando a <code>inactivate_user</code>, seu corpo é muito parecido com <code>update_user_jwt_date</code>, pois encontramos o <code>target</code> da mesma forma, mas fazemos update apenas no campo <code>is_active</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn inactivate_user(msg: Inactivate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(msg.email));
    match diesel::update(target)
        .set(is_active.eq(msg.is_active))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, a função de teste é exatamente igual a <code>update_user_jwt_date</code>, pois retorna somente um <code>Ok(())</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn inactivate_user(msg: Inactivate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(msg.email));
    match diesel::update(target)
        .set(is_active.eq(msg.is_active))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn inactivate_user(_msg: Inactivate, _conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Para finalizar a atualização devemos enviar a struct como mensagem com <code>state.postgres.send</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn validate_jwt_info(jwt_email: String, req_email: String, user: Result&lt;User, DbError&gt;, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    match user {
        Err(_) =&gt; HttpResponse::Unauthorized().finish(),
        Ok(u) =&gt; {
            if u.email == jwt_email &amp;&amp; jwt_email == req_email {
                let inactivate = Inactivate::new(req_email);
                let is_inactive = state.postgres.send(inactivate).await;

                match is_inactive {
                    Ok(_) =&gt; HttpResponse::Accepted().finish(),
                    Err(_) =&gt; HttpResponse::Unauthorized().finish()
                }
            } else {
                HttpResponse::Unauthorized().finish()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Algumas coisas mudaram. Agora precisamos passar <code>state</code> como argumento <code>state: web::Data&lt;Clients&gt;</code> e ao utilizarmos <code>state.postgres.send(inactivate)</code>, precisamos de um <code>await</code>, que exige que nossa função passe a ser <code>async</code> com <code>pub async fn validate_jwt_info</code>. Além disso, chamamos a função <code>new</code> da struct <code>Inactivate</code> com algum dos emails que temos e depois enviamos ela para <code>DbExecutor</code> com <code>let is_inactive = state.postgres.send(inactivate).await;</code>. Um pattern matching simples em <code>is_inactive</code> nos permite responder <code>Accepted</code> para o único caso que ocorreu tudo bem. Lembre de incorporar <code>crate::todo_api::core::model::Inactivate</code> em seu escopo e de modificar o controller de <code>logout</code> para enviar o <code>state</code> e utilizar <code>await</code> em <code>validate_jwt_info</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...

    match jwt {
        None =&gt; return HttpResponse::BadRequest().finish(),
        Some(jwt) =&gt; {
            let jwt_value : JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap())).expect(&quot;failed to parse JWT Value&quot;);
            match validate_jwt_date(jwt_value.expires_at) {
                false =&gt; 
                    HttpResponse::Unauthorized().finish(),
                true =&gt; {
                    validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;), state).await
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, os testes <code>all_args_are_equal_is_accepted</code> e <code>all_args_are_not_equal_is_unauth</code> em <code>core/mod.rs</code> passam a falhar por não receberem o state correto. Como a função <code>validate_jwt_info</code> passou a ser <code>async</code> sua testabilidade diminuiu, junto com isso vamos utilizar <code>CLients::new</code> que depende de <code>dotenv</code> estar executando. Para isso, devemos criar um <code>web::Data&lt;CLients&gt;</code> que será passado como argumento e disponibilizar um runtime para <code>async</code> com <code>#[actix_rt::test]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
    async fn all_args_are_equal_is_accepted() {
        use dotenv::dotenv;
        dotenv().ok();

        let exec = Clients::new();
        let state = actix_web::web::Data::new(exec);

        let user = User::from(&quot;my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
        let email = &quot;my@email.com&quot;.to_string();
        
        let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
        assert_eq!(resp.status(), StatusCode::ACCEPTED);
    }

    #[actix_rt::test]
    async fn all_args_are_not_equal_is_unauth() {
        use dotenv::dotenv;
        dotenv().ok();

        let exec = Clients::new();
        let state = actix_web::web::Data::new(exec);

        let user = User::from(&quot;not_my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
        let email = &quot;my@email.com&quot;.to_string();

        let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
        assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Por último, precisamos dar uma organizada no nosso código.</p>
<h2 id="refatorando-1"><a class="header" href="#refatorando-1">Refatorando</a></h2>
<p>Existem três coisas que eu gostaria de refatorar no momento. A primeira é o módulo de erros <code>db/error.rs</code>, que está totalmente deslocado. A segunda é mover o <code>core/model.rs</code> para <code>model/core.rs</code>, pois creio que agora já cresceu bastante. E a terceira é encontrar um nome melhor para <code>UpdateDate</code>,  como <code>UpdateUserStatus</code>. Começando pela terceira, selecionei para que meu editor de texto encontrasse todos os casos de <code>UpdateDate</code> e substituisse eles por <code>UpdateUserStatus</code> sem grandes conflitos. Depois disso, vamos mover o módulo de erros. Para iniciarmos o processo, precisamos mover a definição do módulo de <code>db/mod.rs</code> para <code>model/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//db/mod.rs
pub mod helpers;
pub mod todo;
pub mod auth;

// model/mod.rs
use aws_sdk_dynamodb::model::AttributeValue;
use std::collections::HashMap;
use uuid::Uuid;

pub mod auth;
pub mod error;
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Movemos todo o arquivo e precisamores modificar o caminho do <code>use</code> deste arquivo nos seguintes arquivos:</p>
<ul>
<li><code>src/todo_api/core</code> em <code>mod.rs</code> e <code>model.rs</code>.</li>
<li><code>src/todo_api/db/auth.rs</code></li>
<li><code>src/todo_api_web/model/auth.rs</code></li>
</ul>
<p>São mudanças bastante simples, basta substituir o <code>db</code> pelo <code>model</code> nos caminhos dos <code>use</code>. E para a segunda mudança, vamos criar o módulo <code>core</code> em <code>model/mod.rs</code>  com <code>pub mod core</code> e mover o arquivo <code>core/model.rs</code> para <code>model/core.rs</code>. Vamos modificar os mesmos arquivos que modificamos em <code>db/error</code>, a única diferença é que a função <code>generate_jwt</code> incorporava <code>Jwt</code> em seu escopo de forma individual. Executando nossos testes com <code>make test</code> está tudo ok e podemos continuar para implementar o requerimento de jwt nas chamadas dos endpoints que já temos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exigindo-autenticação"><a class="header" href="#exigindo-autenticação">Exigindo Autenticação</a></h1>
<p>Agora que implementamos a lógica de login, precisamos aplicar ela ao nosso serviço. Atualmente nosso serviço possui 4 conjuntos de rotas, <code>/auth/</code>, <code>/api/</code>, <code>/ping</code>,  <code>/~/ready</code>. Dessas rotas somente uma precisa de autenticação (<code>api</code>) enquanto as outras servem para fazer a autenticação (<code>auth</code>), ver a saúde do serviço (<code>ping</code>) e ver a disponibildiade de receber chamadas do serviço (<code>ready</code>). Assim, precisamos implementar &quot;algo&quot; que vai aplicar o sistema de login somente a rota <code>/api</code>. Esse algo será um middleware que nós vamos construir, ao contrário dos outros que já utilizamos, e lidará com a lógica de autenticação.</p>
<blockquote>
<p><strong>Middleware</strong></p>
<p>Já utilizamos Middlewares anterioemente, mas como foram utilizações superficiais não foi preciso entender mais a fundo o que eram. Agora creio que seja um momento interessante de defini-los. Middlewares não são um conceito exclusivo de aplicações web, podendo ser utilizados tanto em sistemas operacionais como em programas do dia a dia. Os middlewares proveem um conjunto de serviços e capacidades comuns a uma aplicação que sua base não prove. Esses serviços e capacidades podem ser gerenciamento de dados, tratamento de mensagens, autenticação e logs. Assim, middlewares atual como um tecido conectivo de vários serviços da aplicação.</p>
<p>No caso de middlewares de aplicações web, geralmente sua funcionalidade é adicionar comportamentos aos processamento de request e de response. Eles consegue se conectar a um request, ou a um response, que chegou ao servidor e alterar este request, inclusive respondendo antes do esperado, ou alterando o response. Utilizamos o middleware de <code>Logger</code> para incluir logs ao processamento do nosso request e o middleware de <code>DefaultHeaders</code> para incluir um header em nosso response.</p>
</blockquote>
<p>As alterações a seguir nos exigiram modificar o Cargo.toml para conter a crate <code>futures</code> e mover a crate <code>actix-server</code> para <code>dependencies</code>:</p>
<pre><code class="language-toml">[dependencies]
actix = &quot;0.9.0&quot;
#...
jsonwebtokens = &quot;1.2.0&quot;
actix-service = &quot;2.0.2&quot;
futures = &quot;0.3&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
</code></pre>
<h2 id="estrutura-de-um-middleware-com-actix"><a class="header" href="#estrutura-de-um-middleware-com-actix">Estrutura de um middleware com Actix</a></h2>
<p>Um middleware pode ser registrado em cada <code>App</code>, <code>scope</code> ou <code>Resource</code> do servidor e é executado em ordem oposta a seu registro. De modo geral, middlewares em Actix são um tipo, preferenciamente uma struct, que implementa as traits <code>Service</code> e <code>Transform</code>, da crate <code>actix_service</code>. Assim, cada um dos métodos da trait tem a capacidade de responder algo imediatamente ou através de uma future. O exemplo mais básico de Middleware seria um <code>hello world</code> no request (<code>Hello from Request</code>) e outro na response (<code>Hello from Response</code>), onde usamos <code>wrap_fn</code> para criar o middleware, conforme o código a seguir:</p>
<pre><pre class="playground"><code class="language-rust">use actix_web::{dev::Service as _, web, App};
use futures_util::future::FutureExt;

#[actix_web::main]
async fn main() {
    let app = App::new()
        .wrap_fn(|req, srv| {
            println!(&quot;Hi from start. You requested: {}&quot;, req.path());
            srv.call(req).map(|res| {
                println!(&quot;Hi from response&quot;);
                res
            })
        })
        .route(
            &quot;/index.html&quot;,
            web::get().to(|| async { &quot;Hello, middleware!&quot; }),
        );
}
</code></pre></pre>
<h2 id="definindo-o-middleware-de-autenticação"><a class="header" href="#definindo-o-middleware-de-autenticação">Definindo o Middleware de autenticação</a></h2>
<p>A primeira coisa que devemos fazer aqui é criar o módulo middleware em nosso código. Esse módulo estará contido em <code>src/todo_api_web/middleware/mod.rs</code>. A função <code>authentication_middleware</code> será passada como argumento para o <code>wrap</code> de <code>App</code>, <code>App:new().wrap(from_fn(authentication_middleware))</code>. Este bloco de código fica assim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::{core::decode_jwt, model::core::JwtValue};
use actix_web_lab::middleware::Next;

use actix_web::Error;
use actix_web::{
    body::MessageBody,
    dev::{ServiceRequest, ServiceResponse},
    web::Data,
};

use super::model::http::Clients;
pub async fn authentication_middleware(
    mut req: ServiceRequest,
    next: Next&lt;impl MessageBody&gt;,
) -&gt; Result&lt;ServiceResponse&lt;impl MessageBody&gt;, Error&gt; {
    let data = req.extract::&lt;Data&lt;Clients&gt;&gt;().await.unwrap();
    let jwt = req.headers().get(&quot;x-auth&quot;);

    match jwt {
        None =&gt; Err(actix_web::error::ErrorInternalServerError(
            &quot;Error in authentication middleware&quot;,
        )),
        Some(token) =&gt; {
            let decoded_jwt: JwtValue = serde_json::from_value(decode_jwt(token.to_str().unwrap()))
                .expect(&quot;Failed to parse Jwt&quot;);

            let valid_jwt = data.postgres.send(decoded_jwt);
            let fut = next.call(req).await?;

            match valid_jwt.await {
                Ok(true) =&gt; {
                    let (req, res) = fut.into_parts();
                    let res = ServiceResponse::new(req, res);
                    Ok(res)
                }
                _ =&gt; Err(actix_web::error::ErrorInternalServerError(
                    &quot;Error in authentication middleware&quot;,
                )),
            }
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>A função <code>call</code> é o centro de nossa atenção, sendo ela responsável pela manipulação de dados que queremos fazer. O primeiro caso que vamos ver é o fato de querermos que este middleware atue somente nas rotas <code>/api/</code>, assim temos duas soluções para isso. A primeira seria adicionar este middleware diretamente em <code>web::scope(&quot;api/&quot;)</code> do arquivo de rotas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(
                web::scope(&quot;/api&quot;)
                    .service(create_todo)
                    .service(show_all_todo)
                    .wrap(from_fn(authentication_middleware)),
            )
            .service(
                web::scope(&quot;/auth&quot;)
                    .service(signup_user)
                    .service(login)
                    .service(logout),
            )
            .service(ping)
            .service(readiness)
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}

<span class="boring">}
</span></code></pre></pre>
<p>Não gosto muito desta alternativa pois ela impacta a testabilidade. Portanto, prefiro a segunda alternativa que é criar uma condicional que verifica se a rota do request começa com os <code>scope</code>  que queremos. Caso a condicional for verdadeira, aplicamos nossa lógica, senão, simplesmente damos sequência ao request:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn authentication_middleware(
    mut req: ServiceRequest,
    next: Next&lt;impl MessageBody&gt;,
) -&gt; Result&lt;ServiceResponse&lt;impl MessageBody&gt;, Error&gt; {
        if req.path().starts_with(&quot;/api/&quot;) {
         // ...
        } else {
        let fut = next.call(req).await?;
        let (req, res) = fut.into_parts();
        let res = ServiceResponse::new(req, res);
        Ok(res)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>O <code>if</code> que definimos extrai o <code>path</code>, rota, de <code>ServiceRequest</code>, e aplica a função <code>starts_with</code> com o início da rota que queremos, <code>/api/</code>. Com isso, toda as rotas do serviço que começarem com <code>/api/</code> serão alteradas por este middleware. O próximo passo é extrairmos o header <code>x-auth</code> dos headers do request:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn authentication_middleware(
    mut req: ServiceRequest,
    next: Next&lt;impl MessageBody&gt;,
) -&gt; Result&lt;ServiceResponse&lt;impl MessageBody&gt;, Error&gt; {
    if req.path().starts_with(&quot;/api/&quot;) {
        let data = req.extract::&lt;Data&lt;Clients&gt;&gt;().await.unwrap();
        let jwt = req.headers().get(&quot;x-auth&quot;);

        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Exatraimos o header <code>x-auth</code> aplicando a função <code>headers</code> a request, que obtém todos os headers, e posteriormente escolhendo um header específico com <code>get</code>. O retorno desta função é um <code>Option&lt;String&gt;</code> contendo a String de Jwt. Como este campo é obrigatório, fazemos um <code>match</code> em <code>jwt</code> e no caso <code>None</code> retornamos um <code>BadRequest</code> com a informação que <code>x-auth</code> é requerido, <code>x-auth is required</code>. Depois disso precisamos de duas coisas, decodificar o token Jwt e enviar a resposta decodificada para validar ela no banco de dados, assim precisaremos da função <code>decode_jwt</code> para decodificar o <code>jwt</code> e de <code>Clients</code> armazenado em <code>data</code> para comunicar com o banco de dados: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn authentication_middleware(
    mut req: ServiceRequest,
    next: Next&lt;impl MessageBody&gt;,
) -&gt; Result&lt;ServiceResponse&lt;impl MessageBody&gt;, Error&gt; {
    if req.path().starts_with(&quot;/api/&quot;) {
        let data = req.extract::&lt;Data&lt;Clients&gt;&gt;().await.unwrap();
        let jwt = req.headers().get(&quot;x-auth&quot;);

        match jwt {
            None =&gt; Err(actix_web::error::ErrorInternalServerError(
                &quot;Error in authentication middleware&quot;,
            )),
            Some(token) =&gt; {
                let decoded_jwt: JwtValue =
                    serde_json::from_value(decode_jwt(token.to_str().unwrap()))
                        .expect(&quot;Failed to parse Jwt&quot;);

                let valid_jwt = data.postgres.send(decoded_jwt);
                let fut = next.call(req).await?;

                match valid_jwt.await {
                    Ok(true) =&gt; {
                        let (req, res) = fut.into_parts();
                        let res = ServiceResponse::new(req, res);
                        Ok(res)
                    }
                    _ =&gt; Err(actix_web::error::ErrorInternalServerError(
                        &quot;Error in authentication middleware&quot;,
                    )),
                }
            }
        }
    } else {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Para recordar <code>decode_jwt</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
   use jsonwebtokens::raw::{decode_json_token_slice, split_token, TokenSlices};

   let TokenSlices { claims, .. } = split_token(jwt).unwrap();
   let claims = decode_json_token_slice(claims).expect(&quot;Failed to decode token&quot;);
   claims
}
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>Nossa função <code>call</code> transforma o token em uma struct <code>JwtValue</code>, que corresponde aos campos presentes no token, através da função <code>serde_json::from_value</code>. O valor de <code>JwtValue</code> é enviado para o banco de dados através de <code>data.postgres.send(decoded_jwt)</code>. Com o resultado da troca de mensagens com <code>DbExecutor</code> via <code>data.postgres.send</code> recebemos um tipo <code>Result&lt;bool, MailBoxError&gt;</code> e fazemos <code>match</code>. O único caso que nos interessa é o <code>Ok(true)</code>, para todos os outros lançamos uma erro. Este erro retornará <code>InternalServerError</code>, pois não podemos reutilizar o conteúdo de <code>req</code> já que foi utilizado em <code>let fut = self.service.call(req);</code> para conretizar o request. Caso o resultado do <code>match</code> seja <code>Ok(true)</code>, deixamos o request prosseguir. Agora, vamos a implementação de <code>JwtValue</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub struct JwtValue {
    pub id: String,
    pub email: String,
    pub expires_at: chrono::NaiveDateTime,
}

impl Message for JwtValue {
    type Result = bool;
}

impl Handler&lt;JwtValue&gt; for DbExecutor {
    type Result = bool;

    fn handle(&amp;mut self, msg: JwtValue, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::token_is_valid;

        let user = token_is_valid(&amp;msg, &amp;self.0.get().expect(&quot;Failed to open connection&quot;));
        match user {
            Err(_) =&gt; false,
            Ok(user) =&gt; {
                match (user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id) {
                    (true, true, true) =&gt; true,
                    _ =&gt; false
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso token Jwt possui 3 campos em seu <code>claim</code> <code>id, email, expires_at</code>, assim a implementação de <code>JwtValue</code> possui estes 3 campos, definidos como <code>String, String, chrono::NaiveDateTime</code>, respectivamente. Depois definimos a trait <code>Message</code>, com o tipo <code>type Result = bool;</code>. Para <code>Handler</code>, procuramos o <code>User</code> com <code>token_is_valid(&amp;msg, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))</code> e depois aplicamos <code>match</code> a sua resposta. Em caso de <code>Err</code>, retornamos <code>false</code>, e em caso de <code>Ok</code>, verificamos todas as condições que queremos em outro <code>match</code> (poderia ser um <code>if/else</code>, mas creio que o match ficou mais elegante devido ao uso da tupla). Caso todos os itens da tupla, <code>(user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id)</code> sejam verdadeiros, retornamos <code>true</code>, senão <code>false</code>. Os itens da tupla são:</p>
<ol>
<li>Usuário está ativo com <code>user.is_active</code>.</li>
<li>Data atual é inferior a data <code>expires_at</code> do token com <code>validate_jwt_date(user.expires_at)</code>.</li>
<li>O id do token é o mesmo do usuário cadastrado com <code>user.id.to_string() == msg.id</code>.</li>
</ol>
<p>Quanto a nossa função <code>token_is_valid</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn token_is_valid(token: &amp;JwtValue, conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt; {
    use crate::schema::auth_user::dsl::*;

    let items = auth_user.filter(email.eq(&amp;token.email)).load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users.first().unwrap().clone().to_owned()),
        Err(_) =&gt; Err(DbError::CannotFindUser),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ela é praticamente igual a função <code>scan_user</code>. Assim, podemos substituir ela por scan user, obtendo o campo <code>email</code> de <code>JwtValue</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler&lt;JwtValue&gt; for DbExecutor {
    type Result = bool;

    fn handle(&amp;mut self, msg: JwtValue, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        let user = scan_user(String::from(&amp;msg.email), &amp;self.0.get().expect(&quot;Failed to open connection&quot;));
        match user {
            Err(_) =&gt; false,
            Ok(user) =&gt; {
                match (user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id) {
                    (true, true, true) =&gt; true,
                    _ =&gt; false
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com tudo isso pronto, basta adicionar o middleware em <code>App::new()</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[actix_web::main]
async fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=debug&quot;);
    env_logger::init();

    let client = Clients::new().await;
    create_table(&amp;client.clone()).await;

    HttpServer::new(move|| {
        App::new()
            .app_data(Data::new(client.clone()))
            .wrap(DefaultHeaders::new().add((&quot;x-request-id&quot;, Uuid::new_v4().to_string())))
            .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D X-REQUEST-ID:%{x-request-id}o&quot;))
            .wrap(from_fn(authentication_middleware))
            .configure(app_routes)
    })
    .workers(num_cpus::get() - 2)
    .max_connections(30000)
    .bind((&quot;0.0.0.0&quot;, 4000))
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<h3 id="testando-o-middleware"><a class="header" href="#testando-o-middleware">Testando o middleware</a></h3>
<p>Nosso middleware funciona bem, e basta executar o comando <code>make run</code> para se divertir com ele, porém não temos nenhum teste que garante o comportamento do middleware. Assim, podemos criar pelo menos dois testes. O primeiro teste é não enviar um header <code>x-auth</code> para uma rota <code>/api/</code> e o segundo teste é enviar um token aleatório. Como <code>decode_token</code> possui uma versão para feature <code>db-test</code>, o resultado será sempre um user válido. Assim, vamos ao primeiro teste:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod middleware {
    use actix_web::{test, App, http::StatusCode};
    use dotenv::dotenv;
    use todo_server::todo_api_web::model::http::Clients;
    use todo_server::todo_api_web::routes::app_routes;

    use crate::helpers::read_json;

    #[actix_rt::test]
    async fn bad_request_todo_post() {
        dotenv().ok();
        let mut app =
            test::init_service(
                App::new()
                .data(Clients::new())
                .wrap(todo_server::todo_api_web::middleware::Authentication)
                .configure(app_routes)
            ).await;

        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        assert_eq!(resp.status(), StatusCode::BAD_REQUEST);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este teste é práticamente igual ao teste que criamos uma <code>todo_card</code>, porém possui a função <code>.wrap(todo_server::todo_api_web::middleware::Authentication)</code> associada a <code>App</code> e em vez de validar a resposta valida o status como <code>BAD_REQUEST</code>. Depois disso, podemos criar um teste que adiciona um header <code>x-auth</code> com um Jwt contendo valores aleatórios para nossos campos:</p>
<pre><code>{
  &quot;id&quot;: &quot;7562bf53-6156-433b-a201-90bbc74b0127&quot;,
  &quot;email&quot;: &quot;my@email.com&quot;,
  &quot;expires_at&quot;: &quot;2014-11-28T12:00:09&quot;
}

Algoritmo HS256 com chave `your-256-bit-==secret`

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Ijc1NjJiZjUzLTYxNTYtNDMzYi1hMjAxLTkwYmJjNzRiMDEyNyIsImVtYWlsIjoibXlAZW1haWwuY29tIiwiZXhwaXJlc19hdCI6IjMwMjAtMTEtMjhUMTI6MDA6MDkifQ.hom6KvmmLIuu3dLCSUrOK9KBWyUb0fvdX4hIay52UIY
</code></pre>
<p>O teste para estes valores é:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn good_token_todo_post() {
    dotenv().ok();
    let mut app =
        test::init_service(
            App::new()
            .data(Clients::new())
            .wrap(todo_server::todo_api_web::middleware::Authentication)
            .configure(app_routes)
        ).await;

    let req = test::TestRequest::post()
        .uri(&quot;/api/create&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .header(&quot;x-auth&quot;, &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Ijc1NjJiZjUzLTYxNTYtNDMzYi1hMjAxLTkwYmJjNzRiMDEyNyIsImVtYWlsIjoibXlAZW1haWwuY29tIiwiZXhwaXJlc19hdCI6IjMwMjAtMTEtMjhUMTI6MDA6MDkifQ.hom6KvmmLIuu3dLCSUrOK9KBWyUb0fvdX4hIay52UIY&quot;)
        .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
        .to_request();

    let resp = test::call_service(&amp;mut app, req).await;
    println!(&quot;{:?}&quot;, resp);
    assert_eq!(resp.status(), StatusCode::CREATED);
}
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos este teste vamos receber como resposta um <code>panic!</code>, pois o middleware vai conter um <code>is_active</code> false que vai se encadear para um <code>Err</code>. Assim, precisaremos fazer algumas modificações em <code>scan_user</code>, <code>User.from</code> e <code>handle</code> de JwtValue. Com isso, as modificações serão em ordem de encadeamento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/core.rs
impl Handler&lt;JwtValue&gt; for DbExecutor {
    type Result = bool;

    #[cfg(not(feature = &quot;dbtest&quot;))]
    fn handle(&amp;mut self, msg: JwtValue, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        let user = scan_user(String::from(&amp;msg.email), &amp;self.0.get().expect(&quot;Failed to open connection&quot;));
        match user {
            Err(_) =&gt; false,
            Ok(user) =&gt; {
                match (user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id) {
                    (true, true, true) =&gt; true,
                    _ =&gt; false
                }
            }
        }
    }

    #[cfg(feature = &quot;dbtest&quot;)]
    fn handle(&amp;mut self, msg: JwtValue, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::test_scan_user;

        let user = test_scan_user(String::from(&amp;msg.email), String::from(&amp;msg.id), &amp;self.0.get().expect(&quot;Failed to open connection&quot;));
        match user {
            Err(_) =&gt; false,
            Ok(user) =&gt; {
                match (user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id) {
                    (true, true, true) =&gt; true,
                    _ =&gt; false
                }
            }
        }
    }
}

// src/todo_api/db/auth.rs
#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn scan_user(user_email: String, conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt; {
    use crate::schema::auth_user::dsl::*;

    let items = auth_user.filter(email.eq(&amp;user_email)).load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users.first().unwrap().clone().to_owned()),
        Err(_) =&gt; Err(DbError::CannotFindUser),
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn scan_user(user_email: String, _conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt; {
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;
    let query = auth_user.filter(email.eq(&amp;user_email));
    let expected = &quot;SELECT \&quot;auth_user\&quot;.\&quot;email\&quot;, \&quot;auth_user\&quot;.\&quot;id\&quot;, \&quot;auth_user\&quot;.\&quot;password\&quot;, \&quot;auth_user\&quot;.\&quot;expires_at\&quot;, \&quot;auth_user\&quot;.\&quot;is_active\&quot; FROM \&quot;auth_user\&quot; WHERE \&quot;auth_user\&quot;.\&quot;email\&quot; = $1 -- binds: [\&quot;my@email.com\&quot;]&quot;.to_string();

    assert_eq!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string(), expected);
    Ok(User::from(user_email, &quot;this is a hash&quot;.to_string()))
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn test_scan_user(user_email: String, auth_id: String, _conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt; {
    Ok(User::test_from(user_email, &quot;this is a hash&quot;.to_string(), auth_id))
}

// src/todo_api/model/auth.rs
impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
            is_active: false,
        }
    }

    #[cfg(feature = &quot;dbtest&quot;)]
    pub fn test_from(email: String, password: String, id: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::parse_str(&amp;id).unwrap(),
            password: password,
            expires_at: utc.naive_utc(),
            is_active: true,
        }
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Precisamos modificar <code>handle</code> pois precisamos enviar <code>id</code> como argumento para validar seu valor posteriormente. Como enviamos id, precisamos modificar <code>scan_user</code> para criar um <code>test_scan_user</code> que receba o <code>id</code> como argumento e passe para um <code>User::from</code> que também suporte configurar <code>id</code> e definir <code>is_active</code> como <code>true</code>. Com isso, todos nossos testes passam e podemos prosseguir para os últimos passos, criar um CI, obter um <code>todo</code> pelo seu <code>id</code> e fazer update de um <code>todo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configurando-um-ci"><a class="header" href="#configurando-um-ci">Configurando um CI</a></h1>
<p>Como já temos a estrutura central de nosso projeto pronta (autenticação com postgres, gerenciamento de dados com DynamoDB e middlewares) podemos começar a pensar em um CI. Para isso, devemos considerar as restrições que temos no nosso <code>make test</code>, que executamos contra um container docker do psotgres:</p>
<pre><code class="language-sh">db:
	docker run -i --rm --name auth-db -p 5432:5432 -e POSTGRES_USER=auth -e POSTGRES_PASSWORD=secret -d postgres

int: db
	sleep 2
	diesel setup
	diesel migration run
	cargo test --test lib --no-fail-fast --features &quot;dbtest&quot; -- --test-threads 3
	diesel migration redo


unit:
	cargo test --locked  --no-fail-fast --lib -- --test-threads 3

test: unit int
</code></pre>
<p>Nosso Makefile para testes consistem em 3 alvos <code>int</code> para testes de integração, <code>unit</code> para testes unitários e <code>test</code> para executar os dois. Algo que podemos ficar em dúvida é o porquê deles estarem separados em <code>int</code> e <code>unit</code>, o motivo é simplesmente que é mais fácil executar os testes unitários e eles são executados mais rapidamente que os de integração. Bom, vamos aos nossos alvos de teste. o alvo <code>unit</code> possui as flags <code>--lib</code> que executa somente os testes encontrados nos módulos de <code>lib.rs</code> e a flag <code>--no-fail-fast</code> que executa todos os testes mesmo que algum deles falhe. Para um CI é bastante útil esta flag de <code>--no-fail-fast</code>, pois queremos saber tudo que precisamos corrigir e, assim, não precisarmos ficar corrigindo a cada commit para a branch. Já o teste de integração possui diversos passos:</p>
<ol>
<li>executa o target <code>db</code>, que sobe um container docker com postgres.</li>
<li><code>sleep 2</code> pausa o processo por 2 segundos até que o container se estabilize.</li>
<li><code>diesel setup</code>, falamos anteriormente, mas ajuda o diesel a configurar o banco recém gerado (pode não ser necessário).</li>
<li><code>disel migration run</code>, executa as migrações para o banco.</li>
<li><code>cargo test</code>, os testes em si.</li>
<li><code>diesel migration redo</code>, não precisa estar presente no CI, pois o contaienr com postgres será destruido depois da execução, não necessitando fazer <code>rollback</code> das migrações.</li>
</ol>
<p>Agora vamos entender o item <code>5</code>. Executamos o <code>cargo test</code> com a flag  <code>--test</code> que indica que vamos executar os testes de integração apenas do arquivo <code>lib.rs</code>, que contém nossos módulos. Depois ativamos a feature <code>dbtest</code> com <code>--features &quot;dbtest&quot;</code>. Agora que sabemos os passos que precisamos executar no CI podemos começar a pensar em sua criação.</p>
<h2 id="travis-ci"><a class="header" href="#travis-ci">Travis-CI</a></h2>
<p>O modelo de CI que escolhi para este projeto é o Travis-CI, pois acredito que seja bem simples e executa tudo que precisamos fazer, build e testes. Para executar o travis-ci é necessário entrar no site deles, https://travis-ci.org/, se registrar e dar permissão para o seu github, existe um botão que já faz a autorização e o registro <code>Sign in with github</code>. Caso seus repositórios não apareçam, sugiro clicar em <code>profile</code>, imagem no canto superior direito, e na página de <code>profile</code> clicar em <code>sync account</code>. Agora basta você dar permissão para os repositórios específicos clicando nas chaves ao lado do nome dos repositórios.</p>
<p>Uma vez que esse processo de registro estiver pronto, você vai precisar adicionar um arquivo <code>.travis.yml</code> ao seu repositório. Este arquivo é uma sequencia de comandos que o CI precisará executar. No nosso caso, este arquivo terá o seguinte formato:</p>
<pre><code class="language-yaml">language: rust
rust:
  - nightly
  - 1.40.0
  - stable
cache: cargo
services:
- postgresql
before_script:
- psql -c 'create database auth_db;' -U postgres
- echo &quot;DATABASE_URL=postgres://postgres@localhost/auth_db&quot; &gt; .env
- cargo install diesel_cli --no-default-features --features=postgres
- diesel migration run
script:
- cargo build --verbose --all
- cargo test --locked  --no-fail-fast --lib
- cargo test --test lib --no-fail-fast --features &quot;dbtest&quot;
</code></pre>
<p>O primeiro passo é declarar qual linguagem que estamos utilizando, no nosso caso <code>rust</code>, <code>language: rust</code>. Depois disso, definimos quais targets de rust vamos executar nosso código. Como a versão de rust que eu estou suando é a <code>1.40</code>, espero que o código tenha que passar pelo menos nesta versão, além disso, gostaria de testar em <code>nightly</code> e na última <code>stable</code> sob a chave <code>rust:</code>. Precisamos do <code>cargo</code> também, para isso salvamos seu conteúdo em cache com  <code>cache: cargo</code>. O serviço que vamos utilizar como banco de dados é o postgres, assim é necessário declará-lo em <code>services: - postgresql</code>. O próximo passo corresponde aos scripts q devemos executar antes dos nossos cenários de teste, para isso utilizamos a chave <code>before_script</code> com os seguintes ítens:</p>
<ul>
<li><code>psql -c 'create database auth_db;' -U postgres</code>, corresponde ao <code>diesel setup</code> e nos permite criar a base de dados <code>auth_db</code> no postgres.</li>
<li><code>echo &quot;DATABASE_URL=postgres://postgres@localhost/auth_db&quot; &gt; .env</code> é preciso ter o campo <code>DATABASE_URL</code> configurado em seu <code>.env</code> para executar o <code>DbExecutor</code>, assim utilizamos o <code>echo &lt;campo exportado&gt; &gt; .env</code> para enviar o campo exportado para <code>.env</code>.</li>
<li><code>cargo install diesel_cli --no-default-features --features=postgres</code> instalamos o <code>diesel_cli</code> para poder executar as migrações.</li>
<li><code>diesel migration run</code>, executamos as migrações.</li>
</ul>
<p>Por último, definimos os scripts que vamos executar com a chave <code>script:</code>:</p>
<ul>
<li><code>cargo build --verbose --all</code>, testar se o build funciona.</li>
<li><code>cargo test --locked  --no-fail-fast --lib</code> executar os testes unitários.</li>
<li><code>cargo test --test lib --no-fail-fast --features &quot;dbtest&quot;</code>, executar os testes de integração.</li>
</ul>
<p>Quando comitarmos isso e habilitarmos o travis ler este repositório, teremos um resultado como este:</p>
<p><img src="part-1/../imagens/travis.png" alt="Resultado do Travis CI para o Todo Server" /></p>
<p>Agora podemos terminar nosso todo sever implementando um <code>get by id</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concluindo-o-serviço"><a class="header" href="#concluindo-o-serviço">Concluindo o serviço</a></h1>
<p>Falta pouco para termos nosso serviço pronto, pois precisamos implementar um <code>get</code> por id e um <code>update</code>. O <code>get</code> por id não é muito diferente da rota <code>index</code>, a única diferença é que vamos passar um parâmetro <code>id</code> e chamaremos a rota de <code>show</code> e será um método <code>GET</code> também. Já o <code>update</code> é um pouco diferente pois vamos enviar um corpo Json com as informações para atualizar em uma rota <code>update</code> com o método <code>PUT</code>. Assim, os endpoints que vamos implementar são:</p>
<ol>
<li>HTTP autenticado em <code>show/{id}</code> com o método <code>GET</code>.</li>
<li>HTTP autenticado em <code>update/{id}</code> com o método <code>PUT</code> e um body do tipo Json.</li>
</ol>
<h2 id="show-por-id"><a class="header" href="#show-por-id">Show por ID</a></h2>
<p>Como já falamos anteriormente, nosso objetivo agora é recuperar um <code>TodoCard</code> com base em seu <code>id</code> de inserção no banco de dados. Faremos isso utilizando a mesma função que utilizamos na rota <code>index</code>, <code>scan</code>. Para isso, sabemos que vamos precisar da rota <code>show/{id}</code>, como já mencionamos, e vamos precisar retornar um <code>TodoCard</code>. Assim, imagino que um bom teste para este cenário seria o seguinte:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(test)]
mod show_by_id {
    use actix_web::{test, App};
    use dotenv::dotenv;
    use todo_server::todo_api_web::model::{
        http::Clients,
        todo::TodoCard,
    };
    use todo_server::todo_api_web::routes::app_routes;
    use serde_json::from_str;
    use crate::helpers::{mock_get_todos};

    #[actix_rt::test]
    async fn test_todo_card_by_id() {
        dotenv().ok();
        let mut app =
            test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

        let req = test::TestRequest::with_uri(&quot;/api/show/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;).to_request();
        let resp = test::read_response(&amp;mut app, req).await;

        let todo_card: TodoCard =
            from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
        assert_eq!(&amp;todo_card, mock_get_todos().get(0usize).unwrap());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este teste consiste em definir um request com um uuid, neste caso aleatório, para a rota <code>show</code> com <code>test::TestRequest::with_uri(&quot;/api/show/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;).to_request()</code>. Com o request em mão, chamamos o serviço para obter uma respose com <code>test::read_response(&amp;mut app, req).await</code> e convertemos esta response em um <code>TodoCard</code>, <code>let todo_card: TodoCard = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap()</code>. Como vamos mockar a resposta de <code>TodoCard</code> com o primeiro valor de <code>mock_get_todos</code>, basta comparar os dois com <code>assert_eq!(&amp;todo_card, mock_get_todos().get(0usize).unwrap())</code>.</p>
<p>O primeiro passo para resolver este teste é adicionar a rota a função <code>app_routes</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/routes.rs
// ...
pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                    .route(&quot;create&quot;, web::post().to(create_todo))
                    .route(&quot;index&quot;, web::get().to(show_all_todo))
                    .route(&quot;show/{id}&quot;, web::get().to(show_by_id)),
            )
            .service(
                web::scope(&quot;auth/&quot;)
                    .route(&quot;signup&quot;, web::post().to(signup_user))
                    .route(&quot;login&quot;, web::post().to(login))
                    .route(&quot;logout&quot;, web::delete().to(logout)),
            )
            .route(&quot;ping&quot;, web::get().to(pong))
            .route(&quot;~/ready&quot;, web::get().to(readiness))
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Para recebermos o ID como argumento de rota precisamos definir-lo como <code>{id}</code>, depois disso fazemos um <code>GET</code> redirecionando o request para o controller <code>show_by_id</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/todo.rs
// ...
pub async fn show_by_id(id: web::Path&lt;String&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    match get_todo_by_id(uuid, state.dynamo.clone()) {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::NotFound().finish()
        }
        Some(todo_id) =&gt; HttpResponse::Ok().content_type(&quot;application/json&quot;)
            .json(todo_id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Na função <code>show_by_id</code> vemos um ítem novo logo de cara, <code>web::Path&lt;String&gt;</code>, a função deste ítem é extrair o conteúdo dos argumentos presentes na url do request, ou seja, todas as chaves encontradas entres os símbolos <code>{</code> e <code>}</code>, no nosso caso <code>{id}</code>. Para o caso de um único argumento a estrutura de <code>web::Path</code> é como estamos utilizando, mas para o caso de mais argumentos se utiliza tuplas para definir a sequencia de argumentos, por exemplo <code>/api/show/{id}/task/{title}</code>, uma rota para obter o status de uma <code>task</code> de um <code>TodoCard</code> de <code>id</code> específico, obteriamos os valores com <code>web::Path&lt;(String,String)&gt;</code>. Valores diferentes de string podem ser passados desde que sejam serializáveis pelo serviço, por exemplo o código que escrevemos poderia substituir <code>String</code> por <code>Uuid</code>, caso fossemos utiliza-la:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_by_id(id: web::Path&lt;uuid::Uuid&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.into_inner().to_string();
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Não vamos utilizar o <code>web::Path</code> com <code>Uuid</code> pois, no futuro, vamos querer enviar um response <code>BadRequest</code> caso o campo <code>id</code> não seja um <code>Uuid</code>. Se deixassemos assim o response seria <code>InternalServerError</code>, que não é um status muito indicativo. Mantendo o <code>web::Path</code> como <code>String</code> passamos ao próximo ítem, uma funcnao de <code>todo_api/db/todo.rs</code> que recupera um <code>TodoCard</code> com base em seu <code>id</code>, <code>get_todo_by_id</code>. Os argumentos passados a <code>get_todo_by_id</code> são uma <code>String</code> contendo o <code>id</code> e o cliente para <code>dynamo</code>. Essa função retorna o tipo <code>Option&lt;TodoCard&gt;</code>, que para o padrão <code>None</code> vai retornar um status <code>NotFound</code>, indicando que este elemento não foi encontrado e para o caso <code>Some</code> vai retornar um <code>Ok</code> com um corpo contendo um Json com o valor do <code>TodoCard</code> encontrado.</p>
<p>A função <code>get_todo_by_id</code> é semelhante a função <code>get_todos</code>, mas com uma pequerna diferença, a struct <code>ScanInput</code> utilizanda para fazer a busca no banco possui dois campos extras <code>filter_expression</code> e <code>expression_attribute_values</code>. <code>filter_expression</code> é responsável por definir qual vai ser o filtro aplicado a este <code>scan</code>, por exemplo <code>=, &gt;=, &lt;</code>. No nosso caso, nossa <code>filter_expression</code> será <code>Some(&quot;id = :id&quot;.into())</code>, ou seja, vamos procurar um <code>id</code> que seja igual ao argumento <code>:id</code>. Poderiamos ter mais filtros em <code>filter_expression</code>, mas usaremos somente esse. Agora precisamos definir o argumento <code>:id</code> para aplicar em <code>filter_expression</code>. Este argumento é adicionado a query através de <code>expression_attribute_values</code>, que recebe um <code>HashMap</code> contendo o nome das chaves, <code>:id</code> no nosso caso, e um <code>AttributeValue</code> com a informação de <code>id</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use rusoto_dynamodb::{AttributeValue, DynamoDb};


let mut _map = HashMap::new();
let mut attr = AttributeValue::default();
attr.s = Some(id);
_map.insert(String::from(&quot;:id&quot;), attr);

let scan_item = ScanInput {
    // ...
    filter_expression: Some(&quot;id = :id&quot;.into()),
    expression_attribute_values: Some(_map),
    ..ScanInput::default()
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Filter Expression</strong></p>
<p>A lista de possíveis operadores para <code>filter_expression</code> é a seguinte:</p>
<ul>
<li>Funções: <code>attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size</code>, todas sensitivas a letras maísculas.</li>
<li>Operadores de comparação: <code>= | &lt;&gt; | &lt; | &gt; | &lt;= | &gt;= | BETWEEN | IN</code></li>
<li>Operadores lógicos: <code>AND | OR | NOT</code></li>
</ul>
</blockquote>
<p>Com a Struct <code>ScanInput</code> definida podemos executar a query em si com <code>client.scan(scan_item).sync()</code> e aplicar um <code>match</code> a resposta de <code>scan</code>. Existem dois padrões possíveis <code>Ok</code> e <code>Err</code>, como nosso controller espera um <code>Option&lt;TodoCard&gt;</code> retornamos um <code>None</code> no caso de <code>Err</code>. E no caso de <code>Ok</code> ainda temos que cuidar o caso de a resposta de <code>Ok</code> vir vazia:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.scan(scan_item).sync() {
    Ok(resp) =&gt; {
        let todo_id = adapter::scanoutput_to_todocards(resp);
        if todo_id.first().is_some() {
            debug!(&quot;Scanned {:?} todo cards&quot;, todo_id);
            Some(todo_id.first().unwrap().to_owned())
        } else {
            error!(&quot;Could find todocard with ID.&quot;);
            None
        }
    }
    Err(e) =&gt; {
        error!(&quot;Could not scan todocard due to error {:?}&quot;, e);
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Como a estrutura de <code>resp</code> é um <code>ScanOutput</code>, como em <code>get_todos</code>, podemos aplicar o mesmo adapter <code>adapter::scanoutput_to_todocards</code> a <code>resp</code>, porém a resposta deste adapter será um vetor de <code>TodoCard</code>. Como queremos somente um único elemento na resposta dessa query, aplicamos a função <code>first</code> e validamos o caso de ela não retornar <code>Some</code>, indicando com uma respostas <code>None</code>. Para o caso de retornar sim, retornamos um <code>Option</code> com o primeiro <code>TodoCard</code> com <code>Some(todo_id.first().unwrap().to_owned())</code>. A função completa ficou como a seguir, funcnao de teste esta logo depois retornando apenas <code>Some(TodoCard{...})</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn get_todo_by_id(id: String, client: DynamoDbClient) -&gt; Option&lt;TodoCard&gt; {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;:id&quot;), attr);

    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        filter_expression: Some(&quot;id = :id&quot;.into()),
        expression_attribute_values: Some(_map),
        ..ScanInput::default()
    };

    match client.scan(scan_item).sync() {
        Ok(resp) =&gt; {
            let todo_id = adapter::scanoutput_to_todocards(resp);
            if todo_id.first().is_some() {
                debug!(&quot;Scanned {:?} todo cards&quot;, todo_id);
                Some(todo_id.first().unwrap().to_owned())
            } else {
                error!(&quot;Could find todocard with ID.&quot;);
                None
            }
        }
        Err(e) =&gt; {
            error!(&quot;Could not scan todocard due to error {:?}&quot;, e);
            None
        }
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn get_todo_by_id(id: String, client: DynamoDbClient) -&gt; Option&lt;TodoCard&gt; {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;
    use crate::todo_api_web::model::todo::{State, Task};

    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;:id&quot;), attr);

    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        filter_expression: Some(&quot;id = :id&quot;.into()),
        expression_attribute_values: Some(_map),
        ..ScanInput::default()
    };

    Some(
        TodoCard {
            id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
            title: String::from(&quot;This is a card&quot;),
            description: String::from(&quot;This is the description of the card&quot;),
            owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
            tasks: vec![
                Task {
                    title: String::from(&quot;title 1&quot;),
                    is_done: true,
                },
                Task {
                    title: String::from(&quot;title 2&quot;),
                    is_done: true,
                },
                Task {
                    title: String::from(&quot;title 3&quot;),
                    is_done: false,
                },
            ],
            state: State::Doing,
        }
    )
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="validando-o-uuid"><a class="header" href="#validando-o-uuid">Validando o Uuid</a></h3>
<p>Nosso próximo passo é validar que o formato enviado é um <code>Uuid</code>. Para isso criaremos um teste que faz um request com um formato aleatório de dado e retorna <code>BadRequest</code> com a mesagem que &quot;id deve ser um Uuid&quot;.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_todo_card_without_uuid() {
    dotenv().ok();
    let mut app =
        test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

    let req = test::TestRequest::with_uri(&quot;/api/show/fake-uuid&quot;).to_request();
    let resp = test::read_response(&amp;mut app, req).await;

    let message = String::from_utf8(resp.to_vec()).unwrap();
    assert_eq!(&amp;message, &quot;Id must be a Uuid::V4&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver este teste a implementação de código é bastante simples, basta adicioanrmos um <code>if</code> que verifica se o <code>parse_str</code> é do tipo <code>Err</code> e em caso de <code>true</code> retornar <code>HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;)</code>. Assim, nossa função ficou da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_by_id(id: web::Path&lt;String&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    if uuid::Uuid::parse_str(&amp;uuid).is_err() {
        return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
    }

    match get_todo_by_id(uuid, state.dynamo.clone()) {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::NotFound().finish()
        }
        Some(todo_id) =&gt; HttpResponse::Ok().content_type(&quot;application/json&quot;)
            .json(todo_id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="atualizando-todocards"><a class="header" href="#atualizando-todocards">Atualizando TodoCards</a></h2>
<p>Agora vamos aprender como atualizar as informações de uma <code>TodoCard</code> no DynamoDB. Vamos focar em atualizar somente dois atributos <code>description</code> e <code>state</code>, depois discutiremos estratégias para implementar updates em <code>tasks</code>, pois os outros argumentos são essencialmente iguais a <code>description</code> e <code>state</code>. Agora precisamos definir como será nosso endpoint de atualização, para isso podemos definir sua rota como <code>/api/update/{id}</code> e responderá via método <code>PUT</code>. Assim, nosso body conterá os campos <code>state</code> e/ou <code>description</code>, como no exemplo de <code>put_todo.json</code>:</p>
<pre><code class="language-json">{
	&quot;state&quot;: &quot;Doing&quot;,
	&quot;description&quot;: &quot;dfwgferf&quot;
}
</code></pre>
<p>Um teste para esse cenário seria o seguinte:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/test_api_web/controller.rs
// ...
#[cfg(test)]
mod update {
    use actix_web::{test, App, http::StatusCode};
    use dotenv::dotenv;
    use todo_server::todo_api_web::model::{
        http::Clients,
    };
    use todo_server::todo_api_web::routes::app_routes;
    use crate::helpers::{read_json};


    #[actix_rt::test]
    async fn test_todo_card_by_id() {
        dotenv().ok();
        let mut app =
            test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

        let req = test::TestRequest::put()
            .uri(&quot;/api/update/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;put_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        assert_eq!(resp.status(), StatusCode::OK);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="criando-a-rota"><a class="header" href="#criando-a-rota">Criando a Rota</a></h3>
<p>Temos nosso teste, mas agora precisamos criar a rota em <code>src/todo_api_web/routes.rs</code> seguindo o padrão <code>PUT</code> na rota <code>/api/update/{id}</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    todo::{create_todo, show_all_todo, show_by_id, update_todo},
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                    .route(&quot;create&quot;, web::post().to(create_todo))
                    .route(&quot;index&quot;, web::get().to(show_all_todo))
                    .route(&quot;show/{id}&quot;, web::get().to(show_by_id))
                    .route(&quot;update/{id}&quot;, web::put().to(update_todo)),
            )
            // ...
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, precisamos implementar o controller <code>update_todo</code> em <code>src/todo_api_web/controller/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn update_todo(
    id: web::Path&lt;String&gt;,
    info: web::Json&lt;TodoCardUpdate&gt;, 
    state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    if uuid::Uuid::parse_str(&amp;uuid).is_err() {
        return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
    }

    match update_todo_info(uuid, info.into_inner(), state.dynamo.clone()) {
        true =&gt; HttpResponse::Ok().finish(),
        false =&gt; HttpResponse::NotFound().finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Os argumentos para a função <code>update_todo</code> são <code>id</code> que vem da rota da url <code>{id}</code> com <code>web::Path&lt;String&gt;</code>, <code>info</code> que corresponde ao corpo do <code>PUT</code> do tipo <code>web::Json&lt;TodoCardUpdate&gt;</code> e o <code>state</code> que vem do estao da aplicação com <code>web::Data&lt;Clients&gt;</code>. Primeiro passo é converter o campo <code>id</code> em <code>String</code> com <code>to_string</code> para validar se essa string é um <code>Uuid</code> com <code>uuid::Uuid::parse_str(&amp;uuid)</code> e retornar um <code>HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;)</code> caso o resultado de <code>parse_str</code> seja do tipo <code>Err</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uuid = id.to_string();

if uuid::Uuid::parse_str(&amp;uuid).is_err() {
    return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois disso, chamamos a função <code>update_todo_info</code> que retorna um booleano para aplicarmos pattern matching em <code>true</code>, retornando <code>HttpResponse::Ok().finish()</code>, ou em <code>false</code>, retornando <code>HttpResponse::NotFound().finish()</code>. A função <code>update_todo_info</code> está localizada em <code>src/todo_api/db/todo.rs</code> e é bastante extensa:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn update_todo_info(id: String, info: TodoCardUpdate, client: DynamoDbClient) -&gt; bool {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let expression = adapter::update_expression(&amp;info);
    let attribute_values = adapter::expression_attribute_values(&amp;info);
    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;id&quot;), attr);

    let update = UpdateItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        key: _map,
        update_expression: expression,
        expression_attribute_values: attribute_values,
        ..UpdateItemInput::default()
    };

    match client.update_item(update).sync() {
        Ok(_) =&gt; true,
        Err(e) =&gt; {
            error!(&quot;failed due to {:?}&quot;, e);
            false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que precisamos ressaltar neste código é o <code>UpdateItemInput</code>, que é a struct responsável por executar a atualização da <code>todo</code> com o <code>id</code> enviado na rota. Os campos necessários são <code>table_name</code>, que é o nome da tabela, <code>key</code> que é um <code>AttributeValue</code> com todos os valores de <code>key</code>, no nosso caso é somente <code>id</code>, <code>update_expression</code> que define quais argumentos serão atualizados através do adapter <code>adapter::update_expression</code>, <code>expression_attribute_values</code> que contém os argumentos para atualizar as informações através do <code>adapter::expression_attribute_values</code> que transforma os valores de <code>TodoCardUpdate</code> em um <code>HashMap&lt;String, AttributeValue&gt;</code>. Assim, para transformar o <code>id</code> em um <code>HashMap&lt;String, AttributeValue&gt;</code> podemos utilizar a seguinte lógica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut _map = HashMap::new();
let mut attr = AttributeValue::default();
attr.s = Some(id);
_map.insert(String::from(&quot;id&quot;), attr);
<span class="boring">}
</span></code></pre></pre>
<p>A função para executar a atualização no Dynamo é <code>update_item</code>, lembre-se que após o <code>sync</code> o resultado é do tipo <code>Result</code>, por isso do <code>match</code>. Já os adapter são os seguintes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
// ...
pub fn update_expression(info: &amp;TodoCardUpdate) -&gt; Option&lt;String&gt; {
    let data = info.clone();
    match (data.description, data.state) {
        (Some(_), Some(_)) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s&quot;)),
        (_, Some(_)) =&gt; Some(String::from(&quot;SET  state_db = :s&quot;)),
        (Some(_), _) =&gt; Some(String::from(&quot;SET description = :d&quot;)),
        _ =&gt; None
    }
}

pub fn expression_attribute_values(info: &amp;TodoCardUpdate) -&gt; Option&lt;HashMap&lt;String, AttributeValue&gt;&gt; {
    let data = info.clone();
    match (data.description, data.state) {
        (Some(desc), Some(state)) =&gt; {
            let mut _map = HashMap::new();
            let mut attr_d = AttributeValue::default();
            attr_d.s = Some(String::from(desc));
            let mut attr_s = AttributeValue::default();
            attr_s.s = Some(String::from(state.to_string()));
            _map.insert(String::from(&quot;:d&quot;), attr_d);
            _map.insert(String::from(&quot;:s&quot;), attr_s);
            Some(_map)
        },
        (_, Some(state)) =&gt; {
            let mut _map = HashMap::new();
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(state.to_string()));
            _map.insert(String::from(&quot;:s&quot;), attr);
            Some(_map)
        },
        (Some(desc), _) =&gt; {
            let mut _map = HashMap::new();
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(desc));
            _map.insert(String::from(&quot;:d&quot;), attr);
            Some(_map)
        },
        _ =&gt; None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>update_expression</code> é responsável pro criar a expressão que vai determinar o que será atualizado. Como recebemos 2 campos <code>Optional</code>, <code>description</code> e <code>state</code>, temos 4 possibilidades:</p>
<ol>
<li>Ambos existem retorna <code>&quot;SET description = :d, state_db = :s&quot;)</code>.</li>
<li>Somente <code>state</code> existe retorna <code>&quot;SET state_db = :s&quot;</code>.</li>
<li>Somente <code>description</code> existe retorna <code>&quot;SET description = :d&quot;</code>.</li>
<li>Nenhum retorna um <code>None</code>.</li>
</ol>
<p>Os testes para <code>update_expression</code> são os seguintes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod update_expression_test {
    use super::update_expression;
    use crate::todo_api_web::model::todo::{State, TodoCardUpdate};

    #[test]
    fn description_and_state() {
        let todo_update = TodoCardUpdate {description: Some(&quot;haiushdusd&quot;.to_string()), state: Some(State::Doing)};
        let expected = Some(String::from(&quot;SET description = :d, state_db = :s&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn description() {
        let todo_update = TodoCardUpdate {description: Some(&quot;haiushdusd&quot;.to_string()), state: None};
        let expected = Some(String::from(&quot;SET description = :d&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn state() {
        let todo_update = TodoCardUpdate {description: None, state: Some(State::Doing)};
        let expected = Some(String::from(&quot;SET state_db = :s&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn none() {
        let todo_update = TodoCardUpdate {description: None, state: None};
        let expected = None;

        assert_eq!(expected, update_expression(&amp;todo_update));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Já <code>expression_attribute_values</code> é um pouco mais complicada pois deve retornar um <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code>, mas as regras de pattern matching são as mesmas. Assim vamos entender o caso que existe tanto <code>description</code> quanto <code>state</code>. Para <code>update_expression</code> não nos interessava o conteúdo da expression, assim utilizavamos <code>Some(_)</code> para fazer pattern matching, porém em <code>expression_attribute_values</code> eles interessam já que será inseridos dentro do <code>HashMap</code>. A primeira cosia que devemos fazer é criar um <code>HashMap</code> com <code>let mut _map = HashMap::new();</code> e determinar os <code>AttributeValue</code> para <code>state</code> e para <code>description</code>, <code>let mut attr_s = AttributeValue::default();</code> e <code>let mut attr_d = AttributeValue::default();</code> respectivamente. Depois disso, inserimos o conteúdo de <code>state</code> e de <code>description</code> no campo <code>s</code>, de String, através de <code>attr_d.s</code>, <code>attr_s.s = Some(String::from(state.to_string()));</code> e <code>attr_d.s = Some(String::from(desc));</code>. Inserimos estes valores no mapa com <code>_map.insert(String::from(&quot;:d&quot;), attr_d); _map.insert(String::from(&quot;:s&quot;), attr_s);</code> e retornamos seu valor em <code>Some(_map)</code>. A função para teste é a seguinte: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dbtest&quot;)]
pub fn update_todo_info(id: String, info: TodoCardUpdate, client: DynamoDbClient) -&gt; bool {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let expression = adapter::update_expression(&amp;info);
    let attribute_values = adapter::expression_attribute_values(&amp;info);
    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;id&quot;), attr);

    let update = UpdateItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        key: _map,
        update_expression: expression,
        expression_attribute_values: attribute_values,
        ..UpdateItemInput::default()
    };

    true
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos entender como nosso código mudaria para incluir os outros campos de atualização.</p>
<h2 id="atualizando-outros-campos"><a class="header" href="#atualizando-outros-campos">Atualizando outros campos</a></h2>
<p>Considerando que a struct que temos no banco de dados é a seguinte e que o campo <code>id</code> não será atualizado, podemos discutir como adicionar <code>title</code>, <code>owner</code> e <code>tasks</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TodoCard {
    pub id: Option&lt;Uuid&gt;,
    pub title: String,
    pub description: String,
    pub owner: Uuid,
    pub tasks: Vec&lt;Task&gt;,
    pub state: State,
}
<span class="boring">}
</span></code></pre></pre>
<p>Bom, <code>title</code> e <code>owner</code> são bastante triviais, pois bastaria expandir nossos adapters para lidarem com mais duas strings, modificando nossa struct <code>TodoCardUpdate</code> para:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TodoCardUpdate {
    pub description: Option&lt;String&gt;,
    pub state: Option&lt;State&gt;,
    pub title: Option&lt;String&gt;,
    pub owner: Option&lt;Uuid&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Já o adapter <code>update_expression</code> ficaria semelhante ao seguinte:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_expression(info: &amp;TodoCardUpdate) -&gt; Option&lt;String&gt; {
    let data = info.clone();
    match (data.description, data.state, data.title, data.owner) {
        (Some(_), Some(_), Some(_), Some(_)) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s, title = :t, owner = :o&quot;)),
        ...
        (Some(_), Some(_), _, _) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s&quot;)),
        (_, Some(_), Some(_), _) =&gt; Some(String::from(&quot;SET title = :t, state_db = :s&quot;)),
        (_, _, Some(_), Some(_)) =&gt; Some(String::from(&quot;SET title = :t, owner = :o&quot;)),
        (Some(_), _, _, Some(_)) =&gt; Some(String::from(&quot;SET description = :d, owner = :o&quot;)),
        ...
        (_, Some(_), _, _) =&gt; Some(String::from(&quot;SET  state_db = :s&quot;)),
        (Some(_), _, _, _) =&gt; Some(String::from(&quot;SET description = :d&quot;)),
        (_, _, Some(_), _) =&gt; Some(String::from(&quot;SET title = :t&quot;)),
        (_, _, _, Some(_)) =&gt; Some(String::from(&quot;SET owner = :o&quot;)),
        _ =&gt; None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Acredito que esta solução pode ficar um pouco verbosa, assim, uma ideia seria transformar esses 4 campos em um vetor e iterar nele de forma posicional, o que não geraria uma solução muito elegante também, mas seria muito útil para o caso de <code>expression_attribute_values</code>, como o <strong>pseudo código</strong> a seguir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// pseudo código
pub fn expression_attribute_values(info: &amp;TodoCardUpdate) -&gt; Option&lt;HashMap&lt;String, AttributeValue&gt;&gt; {
    let data = info.clone();
    let mut _map = HashMap::new();
    let data_vec = vec![data.description, data.state, data.title, data.owner];

    data_vec.iter()
        .map(|i| if i.is_some() {
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(i));
            attr
        } else {
            None
        })
        .enumerate(|(idx, item)| 
          match idx {
              0 =&gt; (&quot;:d&quot;.to_string(), item),
              1 =&gt; (&quot;:s&quot;.to_string(), item),
              2 =&gt; (&quot;:t&quot;.to_string(), item),
              3 =&gt; (&quot;:o&quot;.to_string(), item),
              _ =&gt; (&quot;&quot;.to_string(), None)
          })
        .fold(_map,|acc, i| 
          if i.is_some() {
              acc.insert(i.0, i.1)
          };
          acc);
        Some(_map)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tasks"><a class="header" href="#tasks">Tasks</a></h3>
<p>Agora precisamos discutir <code>tasks</code>, elas são mais complicadas pois não criamos o conceito de <code>id</code> nelas, assim a solução que eu creio ser mais simples para lidar com elas é criar uma struct que contém três argumentos <code>is_bool</code>, <code>previous_text</code>, <code>new_text</code>. O campo <code>is_bool</code> é equivalente ao da struct <code>Task</code>, já o argumento <code>previous_text</code> é o argumento que identifica qual o texto existente de <code>Task</code> no banco, e <code>new_text</code> é o texto que queremos atualizar. Para entender como ficaria a adição, a atualização e o remoção teremos o seguinte:</p>
<ul>
<li>Adicão: <code>previous_text = None</code>, <code>new_text = Some</code>.</li>
<li>Atualização: <code>previous_text = Some</code>, <code>new_text = Some</code>.</li>
<li>Remoção: <code>previous_text = Some</code>, <code>new_text = None</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskUpdate {
    pub is_bool: bool,
    pub previous_text: Option&lt;String&gt;,
    pub new_text: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Portanto, quando identificarmos que <code>previous_text</code> não existe, criamos uma nova <code>task</code>, e quando identificarmos que <code>new_text</code> não existe, deletamos a <code>task</code> com o texto da <code>previous_text</code>. Já a atualização filtramos todas as tasks que contém o <code>previous_text</code> com <code>new_text</code>, assim se ambos são iguais atualizamos somente <code>is_bool</code> e em caso de não existir uma task com <code>previous_text</code>, simplesmente criamos uma nova <code>new_text</code>. Isso poderia ser feito em endpoint que responde a um <code>POST</code> em <code>/api/update/{id}/tasks</code>. </p>
<p>Fica como um bom desafio fazer estas mudanças que discutimos aqui antes de seguir para a próxima parte, assim como criar um endpoint de <code>DELETE</code>. Nesta parte aprendemos a criar um serviço <code>REST</code> com actix que cria e gerencia tarefas via <code>create</code>, <code>update</code>, <code>show</code> e <code>index</code>, salvando estas informações em um DynamoDB. Além disso, criamos um middleware de autenticação e endpoints de autenticação, via diesel. Outros middlewares que utilizamos foi o <code>Logger</code>, que infelizmente não funciona com <code>dotenv</code>, necessária para o <code>Logger</code>, e um middleware que cria o header <code>x-request-id</code>. Aprendemos a gerenciar o estado da aplicação com <code>.data()</code> e a configurar rotas com <code>.configure()</code>. Por último, aprendemos a tornar nosso sistema tolerante a falhas e a configurar o docker com todas as dependências.</p>
<p>Agora vamos aprender a utilizar graphql com Actix para fazer um sistema de busca de rotas de voos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-com-actix"><a class="header" href="#graphql-com-actix">GraphQL com Actix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configurando-o-graphql"><a class="header" href="#configurando-o-graphql">Configurando o GraphQL</a></h1>
<p>Agora que temos contexto de como funciona o Actix, será muito mais simples criar um novo serviço, assim o objetivo neste capítulo será focar na parte GraphQL deste novo serviço. Antes vamos entender um pouco o que é GraphQL e porque vamos utlizar essa tecnologia.</p>
<h2 id="graphql"><a class="header" href="#graphql">GraphQL</a></h2>
<p>GraphQL é uma tecnologia desenvolvida pelo Facebook que consiste em uma linguagem de queries para APIs e um runtime para executar estas queries. Além disso, GraphQL provê ferramentas para entender e descrever os dados das APIs, da ao cliente o poder de decidir quais dados quer consumir e facilita e evolução de APIs. De forma resumida, são quatro etapas que envolvem o GraphQL:</p>
<ol>
<li>Descrever seus dados via tipos:</li>
</ol>
<pre><code class="language-graphql">type Project {
  name: String
  tagline: String
  contributors: [User]
}
</code></pre>
<ol start="2">
<li>Receber um request com os dados a serem consumidos:</li>
</ol>
<pre><code class="language-graphql">{
  project(name: &quot;GraphQL&quot;) {
    tagline
  }
}
</code></pre>
<ol start="3">
<li>Realizar as consultas a todos os serviços/APIs necessários</li>
<li>Responder exatamente o que o cliente pediu.</li>
</ol>
<pre><code class="language-json">{
    &quot;data&quot;: {
        &quot;project&quot;: {
            &quot;tagline&quot;: &quot;A query language for APIs&quot;
        }
    }
}
</code></pre>
<p>Assim, o motivo de escolhermos GraphQL como tecnologia para este serviço é a necessidade de consultar diversas fontes para um mesmo request, como mais de uma API e caching.</p>
<h2 id="queries-básicas"><a class="header" href="#queries-básicas">Queries Básicas</a></h2>
<p>Vamos começar com o básico, fazer o sistema responder <code>404 NOT_FOUND</code> para rotas diversas e depois iniciar com uma query que responderá um simples <code>pong</code> quando chamarmos a query <code>ping</code>. Para isso, nosso primeiro passo é criar o serviço com <code>cargo new recommendations-gql --bin</code>, e adicionar as dependências básicas ao nosso Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
actix-web = &quot;2.0.0&quot;
actix-rt = &quot;1.0.0&quot;
juniper = &quot;0.14.2&quot;
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
</code></pre>
<p>Agora precisamos adicionar o caso de status code <code>404</code>. Para esse caso vamos utilizar outro recurso que não utilizamos antes que é o <code>default_service</code>. Ele nos permite responder um valor default para qualquer rota não encontrada, neste caso escrevemos <code>404</code>:</p>
<pre><code class="language-rs">// main.rs
use actix_web::{web, App, HttpServer};

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(move || {
        App::new()
            .default_service(web::to(|| async { &quot;404&quot; }))
    })
    .bind(&quot;127.0.0.1:4000&quot;)?
    .run()
    .await
}
</code></pre>
<p>Pronto! ao acessar <code>localhost:4000</code> recebemos um <code>404</code>. Próximo passo é adicionarmos a query de <code>ping</code>.</p>
<h2 id="ping-em-graphql"><a class="header" href="#ping-em-graphql">Ping em GraphQL</a></h2>
<p>Primeiro passo para o <code>ping</code> seria pensarmos o schema correspondente na estrutura GraphQL. Assim, nosso objetivo é realizar uma query nomeada <code>ping</code> que retorne uma string contento <code>&quot;pong&quot;</code>. Para isso sabemos que precisaremos que uma função <code>ping</code> que retornar um <code>Result&lt;String, Error&gt;</code> que contém <code>pong</code>, algo como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ping() -&gt; Result&lt;String, Error&gt; {
    Ok(String::from(&quot;pong&quot;))
}
<span class="boring">}
</span></code></pre></pre>
<p>Mas esta função precisa estar dentro de um contexto <code>Query</code> do graphql e para isso criamos uma struct chamada de <code>QueryRoot</code>, que corresponde a raiz das queries, e aplicamos a macro <code>#[juniper::object]</code> que transforma essa implementação de queries, <code>impl QueryRoot</code>, em um objeto graphql do tipo <code>Query</code>. Note que o tipo de retorno é um <code>FieldResult</code>, que corresponde a um tipo <code>Result</code> que já abstraiu o tipo do <code>Error</code> para um erro que o GraphQL possa entender.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use juniper::FieldResult;

pub struct QueryRoot;

#[juniper::object]
impl QueryRoot {
    fn ping() -&gt; FieldResult&lt;String&gt; {
        Ok(String::from(&quot;pong&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Segundo passo seria declarar um tipo <code>Schema</code> que poderá ser utilizado pelos handlers do Graphql para validar as queries, as mutations e os tipos. Esse <code>Schema</code> é composto de duas partes, a <code>QueryRoot</code> e a <code>MutationRoot</code>, que são designadas a um nó contendo os schemas chamado <code>RootNode</code>, <code>pub type Schema = RootNode&lt;'static, QueryRoot, MutationRoot&gt;;</code>. Como ainda não temos nenhuma mutation, nosso <code>MutationRoot</code> é bastante simples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MutationRoot;

#[juniper::object]
impl MutationRoot {}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Queries e Mutations</p>
<p>O objetivo de uma query é &quot;perguntar&quot; para o sistema algum conjunto de infotmações, enquanto o objetivo da mutation é &quot;mutar&quot; alguma informação que o sistema possui, mas suas declarações são bastante parecidas com as das queries.</p>
</blockquote>
<p>Por último precisamos de uma função que retorne o schema que criamos, que chamaremos de <code>create_schema</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use juniper::FieldResult;
use juniper::RootNode;

pub struct QueryRoot;

#[juniper::object]
impl QueryRoot {
    fn ping() -&gt; FieldResult&lt;String&gt; {
        Ok(String::from(&quot;pong&quot;))
    }
}

pub struct MutationRoot;

#[juniper::object]
impl MutationRoot {}

pub type Schema = RootNode&lt;'static, QueryRoot, MutationRoot&gt;;

pub fn create_schema() -&gt; Schema {
    Schema::new(QueryRoot {}, MutationRoot {})
}
<span class="boring">}
</span></code></pre></pre>
<p>Com isso podemos criar o módulo <code>schema</code> em <code>schema.rs</code>. Próximo passo é disponibilizar este <code>Schema</code> para a aplicação, podemos fazer isso utilizando a função <code>data</code> de <code>actix_web::App</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate juniper;
extern crate serde_json;

use actix_web::{web, App, HttpServer};

mod schemas;

use crate::schemas::{create_schema, Schema};

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let schema: std::sync::Arc&lt;Schema&gt; = std::sync::Arc::new(create_schema());

    HttpServer::new(move || {
        App::new()
            .data(schema.clone())
            .default_service(web::to(|| async { &quot;404&quot; }))
    })
    .bind(&quot;127.0.0.1:4000&quot;)?
    .run()
    .await
}
</code></pre></pre>
<p>Estamos utilizando a definição <code>let schema: std::sync::Arc&lt;Schema&gt; =</code> para fazer um vínculo da variável <code>schema</code> ao contexto de <code>main</code>, note, também, que seu tipo precis ser <code>std::sync::Arc</code>, pois todas as threads do graphql estarão acessado esse <code>Schema</code>. O próximo passo é definirmos as rotas dos <code>handlers</code> para o GraphQL, fazemos isso no módulo <code>handlers</code> e exportamos estas infos pela função <code>routes</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate juniper;
extern crate serde_json;

use actix_web::{web, App, HttpServer};

mod handlers;
mod schemas;

use crate::handlers::routes;
use crate::schemas::{create_schema, Schema};


#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let schema: std::sync::Arc&lt;Schema&gt; = std::sync::Arc::new(create_schema());

    HttpServer::new(move || {
        App::new()
            .data(schema.clone())
            .configure(routes)
            .default_service(web::to(|| async { &quot;404&quot; }))
    })
    .bind(&quot;127.0.0.1:4000&quot;)?
    .run()
    .await
}
</code></pre></pre>
<p>Assim, a função <code>routes</code> do módulo <code>handlers</code> possuirá a seguinte estrutura:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn routes(config: &amp;mut web::ServiceConfig) {
    config
        .route(&quot;/graphql&quot;, web::post().to(graphql))
        .route(&quot;/graphiql&quot;, web::get().to(graphiql));
}
<span class="boring">}
</span></code></pre></pre>
<p>Nossa configuração possuirá duas rotas <code>/graphql</code>, que é a rota na qual fazemos um post com nossa query, e <code>/graphiql</code>, que será uma rota que nos exibirá uma página web interativa da nossa aplicação:</p>
<p><img src="part-2/../imagens/graphiqlping.png" alt="página interativa do graphiql" /></p>
<p>Note que a direita na rota <code>graphiql</code> existe uma aba chamada de <code>Documentation Explorer</code>, ela nos permite saber as queries e as mutations disponíveis, assim como seus tipos de entrada e tipos de retorno.</p>
<p>Agora, o handler <code>graphiql</code>é bastante simples, sua única função é encondar em <code>HTML</code> o handler <code>graphql</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn graphiql() -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_type(&quot;text/html; charset=utf-8&quot;)
        .body(graphiql_source(&quot;/graphql&quot;))
}
<span class="boring">}
</span></code></pre></pre>
<p>Com isso, podemos finalmente entender o que o handler <code>graphql</code> faz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

use actix_web::{web, Error, HttpResponse};
use juniper::http::graphiql::graphiql_source;
use juniper::http::GraphQLRequest;

use crate::schemas::{Schema};

pub async fn graphql(
    schema: web::Data&lt;Arc&lt;Schema&gt;&gt;,
    data: web::Json&lt;GraphQLRequest&gt;,
) -&gt; Result&lt;HttpResponse, Error&gt; {
    let res = web::block(move || {
        let res = data.execute(&amp;schema, &amp;());
        Ok::&lt;_, serde_json::error::Error&gt;(serde_json::to_string(&amp;res)?)
    })
    .await
    .map_err(Error::from)?;

    Ok(HttpResponse::Ok()
        .content_type(&quot;application/json&quot;)
        .body(res))
}
<span class="boring">}
</span></code></pre></pre>
<p>O handler <code>graphql</code> recebe como argumento dois campos 1. <code>schema</code> através do tipo actix <code>web::Data&lt;Arc&lt;Schema&gt;&gt;</code> e o request <code>data</code> do tipo <code>web::Json&lt;GraphQLRequest&gt;</code>. A magia acontece na linha <code>data.execute(&amp;schema, &amp;())</code>, na qual o GraphQL executa nosso request, <code>data</code>, com base no <code>schema</code>. Depois disso, encodamos o resultado para Json e respondemos como um <code>Result&lt;HttpResponse, Error&gt;</code> oriundo de <code> Ok(HttpResponse::Ok().content_type(&quot;application/json&quot;).body(res))</code>. Se você executar este código será possível fazer a query <code>ping</code> em localhost:4000/graphql:</p>
<p><img src="part-2/../imagens/ping_via_postman.png" alt="QUery ping em /graphql" /></p>
<h2 id="testando-o-endpoint"><a class="header" href="#testando-o-endpoint">Testando o endpoint</a></h2>
<p>Como na parte anterior do livro falamos de como criar testes de integração no diretório <code>tests/</code>, agora vamos partir para outra estratégia, que é criar testes de integração dentro do <code>src/</code>, pois isto nos permite tirar proveito da flag <code>#[cfg(test)]</code>. Para fazermos isso, precisamos criar um módulo <code>test</code>, anotoado com a flag <code>#[cfg(test)]</code> em <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
mod handlers;
mod schemas;
#[cfg(test)] mod test;
...
<span class="boring">}
</span></code></pre></pre>
<p>Depois disso é preciso criar o arquivo <code>src/test/mod.rs</code>, que declarará o nome dos submodulos de teste, neste caso um simples <code>pub mod ping;</code>. Para testarmos o <code>ping</code> precisamos criar o módulo que declaramos em <code>src/test/ping.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod ping_readiness {
    use crate::handlers::routes;
    use crate::schemas::{create_schema, Schema};

    use actix_web::{test, App};
    use bytes::Bytes;

    #[actix_rt::test]
    async fn test_ping_pong() {
        let schema: std::sync::Arc&lt;Schema&gt; = std::sync::Arc::new(create_schema());

        let mut app =
            test::init_service(App::new().data(schema.clone()).configure(routes)).await;

        let req = test::TestRequest::post()
            .uri(&quot;/graphql&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(&quot;{\&quot;query\&quot;: \&quot;query ping { ping }\&quot;}&quot;)
            .to_request();
        let resp = test::read_response(&amp;mut app, req).await;

        assert_eq!(resp, Bytes::from_static(b&quot;{\&quot;data\&quot;:{\&quot;ping\&quot;:\&quot;pong\&quot;}}&quot;));
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>A estrutura do teste é praticamente igual a estrutura que estavamos utilizando anteriormente, as únicas diferenças são <code>let schema: std::sync::Arc&lt;Schema&gt; = std::sync::Arc::new(create_schema());</code>, que a rota agora é <code>/graphql</code> e que o payload é um json contendo um campo <code>query</code> seguido de sua query <code>&quot;{\&quot;query\&quot;: \&quot;query ping { ping }\&quot;}&quot;</code>. </p>
<p>Agora vamos a implementação da primeira query de consulta, que chamaremos de <code>bestPrices</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-prices"><a class="header" href="#best-prices">Best Prices</a></h1>
<p>Nesta query, <code>bestPrices</code>, vamos fazer uma consulta a uma API externa que retorna os melhores preços para uma rota (data, origem e destino). Consultaremos a URL de <code>bestPrices</code> da Latam <code>https://bff.latam.com/ws/proxy/booking-webapp-bff/v1/public/revenue/bestprices/oneway?departure=&lt;YYYY-mm-dd&gt;&amp;origin=&lt;IATA&gt;&amp;destination=&lt;IATA&gt;&amp;cabin=Y&amp;country=BR&amp;language=PT&amp;home=pt_br&amp;adult=1&amp;promoCode=</code>, na qual <code>departure</code> é a data de partida no formato <code>ano-mes-dia</code>, <code>origin</code> é o código IATA da cidade ou do aeroporto de origem, <code>destination</code> é o código IATA da cidade ou do aeroporto de destino. Assim, nossa query deve receber 3 argumentos <code>departure</code>, <code>origin</code> e <code>destination</code> e retornar um conjunto de melhores preços, além de lançar erros. Caso estes argumentos não estejam dentro do padrão esperado. Com isso, nosso primeiro passo será implementar a função <code>bestPrices</code> que recebe os 3 argumentos e por enquanto retornará uma <code>String</code>.</p>
<h2 id="implementando-a-função-básica-de-bestprices"><a class="header" href="#implementando-a-função-básica-de-bestprices">Implementando a função básica de <code>bestPrices</code></a></h2>
<p>Nosso objetivo agora é fazer nosso GraphQL responder da seguinte forma:</p>
<p><img src="part-2/../imagens/bestpricesbasicquery.png" alt="bestPrices basic query" /></p>
<p>A query que usamos é:</p>
<pre><code class="language-graphql">query {
  bestPrices(
    departure: &quot;sdf&quot;, 
    origin: &quot;sdf&quot;, 
    destinantion: &quot;sdfg&quot;)
  ping
}
</code></pre>
<p>E o valor de retorno é:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bestPrices&quot;: &quot;test&quot;,
    &quot;ping&quot;: &quot;pong&quot;
  }
}
</code></pre>
<p>O resultado de uma query GraphQL como a que mostamos retorna o campo <code>data</code> que é um mapa contendo os resultados das queries <code>bestPrices</code> e <code>ping</code>. Para resolvermos isso, podemos escrever a seguinte função:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// schema/mod.rs
// ...
#[juniper::object]
impl QueryRoot {
    //...
    fn bestPrices(departure: String, origin: String, destinantion: String) -&gt; FieldResult&lt;String&gt; {
         Ok(String::from(&quot;test&quot;))
    }
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos começar a pensar um pouco melhor na organização do nosso código. Na seção de apresentação do livro desenhamos o seguinte diagrama:</p>
<pre><code>api
    main
    |-&gt; boundaries
        |-&gt; web
        |-&gt; db
        |-&gt; message
    |-&gt; controllers/resolvers
    |-&gt; adapters
    |-&gt; core 
        |-&gt; business
        |-&gt; compute
    |-&gt; models/schemas
</code></pre>
<p>Com este esquema em mente, vamos ordenar como nossos arquivos ficarão organizados para um projeto GraphQL e exemplificar para onde cada conjunto já existente será movido:</p>
<pre><code>api
    main
    |-&gt; boundaries
        |-&gt; web
        |-&gt; db
    |-&gt; resolvers
        |-&gt; graphql
            |-&gt; queries
            |-&gt; mutations
        |-&gt; internal
    |-&gt; adapters
    |-&gt; core 
        |-&gt; business
        |-&gt; compute
    |-&gt; schemas
        |-&gt; graphql
        |-&gt; model
            |-&gt; db
            |-&gt; web
        |-&gt; errors
</code></pre>
<p>Com esta definição em mente vamos alocar o projeto que contém as rotas e os handlers GraphQL em <code>boundaries/web/handlers.rs</code>, pois este aquivo é responsável pela interface web do projeto. Qualquer módulo de comunicaçnao com banco ficaria em <code>boudnaries/db/</code>, assim como de Kafka ficaria em <code>boudnaries/kafka</code> ou <code>boudnaries/messages</code>. Nosso arquivo <code>schema/mod.rs</code> possui as configurações de resolvers, assim não faz sentido que esteja em <code>schema/</code>, e moveremos ele para <code>resolvers/graphql/</code>, poderiamos separar em <code>queries</code> e <code>mutations</code>, mas como nosso projeto somente conterá 2 queries, não precisamos nos preocupar em extrair para pastas diferentes. Além disso, chamei o que tipicamente é considerado um <code>controller</code> de <code>resolver/internal</code>, por simplicidade, caso prefira chamar de controller esta adequado também. Na pasta <code>schemas</code> vamos adicionar todos os schemas de referência ao GraphQL em <code>schemas/graphql</code>, assim como os de comunicação com o banco em <code>schemas/model/db</code> e de interface web em <code>schemas/model/web</code>. Já os erros de que usaremos para comunicar problemas estarão em <code>schemas/errors</code>. Caso você fique com dúvidas de como ficou a organizacão do código, ela está disponível no commit https://github.com/web-dev-rust/airline-tickets/commit/c33a78cffbd74be49727c744623dcd1e10902cd4.</p>
<h2 id="validando-argumentos"><a class="header" href="#validando-argumentos">Validando argumentos</a></h2>
<p>Com a função que implementamos para <code>bestPrices</code> precisamos agora implementar os erros correspondentes, para isso criaremos o módulo <code>schemas/errors.rs</code> e lá implementaremos os erros Graphql. O primeiro erro que vamos implementar é o erro do formato de <code>origin</code> e <code>destination</code>, pois IATAs devem ser 3 letras. Chamaremos esse conjunto de erros de <code>InputError</code> e o erro correspondente ao IATA de <code>IataFormatError</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use juniper::{FieldError, IntoFieldError};

pub enum InputError {
    IataFormatError,
}

impl IntoFieldError for InputError {
    fn into_field_error(self) -&gt; FieldError {
        match self {
            InputError::IataFormatError =&gt; FieldError::new(
                &quot;The IATA format for origin and destinantion consists of 3 letter&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;IATA FORMAT ERROR&quot;
                }),
            ),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora para usarmos esse erro precisamos modificar a função <code>bestPrices</code> em <code>resolvers/graphql.rs</code> para usar o tipo <code>InputError</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::schema::errors::InputError;
// ...

#[juniper::object]
impl QueryRoot {
    fn ping() -&gt; FieldResult&lt;String&gt; {
        Ok(String::from(&quot;pong&quot;))
    }

    fn bestPrices(
        departure: String,
        origin: String,
        destinantion: String,
    ) -&gt; Result&lt;String, InputError&gt; {
        if origin.len() != 3 || !origin.chars().all(char::is_alphabetic) {
            return Err(InputError::IataFormatError);
        }

        Ok(String::from(&quot;test&quot;))
    }
}
//...
<span class="boring">}
</span></code></pre></pre>
<p>Se formos em  <code>localhost:4000/graphql</code> e enviarmos <code>{bestPrices(departure: &quot;IAT&quot;, origin: &quot;IATA&quot;, destinantion: &quot;sdfg&quot;)}</code> (<code>origin</code> com 4 letras) receberemos o campo <code>error</code> com o campo <code>InputError::IataFormatError</code>:</p>
<pre><code class="language-json">{
  &quot;data&quot;: null,
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;The IATA format for origin and destinantion consists of 3 letter&quot;,
      &quot;locations&quot;: [
        {
          &quot;line&quot;: 1,
          &quot;column&quot;: 2
        }
      ],
      &quot;path&quot;: [
        &quot;bestPrices&quot;
      ],
      &quot;extensions&quot;: {
        &quot;type&quot;: &quot;IATA FORMAT ERROR&quot;
      }
    }
  ]
}
</code></pre>
<p>O campo <code>destination</code> também é um IATA e precisamos aplicar a lógica <code>iata.len() != 3 || !iata.chars().all(char::is_alphabetic)</code> a ambos os campos, assim vamos criar um módulo de lógica que controlar quando esse erro deve ser lançado. O módulo será <code>core/error.rs</code>:</p>
<pre><code class="language-rs">use crate::schema::errors::InputError;

pub fn iata_format(origin: &amp;str, destination: &amp;str) -&gt; Result&lt;(), InputError&gt; {
    if origin.len() != 3
        || !origin.chars().all(char::is_alphabetic)
        || destination.len() != 3
        || !destination.chars().all(char::is_alphabetic)
    {
        Err(InputError::IataFormatError)
    } else {
        Ok(())
    }
}
</code></pre>
<p>Os testes para esta função são:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod iata {
    use super::iata_format;
    use crate::schema::errors::InputError;

    #[test]
    fn len_should_be_3() {
        assert_eq!(
            iata_format(&quot;IATA&quot;, &quot;IAT&quot;).err().unwrap(),
            InputError::IataFormatError
        );

        assert_eq!(
            iata_format(&quot;IAT&quot;, &quot;IATA&quot;).err().unwrap(),
            InputError::IataFormatError
        );
    }

    #[test]
    fn only_letters() {
        assert_eq!(
            iata_format(&quot;IAT&quot;, &quot;I4T&quot;).err().unwrap(),
            InputError::IataFormatError
        );

        assert_eq!(
            iata_format(&quot;I&amp;T&quot;, &quot;IAT&quot;).err().unwrap(),
            InputError::IataFormatError
        );
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Nesta função validamos que o formato IATA é respeitado tanto para <code>origin</code> quanto para <code>destination</code>, somente 3 letras. Caso alguma das verificaçnoes falhe, lançamos o erro <code>InputError::IataFormatError</code>. Depois disso, aplicamos a função <code>iata_format</code> em nosso resolver através de um match, que retorna o erro ou executa alguma função interna:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::core::error;
// ...
#[juniper::object]
impl QueryRoot {
    fn bestPrices(
        departure: String,
        origin: String,
        destination: String,
    ) -&gt; Result&lt;String, InputError&gt; {
        match error::iata_format(&amp;origin, &amp;destination) {
            Err(e) =&gt; Err(e),
            Ok(_) =&gt; Ok(String::from(&quot;test&quot;)),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Próximo passo é determinar se <code>departure</code> é uma data e seu valor é superior ao dia de hoje.</p>
<h3 id="validando-datas"><a class="header" href="#validando-datas">Validando datas</a></h3>
<p>Para trabalharmos com datas precisamos incluir a crate <code>chrono = &quot;0.4.11&quot;</code> no campo <code>[dependencies]</code> do Cargo.toml. A primeira coisa que vamos verificar é se o formato da data está correto. Podemos fazer isso com a seguinte função:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::naive::NaiveDate;
// ...
pub fn departure_date_format(date: &amp;str) -&gt; Result&lt;(), InputError&gt; {
    let departure = NaiveDate::parse_from_str(date, &quot;%Y-%m-%d&quot;);
    match departure {
        Err(_) =&gt; Err(InputError::DateFormatError),
        Ok(d) =&gt; Ok(()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com <code>parse_from_str</code> verificamos se o formato da string <code>departure</code> esta correto de acordo com o formatador que passamos <code>&quot;%Y-%m-%d&quot;</code>. <code>parse_from_str</code> nos retorna um <code>Result</code> que podemos utilizar para compor o erro. Precisamos incluir um novo caso de erro, <code>DateFormatError</code> em <code>InputError</code> e adicionar sua cláusula no <code>macth</code>. Assim, validamos isso com os testes a seguir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod date {
    use super::departure_date_format;
    use crate::schema::errors::InputError;

    #[test]
    fn date_is_correct() {
        assert!(departure_date_format(&quot;3020-01-20&quot;).is_ok());
    }

    #[test]
    fn date_should_be_yyyy_mm_dd() {
        assert_eq!(
            departure_date_format(&quot;2020/01/20&quot;).err().unwrap(),
            InputError::DateFormatError
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Próximo passo é verificar se a data de departure data é maior que a data de hoje, para isso podemos utilizar a função <code>signed_duration_since</code> que nos retorna uma <code>Duration</code> desde a data passada como argumento (<code>today</code>). Podemos comparar essa data extraindo o número de dias com <code>num_days</code> e verificar se é maior que <code>0</code>. Novamente precisamos adicionar um nove erro <code>InvalidDateError</code> em <code>InputError</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{naive::NaiveDate, offset::Utc};
// ...

pub fn departure_date_format(date: &amp;str) -&gt; Result&lt;(), InputError&gt; {
    let departure = NaiveDate::parse_from_str(date, &quot;%Y-%m-%d&quot;);
    match departure {
        Err(_) =&gt; Err(InputError::DateFormatError),
        Ok(d) =&gt; {
            let today = Utc::today();
            if d.signed_duration_since(today.naive_utc()).num_days() &gt; 0 {
                Ok(())
            } else {
                Err(InputError::InvalidDateError)
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E o teste para esse novo caso pode ser:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn date_should_be_greater_than_today() {
    assert_eq!(
        departure_date_format(&quot;2019-01-20&quot;).err().unwrap(),
        InputError::InvalidDateError
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>O módulo <code>schema/error.rs</code> fica da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use juniper::{FieldError, IntoFieldError};

#[derive(Debug, Clone, PartialEq)]
pub enum InputError {
    IataFormatError,
    DateFormatError,
    InvalidDateError,
}

impl IntoFieldError for InputError {
    fn into_field_error(self) -&gt; FieldError {
        match self {
            InputError::IataFormatError =&gt; FieldError::new(
                &quot;The IATA format for origin and destinantion consists of 3 letter&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;IATA FORMAT ERROR&quot;
                }),
            ),
            InputError::DateFormatError =&gt; FieldError::new(
                &quot;departure date should be formated yyyy-mm-dd&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;DATE FORMAT ERROR&quot;
                }),
            ),
            InputError::InvalidDateError =&gt; FieldError::new(
                &quot;Date should be greater than today&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;INVALID DATE ERROR&quot;
                }),
            ),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos adicionar este novo grupo de erros ao nosso resolver com:</p>
<pre><code class="language-rs">fn bestPrices(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;String, InputError&gt; {
    match (
        error::iata_format(&amp;origin, &amp;destination),
        error::departure_date_format(&amp;departure),
    ) {
        (Err(e), Err(e2)) =&gt; Err(e),
        (Err(e), _) =&gt; Err(e),
        (_, Err(e)) =&gt; Err(e),
        _ =&gt; Ok(String::from(&quot;test&quot;)),
    }
}
</code></pre>
<p>Próximo passo é responder as informações de <code>bestPrices</code> em vez de <code>Ok(String::from(&quot;test&quot;))</code>.</p>
<h2 id="respondendo-informacões-de-bestprices"><a class="header" href="#respondendo-informacões-de-bestprices">Respondendo informacões de <code>bestPrices</code></a></h2>
<p>Para este caso devemos utilizar um cliente HTTP, que usualmente são assíncronos em Rust, porém a crate que estamos utilizando para GraphQL ainda não tem um suporte muito sólido para <code>async/await</code>, e por isso preferi utilizar a crate de cliente HTTP <code>reqwest</code> com o módulo <code>reqwest::blocking</code>, mesmo que actix possua seu próprio módulo de cliente <code>actix_web::client</code>.</p>
<blockquote>
<p>Exemplo de client com <code>actix_web::client</code></p>
<pre><pre class="playground"><code class="language-rust">use actix_web::client::Client;

#[actix_rt::main]
async fn main() {
  let mut client = Client::default();

  // Cria `request builder` e envia com `send`
  let response = client.get(&quot;http://www.rust-lang.org&quot;)
     .header(&quot;User-Agent&quot;, &quot;Actix-web&quot;)
     .send().await;  // &lt;-Envia o request

  println!(&quot;Response: {:?}&quot;, response);
}
</code></pre></pre>
</blockquote>
<h3 id="conhecendo-o-endpoint"><a class="header" href="#conhecendo-o-endpoint">Conhecendo o endpoint</a></h3>
<p>Consultando o endpoint de <code>best_prices</code> para data <code>&quot;2020-07-21&quot;</code>, para origem <code>POA</code> e para destino <code>GRU</code> https://bff.latam.com/ws/proxy/booking-webapp-bff/v1/public/revenue/bestprices/oneway?departure={data}&amp;origin={iata}&amp;destination={iata}&amp;cabin=Y&amp;country=BR&amp;language=PT&amp;home=pt_br&amp;adult=1&amp;promoCode= recebemos o seguinte campos relevantes no Json:</p>
<pre><code class="language-json">{
    &quot;itinerary&quot;:{
       &quot;date&quot;:&quot;2020-07-21&quot;,
       &quot;originDestinations&quot;:[
          {
             &quot;duration&quot;:95,
             &quot;departure&quot;:{
                &quot;airport&quot;:&quot;POA&quot;,
                &quot;city&quot;:&quot;POA&quot;,
                &quot;country&quot;:&quot;BR&quot;,
                &quot;timestamp&quot;:&quot;2020-07-21T11:10-03:00&quot;
             },
             &quot;arrival&quot;:{
                &quot;airport&quot;:&quot;GRU&quot;,
                &quot;city&quot;:&quot;SAO&quot;,
                &quot;country&quot;:&quot;BR&quot;,
                &quot;timestamp&quot;:&quot;2020-07-21T12:45-03:00&quot;
             }
          }
       ]
    },
    &quot;bestPrices&quot;:[
       {
          &quot;date&quot;:&quot;2020-07-18&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
             &quot;amount&quot;:117.03, &quot;currency&quot;:&quot;BRL&quot;
          }
       },
       {
          &quot;date&quot;:&quot;2020-07-19&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
             &quot;amount&quot;:117.03, &quot;currency&quot;:&quot;BRL&quot;
          }
       },
       {
          &quot;date&quot;:&quot;2020-07-20&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
             &quot;amount&quot;:117.03, &quot;currency&quot;:&quot;BRL&quot;
          }
       },
       {
          &quot;date&quot;:&quot;2020-07-21&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
             &quot;amount&quot;:117.03, &quot;currency&quot;:&quot;BRL&quot;
          }
       },
       {
          &quot;date&quot;:&quot;2020-07-22&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
             &quot;amount&quot;:117.03, &quot;currency&quot;:&quot;BRL&quot;
          }
       },
       {
          &quot;date&quot;:&quot;2020-07-23&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
             &quot;amount&quot;:117.03, &quot;currency&quot;:&quot;BRL&quot;
          }
       },
       {
          &quot;date&quot;:&quot;2020-07-24&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
             &quot;amount&quot;:117.03, &quot;currency&quot;:&quot;BRL&quot;
          }
       }
    ]
 }
</code></pre>
<p>Com isso, precisamos modelar a resposta de cada campo para uma estrutura de dados correspondete localizadas em <code>schema/model/web.rs</code>, chamaremos esta estrutura de <code>BestPrices</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use juniper::GraphQLObject;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct BestPrices {
    itinerary: Itinerary,
    best_prices: Vec&lt;BestPrice&gt;,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Itinerary {
    date: String,
    origin_destinations: Vec&lt;OriginDestination&gt;,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
pub struct OriginDestination {
    duration: i32,
    departure: AirportInfo,
    arrival: AirportInfo,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
pub struct AirportInfo {
    airport: String,
    city: String,
    country: String,
    timestamp: String,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
pub struct BestPrice {
    date: String,
    available: bool,
    price: Option&lt;Price&gt;,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
pub struct Price {
    amount: f64,
    currency: String,
}
}
<span class="boring">}
</span></code></pre></pre>
<p>Para podermos converter o json em uma estrutura de dados Rust vamos precisar utilizar a crate <code>serde</code> e adicionar <code>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]</code> em todas as struct anteriores. Além disso, utilizaremos <code>#[serde(rename_all = &quot;camelCase&quot;)]</code> para transformar campos <code>snake_case</code> em <code>camelCase</code>, como <code>origin_destinations</code>, e a macro <code>GraphQLObject</code> para indicar que estas structs correspondem a um objeto GraphQL. Agora podemos fazer um request para este endpoint, para isso vamos criar o módulo <code>boundaries/http_out</code> e utilizar o <code>reqwest</code> para fazer um <code>GET</code> no endpoint:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::{blocking::Response, Result};

pub fn best_prices(departure: String, origin: String, destination: String) -&gt; Result&lt;Response&gt; {
    let url =
        format!(&quot;https://bff.latam.com/ws/proxy/booking-webapp-bff/v1/public/revenue/bestprices/oneway?departure={}&amp;origin={}&amp;destination={}&amp;cabin=Y&amp;country=BR&amp;language=PT&amp;home=pt_br&amp;adult=1&amp;promoCode=&quot;, departure, origin, destination);
    reqwest::blocking::get(&amp;url)
}
<span class="boring">}
</span></code></pre></pre>
<p>A função <code>best_prices</code> formata a <code>url</code> do request adicionando os parâmetros <code>departure, origin, destination</code> para utilizar a função bloqueante <code>get</code> de <code>reqwest</code>, <code>reqwest::blocking::get(&amp;url)</code>. O tipo de retorno é um <code>Result&lt;Response&gt;</code> da própria crate <code>reqwest</code>.</p>
<h3 id="resolvendo-bestprices"><a class="header" href="#resolvendo-bestprices">Resolvendo <code>BestPrices</code></a></h3>
<p>Com a função <code>boundaries::http_out::best_prices</code> fazendo o request, precisamos transformar o resultado desse request em uma estrutura de dados do tipo <code>BestPrices</code> que serializa e implementa <code>GraphQLObject</code>. Para coordenarmos isso, criamos um módulo <code>resolvers/internal</code> que vai implementar a função <code>best_prices_info</code>: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::boundaries::http_out::best_prices;
use crate::schema::{errors::InputError, model::web::BestPrices};

pub fn best_prices_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;BestPrices, InputError&gt; {
    let best_prices_text = best_prices(departure, origin, destination)
        .unwrap()
        .text()
        .unwrap();

    let best_prices: BestPrices = serde_json::from_str(&amp;best_prices_text).unwrap();

    Ok(best_prices)
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que o resultado da função <code>boundaries::http_out::best_prices</code> é um <code>reqwest::Result&lt;reqwest::blocking::response&gt;</code>, e que para utilizarmos seus dados precisamos tratar como um <code>Result</code> usual, por isso aplicamos <code>unwrap</code>. Além disso, queremos a informação presente no <code>body</code> da resposta, que obtemos como texto utilizando a função <code>text</code>, que retorna um <code>Result</code>, definimos o resultado deste processo como <code>best_prices_text</code>. Com <code>best_prices_text</code> podemos transformar esse texto em uma estrutura <code>BestPrices</code> utilizando a função <code>serde_json::from_str</code>, como em <code>let best_prices: BestPrices = serde_json::from_str(&amp;best_prices_text).unwrap();</code> e retornar essa infomacão em um <code>Ok</code>. O código ainda possui alguns defeitos como a grande quantidade de <code>unwraps</code> e um <code>InputError</code> totalmente deslocado, logo veremos como melhorar o código neste sentido. <code>best_prices_info</code> ainda não está conectado a nenhuma parte do código GraphQL, assim, precisamos chamar esta função no resolver GraphQL <code>best_prices</code> e mudar seu tipo de resposta para utilizar <code>schema::model::web::BestPrices</code>, <code>Result&lt;BestPrices, InputError</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::core::error;
use crate::resolvers::internal::best_prices_info;
use crate::schema::{errors::InputError, model::web::BestPrices};
use juniper::FieldResult;
use juniper::RootNode;

pub struct QueryRoot;

#[juniper::object]
impl QueryRoot {
    fn ping() -&gt; FieldResult&lt;String&gt; {
        Ok(String::from(&quot;pong&quot;))
    }

    fn bestPrices(
        departure: String,
        origin: String,
        destination: String,
    ) -&gt; Result&lt;BestPrices, InputError&gt; {
        match (
            error::iata_format(&amp;origin, &amp;destination),
            error::departure_date_format(&amp;departure),
        ) {
            (Err(e), Err(e2)) =&gt; Err(e),
            (Err(e), _) =&gt; Err(e),
            (_, Err(e)) =&gt; Err(e),
            _ =&gt; best_prices_info(departure, origin, destination),
        }
    }
}
// ...
<span class="boring">}
</span></code></pre></pre>
<h2 id="melhorando-as-mensagens-de-erro"><a class="header" href="#melhorando-as-mensagens-de-erro">Melhorando as mensagens de erro.</a></h2>
<p>O conceito de <code>Input Error</code> é particularmente estranho para erros de conversão de Json com <code>serde</code> ou de request com <code>reqwest</code>, assim, uma possível solução é fazer um <strong>&quot;super grupo&quot;</strong> de erros, que vou chamar de <code>GenericError</code>, e esse vai possuír um <code>enum</code> chamado <code>InternalError</code>:</p>
<pre><code class="language-Rust">#[derive(Debug, Clone, PartialEq)]
pub enum GenericError {
    InputError(InputError),
    InternalError(InternalError),
}

#[derive(Debug, Clone, PartialEq)]
pub enum InputError {
    IataFormatError,
    DateFormatError,
    InvalidDateError,
}

#[derive(Debug, Clone, PartialEq)]
pub enum InternalError {
    RequestFailedError,
    ResponseParseError,
}
</code></pre>
<p>A próxima mudança que podemos fazer é alterar todos os <code>Result&lt;BestPrices, InputError&gt;</code> para <code>Result&lt;BestPrices, GenericError&gt;</code>, o que causa uma grande quantidade de alarmes em nosso código, mas em vez de arrumarmos cada um dos alarmes e termos mais dor de cabeça, vamos implementar a trait <code>From</code> para dois erros do tipo <code>GenericError::InternalError</code>, <code>reqwest::Error</code> e <code>serde_json::Error</code>, pois estes são os erros que queremos lançar na função <code>esolvers::internal::best_prices_info;</code>. O primeiro erro, <code>reqwest::Error</code>, tem como objetivo retirar o <code>unwrap</code> e o <code>expect</code> da chamada <code>best_prices(departure, origin, destination).unwrap().text().expect(...);</code>, obtendo como resultado <code>best_prices(departure, origin, destination)?.text()?;</code>, que nos ajuda a aproveitar o tipo de retorno <code>GenericError</code>. O mesmo faremos para transformar a chamada de <code>serde_json::from_str(&amp;best_prices_text).unwrap();</code> em <code>serde_json::from_str(&amp;best_prices_text)?;</code> aplicando a trait <code>From</code> no tipo de erro <code>serde_json::Error</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;reqwest::Error&gt; for GenericError {
    fn from(e: reqwest::Error) -&gt; Self {
        GenericError::InternalError(InternalError::RequestFailedError)
    }
}

impl From&lt;serde_json::Error&gt; for GenericError {
    fn from(e: serde_json::Error) -&gt; Self {
        GenericError::InternalError(InternalError::ResponseParseError)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>O efeito disso é que o arquivo <code>resolver/internal.rs</code> se torna muito mais simples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::boundaries::http_out::best_prices;
use crate::schema::{errors::GenericError, model::web::BestPrices};

pub fn best_prices_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;BestPrices, GenericError&gt; {
    let best_prices_text = best_prices(departure, origin, destination)?.text()?;
    let best_prices: BestPrices = serde_json::from_str(&amp;best_prices_text)?;

    Ok(best_prices)
}
<span class="boring">}
</span></code></pre></pre>
<p>Com isso, podemos notar que a vida da query <code>bestPrices</code> ficou muito mais simples, pois o <code>match</code> se torna desnecessário, já que as funções <code>error::iata_format</code>e <code>error::departure_date_format</code> retornam um tipo <code>Result&lt;(),InputError&gt;</code>, que é facilmente convertido para um <code>Result&lt;(),GenericError&gt;</code>, nos permitindo utilizar a sintaxe <code>try</code> para elas na query <code>bestPrices</code>, <code>error::iata_format(&amp;origin, &amp;destination)?;</code> e <code>error::departure_date_format(&amp;departure)?;</code>. O arquivo <code>core/error.rs</code> passa a ter a seguinte aparência:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::schema::errors::{GenericError, InputError};
use chrono::{naive::NaiveDate, offset::Utc};

pub fn iata_format(origin: &amp;str, destination: &amp;str) -&gt; Result&lt;(), GenericError&gt; {
    if origin.len() != 3
        || !origin.chars().all(char::is_alphabetic)
        || destination.len() != 3
        || !destination.chars().all(char::is_alphabetic)
    {
        Err(GenericError::InputError(InputError::IataFormatError))
    } else {
        Ok(())
    }
}

pub fn departure_date_format(date: &amp;str) -&gt; Result&lt;(), GenericError&gt; {
    let departure = NaiveDate::parse_from_str(date, &quot;%Y-%m-%d&quot;);
    match departure {
        Err(_) =&gt; Err(GenericError::InputError(InputError::DateFormatError)),
        Ok(d) =&gt; {
            let today = Utc::today();
            if d.signed_duration_since(today.naive_utc()).num_days() &gt; 0 {
                Ok(())
            } else {
                Err(GenericError::InputError(InputError::InvalidDateError))
            }
        }
    }
}

#[cfg(test)]
mod date {
    use super::departure_date_format;
    use crate::schema::errors::{InputError, GenericError};

    #[test]
    fn date_is_correct() {
        assert!(departure_date_format(&quot;3020-01-20&quot;).is_ok());
    }

    #[test]
    fn date_should_be_yyyy_mm_dd() {
        assert_eq!(
            departure_date_format(&quot;2020/01/20&quot;).err().unwrap(),
            GenericError::InputError(InputError::DateFormatError)
        );
    }

    #[test]
    fn date_should_be_greater_than_today() {
        assert_eq!(
            departure_date_format(&quot;2019-01-20&quot;).err().unwrap(),
            GenericError::InputError(InputError::InvalidDateError)
        );
    }
}

#[cfg(test)]
mod iata {
    use super::iata_format;
    use crate::schema::errors::{InputError, GenericError};

    #[test]
    fn len_should_be_3() {
        assert_eq!(
            iata_format(&quot;IATA&quot;, &quot;IAT&quot;).err().unwrap(),
            GenericError::InputError(InputError::IataFormatError)
        );

        assert_eq!(
            iata_format(&quot;IAT&quot;, &quot;IATA&quot;).err().unwrap(),
            GenericError::InputError(InputError::IataFormatError)
        );
    }

    #[test]
    fn only_letters() {
        assert_eq!(
            iata_format(&quot;IAT&quot;, &quot;I4T&quot;).err().unwrap(),
            GenericError::InputError(InputError::IataFormatError)
        );

        assert_eq!(
            iata_format(&quot;I&amp;T&quot;, &quot;IAT&quot;).err().unwrap(),
            GenericError::InputError(InputError::IataFormatError)
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Todas essas mudanças nos permitem ainda simplificar a query <code>bestPrices</code> para utilizar os operadores <code>try</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[juniper::object]
impl QueryRoot {
    fn ping() -&gt; FieldResult&lt;String&gt; {
        Ok(String::from(&quot;pong&quot;))
    }

    fn bestPrices(
        departure: String,
        origin: String,
        destination: String,
    ) -&gt; Result&lt;BestPrices, GenericError&gt; {
        error::iata_format(&amp;origin, &amp;destination)?;
        error::departure_date_format(&amp;departure)?;
        let best_price = best_prices_info(departure, origin, destination)?;
        Ok(best_price)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ainda há um problema envolvendo a trait <code>IntoFieldError</code> que não está implementada para o enum <code>GenericError</code>. Fazemos isso refatorando a implementação da trait para o enum <code>InputError</code>, reaproveitando todos seus campos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoFieldError for GenericError {
    fn into_field_error(self) -&gt; FieldError {
        match self {
            GenericError::InputError(InputError::IataFormatError) =&gt; FieldError::new(
                &quot;The IATA format for origin and destinantion consists of 3 letter&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;IATA FORMAT ERROR&quot;
                }),
            ),
            GenericError::InputError(InputError::DateFormatError) =&gt; FieldError::new(
                &quot;departure date should be formated yyyy-mm-dd&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;DATE FORMAT ERROR&quot;
                }),
            ),
            GenericError::InputError(InputError::InvalidDateError) =&gt; FieldError::new(
                &quot;Date should be greater than today&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;INVALID DATE ERROR&quot;
                }),
            ),
            GenericError::InternalError(InternalError::RequestFailedError) =&gt; FieldError::new(
                &quot;Could not complete properly request to the backend&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;REQUEST FAILED ERROR&quot;
                }),
            ),
            GenericError::InternalError(InternalError::ResponseParseError) =&gt; FieldError::new(
                &quot;Could not parse response from backend&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;RESPONSE PARSE ERROR&quot;
                }),
            ),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora que evoluímos os erros da nossa API, podemos fazer a query de recommendations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h1>
<p>Nesta query, <code>recommendations</code>, vamos fazer uma consulta a mesma API anterior, mas em um endpoint diferente. Esse endpoint retorna todas as opções de voo para uma rota (data, origem e destino). Consultaremos a URL de <code>recommendations</code> da Latam <code>https://bff.latam.com/ws/proxy/booking-webapp-bff/v1/public/revenue/recommendations/oneway?departure=&lt;YYYY-mm-dd&gt;&amp;origin=&lt;IATA&gt;&amp;destination=&lt;IATA&gt;&amp;cabin=Y&amp;country=BR&amp;language=PT&amp;home=pt_br&amp;adult=1&amp;promoCode=</code>, na qual <code>departure</code> é a data de partida no formato <code>ano-mes-dia</code>, <code>origin</code> é o código IATA da cidade ou do aeroporto de origem, <code>destination</code> é o código IATA da cidade ou do aeroporto de destino. Assim, nossa query deve receber 3 argumentos <code>departure</code>, <code>origin</code> e <code>destination</code> e retornar uma lista de todas as opções de vôo, além de lançar erros. Assim como a query <code>bestPrices</code>, nossa query de <code>recommendations</code> vai receber os mesmos parâmetros:</p>
<p><strong>BestPrices</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bestPrices(
    departure: String,
    origin: String,
    destination: String,
) 
<span class="boring">}
</span></code></pre></pre>
<p><strong>Recommendations</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recommendations(
    departure: String,
    origin: String,
    destination: String,
) 
<span class="boring">}
</span></code></pre></pre>
<p>O tipo de retorno de <code>recommendations</code> será semelhante ao tipo de <code>bestPrices</code>, <code>Result&lt;Recommendations, GenericError&gt;</code>. As validações dos tipos de entrada podem continuar iguais:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[juniper::object]
impl QueryRoot {
    fn ping() -&gt; FieldResult&lt;String&gt; {
        Ok(String::from(&quot;pong&quot;))
    }

    fn bestPrices(
        departure: String,
        origin: String,
        destination: String,
    ) -&gt; Result&lt;BestPrices, GenericError&gt; {
        error::iata_format(&amp;origin, &amp;destination)?;
        error::departure_date_format(&amp;departure)?;
        let best_price = best_prices_info(departure, origin, destination)?;
        Ok(best_price)
    }

    fn recommendations(
        departure: String,
        origin: String,
        destination: String,
    ) -&gt; Result&lt;Recommendations, GenericError&gt; {
        error::iata_format(&amp;origin, &amp;destination)?;
        error::departure_date_format(&amp;departure)?;
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos começar a implementar o resolver <code>recommendations_info</code>, começando por conehcer o endpoint.</p>
<h2 id="conhecendo-o-endpoint-de-recommendations"><a class="header" href="#conhecendo-o-endpoint-de-recommendations">Conhecendo o endpoint de <code>recommendations</code></a></h2>
<p>Consultando o endpoint de <code>recommendations</code> para data <code>&quot;2020-07-21&quot;</code>, para origem <code>POA</code> e para destino <code>GRU</code> https://bff.latam.com/ws/proxy/booking-webapp-bff/v1/public/revenue/recommendations/oneway?departure={data}&amp;origin={iata}&amp;destination={iata}&amp;cabin=Y&amp;country=BR&amp;language=PT&amp;home=pt_br&amp;adult=1&amp;promoCode= recebemos o seguinte campos relevantes no Json (muitos campos foram ocultos pois não vamos utilizar):</p>
<pre><code class="language-json">{
  &quot;data&quot;:[
    {
      &quot;flights&quot;:[
        {
          &quot;flightCode&quot;:&quot;LA4596&quot;,
          &quot;arrival&quot;:{
            &quot;airportCode&quot;:&quot;GRU&quot;,
            &quot;airportName&quot;:&quot;Guarulhos Intl.&quot;,
            &quot;cityCode&quot;:&quot;SAO&quot;,
            &quot;cityName&quot;:&quot;São Paulo&quot;,
            &quot;countryCode&quot;:&quot;BR&quot;,
            &quot;date&quot;:&quot;2020-07-21&quot;,
            &quot;dateTime&quot;:&quot;2020-07-21T10:50-03:00&quot;,
            &quot;overnights&quot;:0,
            &quot;time&quot;:{ &quot;stamp&quot;:&quot;10:50&quot;, &quot;hours&quot;:&quot;10&quot;, &quot;minutes&quot;:&quot;50&quot; }
          },
          &quot;departure&quot;:{
            &quot;airportCode&quot;:&quot;POA&quot;,
            &quot;airportName&quot;:&quot;Salgado Filho&quot;,
            &quot;cityCode&quot;:&quot;POA&quot;,
            &quot;cityName&quot;:&quot;Porto Alegre&quot;,
            &quot;countryCode&quot;:&quot;BR&quot;,
            &quot;date&quot;:&quot;2020-07-21&quot;,
            &quot;dateTime&quot;:&quot;2020-07-21T09:15-03:00&quot;,
            &quot;overnights&quot;:null,
            &quot;time&quot;:{ &quot;stamp&quot;:&quot;09:15&quot;, &quot;hours&quot;:&quot;09&quot;, &quot;minutes&quot;:&quot;15&quot; }
          },
          &quot;stops&quot;:0,
          &quot;segments&quot;:[
            {
              &quot;flightCode&quot;:&quot;LA4596&quot;,
              &quot;flightNumber&quot;:&quot;4596&quot;,
              &quot;waitTime&quot;:null,
              &quot;equipment&quot;:{ &quot;name&quot;:&quot;Airbus 321&quot;, &quot;code&quot;:&quot;321&quot; },
              &quot;legs&quot;:[

              ],
              &quot;airline&quot;:{
                &quot;marketing&quot;:{ &quot;code&quot;:&quot;LA&quot;, &quot;name&quot;:&quot;LATAM Airlines&quot; },
                &quot;operating&quot;:{
                  &quot;code&quot;:&quot;JJ&quot;,
                  &quot;name&quot;:&quot;LATAM Airlines Brasil&quot;
                },
                &quot;code&quot;:&quot;LA&quot;
              },
              &quot;duration&quot;:&quot;PT1H35M&quot;,
              &quot;departure&quot;:{
                &quot;airportCode&quot;:&quot;POA&quot;,
                &quot;airportName&quot;:&quot;Salgado Filho&quot;,
                &quot;cityCode&quot;:&quot;POA&quot;,
                &quot;cityName&quot;:&quot;Porto Alegre&quot;,
                &quot;countryCode&quot;:&quot;BR&quot;,
                &quot;date&quot;:&quot;2020-07-21&quot;,
                &quot;dateTime&quot;:&quot;2020-07-21T09:15-03:00&quot;,
                &quot;overnights&quot;:null,
                &quot;time&quot;:{ &quot;stamp&quot;:&quot;09:15&quot;, &quot;hours&quot;:&quot;09&quot;, &quot;minutes&quot;:&quot;15&quot; }
              },
              &quot;arrival&quot;:{
                &quot;airportCode&quot;:&quot;GRU&quot;,
                &quot;airportName&quot;:&quot;Guarulhos Intl.&quot;,
                &quot;cityCode&quot;:&quot;SAO&quot;,
                &quot;cityName&quot;:&quot;São Paulo&quot;,
                &quot;countryCode&quot;:&quot;BR&quot;,
                &quot;date&quot;:&quot;2020-07-21&quot;,
                &quot;dateTime&quot;:&quot;2020-07-21T10:50-03:00&quot;,
                &quot;overnights&quot;:0,
                &quot;time&quot;:{ &quot;stamp&quot;:&quot;10:50&quot;, &quot;hours&quot;:&quot;10&quot;, &quot;minutes&quot;:&quot;50&quot;
                }
              },
              &quot;familiesMap&quot;:{
                &quot;Y-LIGHT&quot;:{
                  &quot;segmentClass&quot;:&quot;G&quot;,
                  &quot;farebasis&quot;:&quot;GLYX0N1&quot;
                },
                &quot;Y-PLUS&quot;:{
                  &quot;segmentClass&quot;:&quot;G&quot;,
                  &quot;farebasis&quot;:&quot;GLYX0N8&quot;
                },
                &quot;Y-TOP&quot;:{
                  &quot;segmentClass&quot;:&quot;G&quot;,
                  &quot;farebasis&quot;:&quot;GLYX0N9&quot;
                },
                &quot;W-PLUS&quot;:{
                  &quot;segmentClass&quot;:&quot;P&quot;,
                  &quot;farebasis&quot;:&quot;GDKX0N2&quot;
                },
                &quot;W-TOP&quot;:{
                  &quot;segmentClass&quot;:&quot;W&quot;,
                  &quot;farebasis&quot;:&quot;XJ7X0NA&quot;
                }
              }
            }
          ],
          &quot;flightDuration&quot;:&quot;PT1H35M&quot;,
          &quot;cabins&quot;:[
            {
              &quot;code&quot;:&quot;Y&quot;,
              &quot;displayPrice&quot;:101.03,
              &quot;availabilityCount&quot;:18,
              &quot;displayPrices&quot;:{
                &quot;slice&quot;:101.03,
                &quot;wholeTrip&quot;:101.03,
                &quot;sliceDiscountCode&quot;:&quot;&quot;,
                &quot;wholeTripDiscountCode&quot;:&quot;&quot;
              },
              &quot;fares&quot;:[
                {
                  &quot;code&quot;:&quot;SL&quot;,
                  &quot;category&quot;:&quot;LIGHT&quot;,
                  &quot;fareId&quot;:&quot;250/BdC0XLNrp3H333zqIqmJJpNOO/05D8NwB5zcjHVNnkyl4GjqR/YOQrcDNWLPERAtEBLYqieN002&quot;,
                  &quot;price&quot;:{
                    &quot;adult&quot;:{
                      &quot;amountWithoutTax&quot;:68.9,
                      &quot;taxAndFees&quot;:32.13,
                      &quot;total&quot;:101.03
                    }
                  },
                  &quot;availabilityCount&quot;:18,
                },
                {
                  &quot;code&quot;:&quot;SE&quot;,
                  &quot;category&quot;:&quot;PLUS&quot;,
                  &quot;fareId&quot;:&quot;250/BdC0XLNrp3H333zqIqmJJpNOO/05D8NwB5zcjHVNnkyl4GjqR/YOQrcDNWLPERAtEBLYqieN009&quot;,
                  &quot;price&quot;:{
                    &quot;adult&quot;:{
                      &quot;amountWithoutTax&quot;:123.9,
                      &quot;taxAndFees&quot;:32.13,
                      &quot;total&quot;:156.03
                    }
                  },
                  &quot;availabilityCount&quot;:18
                },
                {
                  &quot;code&quot;:&quot;SF&quot;,
                  &quot;category&quot;:&quot;TOP&quot;,
                  &quot;fareId&quot;:&quot;250/BdC0XLNrp3H333zqIqmJJpNOO/05D8NwB5zcjHVNnkyl4GjqR/YOQrcDNWLPERAtEBLYqieN00C&quot;,
                  &quot;price&quot;:{
                    &quot;adult&quot;:{
                      &quot;amountWithoutTax&quot;:193.9,
                      &quot;taxAndFees&quot;:32.13,
                      &quot;total&quot;:226.03
                    }
                  },
                  &quot;availabilityCount&quot;:18
                }
              ]
            },
            {
              &quot;code&quot;:&quot;W&quot;,
              &quot;displayPrice&quot;:247.03,
              &quot;availabilityCount&quot;:9,
              &quot;displayPrices&quot;:{
                &quot;slice&quot;:247.03,
                &quot;wholeTrip&quot;:247.03,
                &quot;sliceDiscountCode&quot;:&quot;&quot;,
                &quot;wholeTripDiscountCode&quot;:&quot;&quot;
              },
              &quot;fares&quot;:[
                {
                  &quot;code&quot;:&quot;RA&quot;,
                  &quot;category&quot;:&quot;PLUS&quot;,
                  &quot;fareId&quot;:&quot;250/BdC0XLNrp3H333zqIqmJJpNOO/05D8NwB5zcjHVNnkyl4GjqR/YOQrcDNWLPERAtEBLYqieN00F&quot;,
                  &quot;price&quot;:{
                    &quot;adult&quot;:{
                      &quot;amountWithoutTax&quot;:214.9,
                      &quot;taxAndFees&quot;:32.13,
                      &quot;total&quot;:247.03
                    }
                  },
                  &quot;availabilityCount&quot;:9,
                },
                {
                  &quot;code&quot;:&quot;RY&quot;,
                  &quot;category&quot;:&quot;TOP&quot;,
                  &quot;fareId&quot;:&quot;250/BdC0XLNrp3H333zqIqmJJpNOO/05D8NwB5zcjHVNnkyl4GjqR/YOQrcDNWLPERAtEBLYqieN00K&quot;,
                  &quot;price&quot;:{
                    &quot;adult&quot;:{
                      &quot;amountWithoutTax&quot;:673.9,
                      &quot;taxAndFees&quot;:32.13,
                      &quot;total&quot;:706.03
                    }
                  },
                  &quot;availabilityCount&quot;:12,
                }
              ]
            }
          ]
        },
        ...Mais recomendações aqui
      ],
      &quot;currency&quot;:&quot;BRL&quot;,
      &quot;recommendedFlightCode&quot;:&quot;LA4596&quot;
    }
  ],
  &quot;status&quot;:{
    &quot;code&quot;:200,
    &quot;message&quot;:&quot;&quot;
  }
}
</code></pre>
<p>Com esse Json podemos começar a modelar a resposta de recommendations, conforme fizemos com <code>BestPrices</code>.</p>
<h3 id="modelando-recommendations"><a class="header" href="#modelando-recommendations">Modelando <code>Recommendations</code></a></h3>
<p>Para modelar recomendarions precisamos fazer uma pequena refatoração em <code>BestPrices</code>, para evitarmos a que <code>Recommendations</code> e <code>BestPrices</code> fiquem misturados no mesmo módulo. Podemos criar um novo arquivo para cada um dos módulos, como temos feito, ou criar módulos internos dentro de <code>schema/model/web.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod best_prices {
    use juniper::GraphQLObject;
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
    #[serde(rename_all = &quot;camelCase&quot;)]
    pub struct BestPrices {
        itinerary: Itinerary,
        best_prices: Vec&lt;BestPrice&gt;,
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos criar o módulo <code>recommendations</code> com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod recommendations {
    use juniper::GraphQLObject;
    use serde::{Deserialize, Serialize};
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Nossa estrutura de <code>Recommendations</code> contém 2 campos principais <code>data</code> e <code>status</code>. <code>status</code> é uma struct com os campos <code>code</code> do tipo <code>i32</code> e <code>message</code> do tipo <code>String</code>. Já <code>data</code> é um vetor de uma struct que contrém os campos <code>flight</code>, <code>currency</code>, <code>recommendedFlightCode</code>, resultando em algo assim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod recommendations {
    use juniper::GraphQLObject;
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
    pub struct Recommendations {
        data: Vec&lt;Data&gt;,
        status: Status,
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
    pub struct Status {
        code: i32,
        message: String,
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
    #[serde(rename_all = &quot;camelCase&quot;)]
    pub struct Data {
        flights: Vec&lt;Flight&gt;,
        recommended_flight_code: String,
        currency: String,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar as struct <code>Flight</code> derivada do seguinte Json:</p>
<pre><code class="language-json">{
    &quot;flightCode&quot;:&quot;LA4596&quot;,
    &quot;arrival&quot;:{ ... },
    &quot;departure&quot;:{ ... },
    &quot;stops&quot;:0,
    &quot;segments&quot;:[ ... ],
    &quot;flightDuration&quot;:&quot;PT1H35M&quot;,
    &quot;cabins&quot;:[ ... ]
}
</code></pre>
<p>Assim, os campos são as strings <code>flightDuration</code> e <code>flightCode</code>, o campo <code>stops</code> do tipo <code>i32</code>, as duas structs de <code>arrival</code> e <code>departure</code>, os vetores de <code>segments</code> e de <code>cabins</code>: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Flight {
    flight_code: String,
    arrival: Location,
    departure: Location,
    stops: i32,
    segments: Vec&lt;Segment&gt;,
    flight_duration: String,
    cabins: Vec&lt;Cabin&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que <code>arrival</code> e <code>departure</code> estão com o mesmo tipo, <code>Location</code>, pois possuem a mesma estrutura:</p>
<pre><code class="language-json">{
    &quot;airportCode&quot;:&quot;POA&quot;,
    &quot;airportName&quot;:&quot;Salgado Filho&quot;,
    &quot;cityCode&quot;:&quot;POA&quot;,
    &quot;cityName&quot;:&quot;Porto Alegre&quot;,
    &quot;countryCode&quot;:&quot;BR&quot;,
    &quot;date&quot;:&quot;2020-07-21&quot;,
    &quot;dateTime&quot;:&quot;2020-07-21T09:15-03:00&quot;,
    &quot;time&quot;:{ &quot;stamp&quot;:&quot;09:15&quot;, &quot;hours&quot;:&quot;09&quot;, &quot;minutes&quot;:&quot;15&quot; }
}
</code></pre>
<p>Que se torna a struct <code>Location</code>, na qual quase todos os campos são Strings exceto por <code>time</code> que será a struct <code>Time</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Location {
    airport_code: String,
    airport_name: String,
    city_code: String,
    city_name:String,
    country_code: String,
    date: String,
    date_time: String,
    time: Time,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
pub  struct Time {
    stamp: String, 
    hours: String, 
    minutes: String, 
}
<span class="boring">}
</span></code></pre></pre>
<p>Para implementarmos <code>Segment</code> precisamos nos basear no seguinte json:</p>
<pre><code class="language-json">{
    &quot;flightCode&quot;:&quot;LA4596&quot;,
    &quot;flightNumber&quot;:&quot;4596&quot;,
    &quot;equipment&quot;:{ &quot;name&quot;:&quot;Airbus 321&quot;, &quot;code&quot;:&quot;321&quot; },

    &quot;airline&quot;:{
        &quot;marketing&quot;:{ &quot;code&quot;:&quot;LA&quot;, &quot;name&quot;:&quot;LATAM Airlines&quot; },
    },
    &quot;duration&quot;:&quot;PT1H35M&quot;,
    &quot;departure&quot;: Location,
    &quot;arrival&quot;: Location,
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Segment {
    flight_code: String,
    flight_number: String,
    equipment: Info,
    airline: Airline,
    duration: String,
    departure: Location,
    arrival: Location,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
pub struct Info {
    name: String,
    code: String,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
pub struct Airline {
    marketing: Info,
}
<span class="boring">}
</span></code></pre></pre>
<p>Por último, podemos implementarmos <code>Cabin</code> e vamos nos basear no json:</p>
<pre><code class="language-json">{
    &quot;code&quot;:&quot;Y&quot;,
    &quot;displayPrice&quot;:101.03,
    &quot;availabilityCount&quot;:18,
    &quot;displayPrices&quot;:{
        &quot;slice&quot;:101.03,
        &quot;wholeTrip&quot;:101.03,
    },
    &quot;fares&quot;:[...]
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Cabin {
    code: String,
    display_price: f64,
    availability_count: i32,
    display_prices: DisplayPrice,
    fares: Vec&lt;Fare&gt;
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct DisplayPrice {
    slice: f64,
    whole_trip: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>Por último precisamos modelar <code>Fare</code> cujo Json é:</p>
<pre><code class="language-json">{
    &quot;code&quot;:&quot;SL&quot;,
    &quot;category&quot;:&quot;LIGHT&quot;,
    &quot;fareId&quot;:&quot;250/BdC0XLNrp3H333zqIqmJJpNOO/05D8NwB5zcjHVNnkyl4GjqR/YOQrcDNWLPERAtEBLYqieN002&quot;,
    &quot;availabilityCount&quot;:18,
    &quot;price&quot;:{
        &quot;adult&quot;:{
            &quot;amountWithoutTax&quot;:68.9,
            &quot;taxAndFees&quot;:32.13,
            &quot;total&quot;:101.03
        }
    }
},
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Fare {
    code: String,
    category: String,
    fare_id: String,
    availability_count: i32,
    price: Price
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
pub struct Price {
    adult: PriceInfo
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, GraphQLObject)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct PriceInfo {
    amount_without_tax: f64, 
    tax_and_fees: f64, 
    total: f64, 
}
<span class="boring">}
</span></code></pre></pre>
<p>Com a modelagem pronta, podemos finalizar a implementação da query <code>recommendations</code>.</p>
<h2 id="implementando-a-query-recommendations"><a class="header" href="#implementando-a-query-recommendations">Implementando a Query <code>recommendations</code></a></h2>
<p>Como a estrutura de <code>recommendations</code> será praticamente igual a de <code>best_prices</code>, podemos nos antecipar e adicionar o resolver de <code>recommendations</code> na implementação de <code>QueryRoot</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::resolvers::internal::{best_prices_info, recommendations_info};
use crate::schema::{errors::{GenericError}, model::web::{best_prices::BestPrices, recommendations::Recommendations}};
// ...

#[juniper::object]
impl QueryRoot {
    // ...

    fn recommendations(
        departure: String,
        origin: String,
        destination: String,
    ) -&gt; Result&lt;Recommendations, GenericError&gt; {
        error::iata_format(&amp;origin, &amp;destination)?;
        error::departure_date_format(&amp;departure)?;
        let recommendations = recommendations_info(departure, origin, destination)?;
        Ok(recommendations)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos receber um erro indicando que <code>recommendations_info</code> não foi implementada ainda, e, assim, podemos partir para sua implementação, que seráexatamente igual a <code>best_prices_info</code>, apenas renomeando os campos de <code>best_prices</code> para <code>recommendations</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::boundaries::http_out::{best_prices, recommendations};
use crate::schema::{errors::GenericError, model::web::{best_prices::BestPrices, recommendations::Recommendations}};

/// ...

pub fn recommendations_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;Recommendations, GenericError&gt; {
    let recommendations_text = recommendations(departure, origin, destination)?.text()?;
    let recommendations: Recommendations = serde_json::from_str(&amp;recommendations_text)?;

    Ok(recommendations)
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar a função <code>http_out::recommendations</code> que também é parecida com a função <code>http_out::best_prices</code> pois possui apenas a <code>url</code> de request diferente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// boundaries/http_out.rs
use reqwest::{blocking::Response, Result};
// ...

pub fn recommendations(departure: String, origin: String, destination: String) -&gt; Result&lt;Response&gt; {
    let url =
        format!(&quot;https://bff.latam.com/ws/proxy/booking-webapp-bff/v1/public/revenue/recommendations/oneway?departure={}&amp;origin={}&amp;destination={}&amp;cabin=Y&amp;country=BR&amp;language=PT&amp;home=pt_br&amp;adult=1&amp;promoCode=&quot;,
                departure, origin, destination);
    reqwest::blocking::get(&amp;url)
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos executar <code>cargo run</code> e brincar com a interface gráfica de nosso serviço em <code>localhost:4000/graphiql</code>. Um exemplo de request que podemos utilizar é:</p>
<pre><code>{
  bestPrices(departure: &quot;2020-07-21&quot;, 
    origin: &quot;POA&quot;, 
    destination: &quot;GRU&quot;) {
    bestPrices {
      date
      available
      price {amount}
    }
  }
  
  recommendations(departure: &quot;2020-07-21&quot;, 
    origin: &quot;POA&quot;, 
    destination: &quot;GRU&quot;) {
    data {
      recommendedFlightCode 
      flights {
        flightCode
        flightDuration
        arrival {
          airportCode
          airportName
          dateTime
        }
        departure {
          airportCode
          airportName
          dateTime
        }
      }
    }
  }
}
</code></pre>
<ul>
<li>Lembre de atualizar as datas, quando este livro foi escrito elas estavam distantes.</li>
</ul>
<p>A resposta parcial desta query é:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;bestPrices&quot;: {
      &quot;bestPrices&quot;: [...]},
    &quot;recommendations&quot;: {
      &quot;data&quot;: [
        {
          &quot;recommendedFlightCode&quot;: &quot;LA4596&quot;,
          &quot;flights&quot;: [
            {
              &quot;flightCode&quot;: &quot;LA4596&quot;,
              &quot;flightDuration&quot;: &quot;PT1H35M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T10:50-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T09:15-03:00&quot;
              }
            },
            {
              &quot;flightCode&quot;: &quot;LA4629&quot;,
              &quot;flightDuration&quot;: &quot;PT1H35M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T22:20-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T20:45-03:00&quot;
              }
            },
            {
              &quot;flightCode&quot;: &quot;LA3287&quot;,
              &quot;flightDuration&quot;: &quot;PT1H40M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T16:55-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T15:15-03:00&quot;
              }
            },
            {
              &quot;flightCode&quot;: &quot;LA3152LA3633&quot;,
              &quot;flightDuration&quot;: &quot;PT4H55M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T13:40-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T08:45-03:00&quot;
              }
            },
            {
              &quot;flightCode&quot;: &quot;LA3152LA3613&quot;,
              &quot;flightDuration&quot;: &quot;PT8H30M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T17:15-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T08:45-03:00&quot;
              }
            },
            {
              &quot;flightCode&quot;: &quot;LA3090LA3029LA3296&quot;,
              &quot;flightDuration&quot;: &quot;PT12H45M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T22:10-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T09:25-03:00&quot;
              }
            },
            {
              &quot;flightCode&quot;: &quot;LA3090LA3151LA3687&quot;,
              &quot;flightDuration&quot;: &quot;PT12H50M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T22:15-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T09:25-03:00&quot;
              }
            },
            {
              &quot;flightCode&quot;: &quot;LA3152LA3175LA3687&quot;,
              &quot;flightDuration&quot;: &quot;PT13H30M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T22:15-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T08:45-03:00&quot;
              }
            },
            {
              &quot;flightCode&quot;: &quot;LA3152LA3028LA3381&quot;,
              &quot;flightDuration&quot;: &quot;PT13H35M&quot;,
              &quot;arrival&quot;: {
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T22:20-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;dateTime&quot;: &quot;2020-07-21T08:45-03:00&quot;
              }
            }
          ]
        }
      ]
    }
  }
}
</code></pre>
<p>Um exemplo utilizando <code>variables</code> pelo <code>Postman</code> pode ser a foto a seguir. A mesma estratégia poderá ser utilizada via <code>curl</code>.</p>
<p><img src="part-2/../imagens/postmanVariables.png" alt="Usando variables com o Postman" /></p>
<p>Nosso próximo passo é implementar um sistema de caching com redis, para evitar múltiplos requests para a API da Latam.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adicionando-caching-com-redis"><a class="header" href="#adicionando-caching-com-redis">Adicionando Caching com Redis</a></h1>
<p>Vamos utilizar como plataforma de caching o banco de dados <strong>Redis</strong> e para isso precisamos disponibilizar um container de redis. Podemos fazer isso adicionando o alvo <code>redis</code> em um Makefile. Esse Makefile vai conter um comando para executar o docker com <code>docker run -p 6379:6379 --name some-redis -d redis</code>. Inclusive podemos incluir um alvo para executar <code>cargo run</code>:</p>
<pre><code class="language-Makefile">redis:
	docker run -p 6379:6379 --name some-redis -d redis

run:
	cargo run

</code></pre>
<p>Se executarmos <code>make redis</code> vamos obter o seguinte output no terminal:</p>
<pre><code class="language-sh">docker run -p 6379:6379 --name some-redis -d redis
Unable to find image 'redis:latest' locally
latest: Pulling from library/redis
8559a31e96f4: Pull complete 
85a6a5c53ff0: Pull complete 
b69876b7abed: Pull complete 
a72d84b9df6a: Pull complete 
5ce7b314b19c: Pull complete 
04c4bfb0b023: Pull complete 
Digest: sha256:800f2587bf3376cb01e6307afe599ddce9439deafbd4fb8562829da96085c9c5
Status: Downloaded newer image for redis:latest
0190e745a049650ba4a594b2f379483729fb9b5f01b4b1f7467ef4641772e042
</code></pre>
<h2 id="disponibilizando-o-redis-client-para-as-queries"><a class="header" href="#disponibilizando-o-redis-client-para-as-queries">Disponibilizando o Redis Client para as Queries</a></h2>
<p>A primeira coisa que precisamos fazer é adicionar a crate <img src="https://github.com/mitsuhiko/redis-rs" alt="redis" /> ao seu <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-web = &quot;2.0.0&quot;
actix-rt = &quot;1.0.0&quot;
juniper = &quot;0.14.2&quot;
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
chrono = &quot;0.4.11&quot;
reqwest = { version = &quot;0.10.4&quot;, features = [&quot;blocking&quot;, &quot;json&quot;] }
redis = &quot;0.16.0&quot;
</code></pre>
<p>Com isso podemos começar disponibilizando uma função que retorna o <code>redis::Client</code>. Na documentação vemos que basta executarmos <code>redis::Client::open(&quot;redis://127.0.0.1/&quot;)?</code> para obtermos o <code>Client</code>, mas por moticos de consistência de código criremos um módulo  <code>boundaries/redis.rs</code> que possuirá a função <code>redis_client</code> cujo tipo de retorno será um <code>RedisResult&lt;Client&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use redis::{Client,RedisResult};

pub fn redis_client() -&gt; RedisResult&lt;Client&gt; {
    Ok(redis::Client::open(&quot;redis://127.0.0.1/&quot;)?)
}
<span class="boring">}
</span></code></pre></pre>
<p>Com a função <code>redis_client</code> implementada podemos pensar em como vamos incluir o caching no nosso sistema. O local que eu acredito ser mais apropriado é em <code>resolvers/internal.rs</code>, pois é o estágio anterior a fazermos o request e funciona bem como um controller também. Assim, na função <code>recommendations_info</code> podemos criar a conexão do Redis com <code>let mut con = redis_client()?.get_connection()?</code>.  <code>con</code> é um tipo mutável pois as operações de <code>set</code> e <code>get</code>, adicionar e ler respectivamente, exigem mutabilidade. Além disso, para podermos utilizar <code>get</code> e <code>set</code> precisamos utilizar a diretiva <code>use redis::Commands;</code>. </p>
<p>Outro fato importante é definirmos como vamos querer criar essa estratégia de caching. Sabemos que a função <code>recommendations_info</code> recebe 3 argumentos, <code>departure, origin, destination</code>, então podemos concluir que estes argumentos são chaves para o caching, porém ainda precisamos definir uma estratégia de tempo. Como sei que as passagens não mudam muito de um dia pro outro, vamos utilizar a atual data como principal chave do caching. Podemos fazer isso utilizando a crate <code>chrono</code> e sua função <code>Utc::today().to_string()</code> que retorna uma data como <code>2020-06-18UTC</code>, e vamos salvar essa informação no valor <code>today</code>. Para compormos essas chaves podemos utilizar a seguinte declaração <code>let redis_key = format!(&quot;r{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);</code>, que combinado retorna <code>r2020-06-18UTC:2020-07-21:POA:GRU</code>, o <code>r</code> faz referência a <code>recommendations</code>.</p>
<p>Com <code>con</code> podemos chamar a função <code>get</code> com a <code>redis_key</code> e aplicar um <code>match</code> em seu resultado. Este <code>get</code> vai nos retornar um Result que caso seja <code>Ok</code> vai retornar o retorno o body do request <code>http</code> e caso seja <code>Err</code> precisaremos aplicar a função <code>set</code> com <code>set(&amp;redis_key, &amp;recommendations_text)</code>. Algo como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match con.get(&amp;redis_key) {
    Ok(response) =&gt; response,
    Err(_) =&gt; {
        let _recommendations = recommendations(departure, origin, destination)?.text()?;
        let _: () = con.set(&amp;redis_key, &amp;_recommendations)?;
        _recommendations
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Assim, o resultado deste <code>match</code> agora pode ser utilizado em um <code>let recommendations_text = match ...</code> que será passado para a função <code>let recommendations: Recommendations = serde_json::from_str(&amp;recommendations_text)?</code> e retornar um <code>Ok(recommendations)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::boundaries::{
    http_out::{best_prices, recommendations},
    redis::redis_client};
use crate::schema::{errors::GenericError, model::web::{best_prices::BestPrices, recommendations::Recommendations}};
use redis::Commands;
use chrono::Utc;

// ...

pub fn recommendations_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;Recommendations, GenericError&gt; {
    let mut con = redis_client()?.get_connection()?;
    let today = Utc::today().to_string();
    let redis_key = format!(&quot;r{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);

    let recommendations_text = match con.get(&amp;redis_key) {
        Ok(response) =&gt; response,
        Err(_) =&gt; {
            let _recommendations = recommendations(departure, origin, destination)?.text()?;
            let _: () = con.set(&amp;redis_key, &amp;_recommendations)?;
            _recommendations
        }
    };
    
    let recommendations: Recommendations = serde_json::from_str(&amp;recommendations_text)?;

    Ok(recommendations)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="aplicando-caching-a-best_prices"><a class="header" href="#aplicando-caching-a-best_prices">Aplicando Caching a <code>best_prices</code></a></h2>
<p>Agora para aplicarmos caching em <code>best_prices_info</code> podemos copiar a solução de <code>recommendations_info</code> modificando as funções para <code>best_prices</code> e definir a <code>redis_key</code> com a inicial <code>bp</code>, <code>let redis_key = format!(&quot;bp{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::boundaries::{
    http_out::{best_prices, recommendations},
    redis::redis_client};
use crate::schema::{errors::GenericError, model::web::{best_prices::BestPrices, recommendations::Recommendations}};
use redis::Commands;
use chrono::Utc;

pub fn best_prices_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;BestPrices, GenericError&gt; {
    let mut con = redis_client()?.get_connection()?;
    let today = Utc::today().to_string();
    let redis_key = format!(&quot;bp{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);

    let best_prices_text = match con.get(&amp;redis_key) {
        Ok(response) =&gt; response,
        Err(_) =&gt; {
            let _best_prices = best_prices(departure, origin, destination)?.text()?;
            let _: () = con.set(&amp;redis_key, &amp;_best_prices)?;
            _best_prices
        }
    };

    let best_prices: BestPrices = serde_json::from_str(&amp;best_prices_text)?;

    Ok(best_prices)
}

pub fn recommendations_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;Recommendations, GenericError&gt; {
    let mut con = redis_client()?.get_connection()?;
    let today = Utc::today().to_string();
    let redis_key = format!(&quot;r{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);

    let recommendations_text = match con.get(&amp;redis_key) {
        Ok(response) =&gt; response,
        Err(_) =&gt; {
            let _recommendations = recommendations(departure, origin, destination)?.text()?;
            let _: () = con.set(&amp;redis_key, &amp;_recommendations)?;
            _recommendations
        }
    };
    
    let recommendations: Recommendations = serde_json::from_str(&amp;recommendations_text)?;

    Ok(recommendations)
}
<span class="boring">}
</span></code></pre></pre>
<p>Em nossos exemplos fizemos caching de mesma data, mas é possível passar chaves que expiram com as funções <code>set_ex</code> que recebe a quantidade de segundos até expirar no formato <code>usize</code>, <code>pub fn set_ex&lt;'a, K: ToRedisArgs, V: ToRedisArgs&gt;(key: K, value: V, seconds: usize) -&gt; Self</code>, e a função <code>pset_ex</code> que faz a mesma coisa, mas com milisegundos, <code>pub fn pset_ex&lt;'a, K: ToRedisArgs, V: ToRedisArgs&gt;(key: K, value: V, milliseconds: usize) -&gt; Self</code>. Outras funcões interessantes de se olhar são <code>mset_nx</code>, <code>getset</code>, <code>getrange</code>, <code>setrange</code>, <code>persist</code>, <code>append</code>, outras funcões podem ser encontradas em https://docs.rs/redis/0.16.0/redis/struct.Cmd.html. </p>
<p>Nesta parte aprendemos a utilizar GraphQL com Actix, fazer requests HTTP síncronos e salvar essas informações como caching em uma banco de dados Redis. Com isso podemos começar um frontend com WebAssemby capaz de processar as informações do GraphQL em uma single page app que nos permitirá interagir com as passagens da Latam.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frontend-com-webassembly-e-yewstack"><a class="header" href="#frontend-com-webassembly-e-yewstack">Frontend com WebAssembly e YewStack</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-de-webassembly"><a class="header" href="#setup-de-webassembly">Setup de WebAssembly</a></h1>
<p>Antes de fazermos o setup de WebAssembly para nosso computador, vamos entender o porquê de WebAssembly e o que é YewStack que vamos utilizar.</p>
<h2 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h2>
<h3 id="o-que-é-webassembly"><a class="header" href="#o-que-é-webassembly">O que é WebAssembly</a></h3>
<p>WebAssembly, também conhecido como <code>Wasm</code>, é um padrão que define um formato binário portável e compacto para executáveis com velocidades quase nativas. Sua correspondente textual da linguagem assembly é o <code>.wat</code>, que utiliza <code>expressões-s</code>, que lembra um pouco Clojure e Scheme. Sua principal aplicação é como interface simples entre o programa que você desenvolveu e seu host ambiente, assim seu maior objetivo é possibilitar páginas web de alta performance, mas existem outros exemplos aplicando os conceitos de WemAssemlby para mobile por exemplo.</p>
<h3 id="por-que-webassembly"><a class="header" href="#por-que-webassembly">Por que WebAssembly</a></h3>
<p>Aplicações web JavaScript possui uma certa incerteza quanto a performance que o produto final vai atingir. Seu sistema de tipos dinâmico dificulta muitas otimizações e o Garbage Collector muitas vezes não ajuda por depender de algumas pausas confusas. Além disso, aplicar um superset tipado não garante efetivamente uma melhora nesses quesitos, pois no final das contas, continua tendo que executar JavaScript. Outro grande problema pode ser o fato de pequenas mudanças impactarem profundamente a performance caso você caia em buracos como <code>fadiga do JavaScript</code> (JavaScript fatigue) e como <code>inferno de dependências</code> (dependency hell), que podem confundir muito o sistema de JIT. Outro ponto importante é o tamanho do código, especialmente quando falamos de <em>dependency hell</em>, o JavaScript pode causar grande impacto de performance, pois o tamanho do arquivo que vamos comunicar via internet é crucial.</p>
<p>Assim, Rust provê um controler de baixo nível e uma performance confiável, especialmente por não depender de Garbage Collectors não deterministicos como o JavaScript, por possibilitar arquivos de tamanho reduzido, já que você só recebe o que você precisa, e por dar poder as pessoas que vão desenvolver de como o layout de memória será. Outra vantagem é que WebAssembly permite uma portabilidade muito boa, de forma que você pode começar implementando apenas as partes mais críticas de seu JavaScript.</p>
<h3 id="yewstack"><a class="header" href="#yewstack">YewStack</a></h3>
<p>Yew é um framework moderno para criar apps frontend multi-threaded com WebAssembly e Rust.</p>
<ul>
<li>Possui um framework baseado em componentes que permite criar UIs de forma interativa. Assim, quem já possui experiência de React e Elm devem se sentir bastante confortáveis com o funcionamento do Yew.</li>
<li>Sua performance se da por minimizar chamadas a API de DOM e por permitir muito processamento nos web workers de background.</li>
<li>Permite ótima interoperabilidade com JavaScript, o que permite desenvolver aproveitando os pacotes NPM e integrar com aplicações JavaScript já existentes.</li>
</ul>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Primeiro devemos começar com o setup do WebAssembly para Rust:</p>
<ol>
<li>Começamos com o <code>wasm-pack</code>, uma ferramenta para construir, testar e publicar WebAssembly gerado por Rust. Basta executar o comando <code>curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh</code> ou acessar o site https://rustwasm.github.io/wasm-pack/installer/ para mais informações. Outra opção é utilizar o <code>cargo install wasm-pack</code>.</li>
<li>O segundo passo é instalar o <code>cargo-generate</code>, que pode ser feito através do comando <code>cargo install cargo-generate</code>. Sua função é facilitar a subida e execução de novos projetos e seus tempaltes em Rust.</li>
<li>Por fim, instalar o NPM de sua escolha, uma sugestão é fazer o download pelo site https://www.npmjs.com/get-npm e executar <code>npm install npm@latest -g</code>.</li>
</ol>
<h3 id="setup-para-o-yew"><a class="header" href="#setup-para-o-yew">Setup para o Yew</a></h3>
<p>Para utilizarmos o Yew vamos precisar de 2 novos pacotes, <code>wasm-bindgen</code> e <code>cargo-web</code>, e uma dependência NPM chamada <code>rollup</code>. </p>
<ol>
<li><code>wasm-bindgen</code> pode ser encontrado como <code>dependencies</code>. </li>
<li>Para instalar o <code>cargo-web</code>  você precisa executar o comando <code>cargo install cargo-web</code>. Para o <code>build</code> basta utilizar <code>cargo web build</code> e o <code>run</code> utilizar <code>cargo web run</code>. Necessário para <code>stdweb</code>.</li>
<li>Para o exemplo teste precisamos instalar o <code>rollup</code> execute <code>npm install --global rollup</code></li>
<li>Para o nosso exemplo de teste vamos utilozar Python, ou Python3 se você preferir, e o módulo <code>http</code> isntalado com <code>pip install http</code>. Outros servidores também seriam possíveis como o <code>miniserve</code> do cargo, que pode ser obtido através do comando <code>cargo +nightly install miniserve</code>.</li>
</ol>
<p>Os alvos suportados são:</p>
<ul>
<li><code>wasm32-unknown-unknown</code></li>
<li><code>wasm32-unknown-emscripten</code></li>
<li><code>asmjs-unknown-emscripten</code></li>
</ul>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>Nesse exemplo vamos utilizar o template mínimo da <code>yew-stack</code>, para isso faça clone do repositório https://github.com/yewstack/yew-wasm-pack-minimal.git. Você verá que o arquivo <code>Cargo.toml</code> está configurado da seguitne forma:</p>
<pre><code class="language-toml">[package]
authors = [
    &quot;Kelly Thomas Kline &lt;kellytk@sw-e.org&gt;&quot;,
    &quot;Samuel Rounce &lt;me@samuelrounce.co.uk&gt;&quot;
]
categories = [&quot;gui&quot;, &quot;wasm&quot;, &quot;web-programming&quot;]
description = &quot;yew-wasm-pack-minimal demonstrates the minimum code and tooling necessary for a frontend web app with simple deployable artifacts consisting of one HTML file, one JavaScript file, and one WebAssembly file, using Yew, wasm-bindgen, and wasm-pack.&quot;
edition = &quot;2018&quot;
keywords = [&quot;yew&quot;, &quot;wasm&quot;, &quot;wasm-bindgen&quot;, &quot;web&quot;]
license = &quot;MIT/Apache-2.0&quot;
name = &quot;yew-wasm-pack-minimal&quot;
readme = &quot;README.md&quot;
repository = &quot;https://github.com/yewstack/yew-wasm-pack-minimal&quot;
version = &quot;0.1.0&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen = &quot;^0.2&quot;
yew = &quot;0.12&quot;
</code></pre>
<p>Na tag <code>author</code> mude para seu nome e seu email, a <code>description</code> pode ser <code>&quot;hello world in wasm&quot;</code>, a tag <code>name</code> pode ser <code>hello-world-wasm</code>, estaremos utilizando <code>websys</code>. Caso você deseje utilizar a <code>stdweb</code> basta modificar a dependência <code>yew</code> para <code>yew = { version = &quot;0.15&quot;, package = &quot;yew-stdweb&quot; }</code>. Alguns exemplos da diferença entre <code>websys</code> e <code>stdweb</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// web-sys
let window: web_sys::Window = web_sys::window().expect(&quot;window not available&quot;);
window.alert_with_message(&quot;hello from wasm!&quot;).expect(&quot;alert failed&quot;);

// stdweb
let window: stdweb::web::Window = stdweb::web::window();
window.alert(&quot;hello from wasm!&quot;);

// stdweb com a macro js!
use stdweb::js;
use stdweb::unstable::TryFrom;
use stdweb::web::Window;

let window_val: stdweb::Value = js!{ return window; };
let window = Window::try_from(window_val).expect(&quot;conversion to window failed&quot;);
window.alert(&quot;hello from wasm!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Dentro da macro <code>js!</code> é possível utilizar JavaScript, como no exemplo <code>js!{ return window; }</code>.</p>
<p><strong>Diferenças entre <code>web-sys</code> e <code>stdweb</code></strong></p>
<p>|  	| web-sys 	| stdweb 	|
|-	|-	|-	|
| Status do projeto 	| Ativamente mantido pelo wasm-working-group 	| Pouca atividade no Github, já passou longos períodos sem commits 	|
| Cobertura da Web API 	| APIs Rust são auto geradas pela spec Web IDL e deveriam ter cobertura de ~100%. | APIs do Browser são adicionadas de acordo com as necessidades da comunidade |
| Design da API Rust 	| Toma medidas conservadoras ao retornar quase sempre um <code>Result</code> para as chamadas da API	| Prefere utilizar <code>panic!</code> em vez de <code>Result</code>.	|
| Suporte para build tools | * <code>wasm-pack</code> * <code>wasm-bindgen</code> | * <code>wasm-pack</code> * <code>wasm-bindgen</code> * <code>cargo-web</code> |
| Alvos suportados | * <code>wasm32-unknown-unknown</code> | * <code>wasm32-unknown-unknown</code> * <code>wasm32-unknown-emscripten</code> * <code>asmjs-unknown-emscripten</code> |</p>
<h3 id="executando-o-projeto"><a class="header" href="#executando-o-projeto">Executando o projeto</a></h3>
<p><strong>Opção 1</strong></p>
<ol>
<li>Para buildar o projeto execute <code>wasm-pack build --target web</code>.</li>
<li>Para fazer o bundle utilize <code>rollup ./main.js --format iife --file ./pkg/bundle.js</code>. </li>
<li>Para expor seu bundle no browser execute o comando <code>python -m SimpleHTTPServer</code> para Python2 e <code>python3 -m http.server</code> para Python3, depois acesse em seu browser <code>localhost:8000</code> para ver um bome  velho <code>Hello world!</code>.</li>
</ol>
<p><strong>Opção 2</strong></p>
<ol>
<li>Crie a pasta <code>static</code> através de um <code>mkdir static</code> e inclua o seguinte arquivo <code>index.html</code>:</li>
</ol>
<pre><code class="language-html">&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;Yew Sample App&lt;/title&gt;
        &lt;script type=&quot;module&quot;&gt;
            import init from &quot;./wasm.js&quot;
            init()
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>Modifique a <code>src/lib.rs</code> para expor a função:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app;

use wasm_bindgen::prelude::*;
use yew::App;

#[wasm_bindgen(start)]
pub fn run_app() {
    App::&lt;app::App&gt;::new().mount_to_body();
}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>Execute o comando <code>wasm-pack build --target web --out-name wasm --out-dir ./static</code> para buildar seu projeto.</li>
<li>Disponibilize o bundle no browser com <code>miniserve ./static --index index.html</code>. E pronto, basta acessar <code>localhost:8080</code>.</li>
</ol>
<p>Ao longo das próximas etapas do projeto vamos utilizar a <code>opção 2</code>, mas se você preferir utilizar a <code>opção 1</code> fique a vontade.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iniciando-o-projeto"><a class="header" href="#iniciando-o-projeto">Iniciando o projeto</a></h1>
<p>Para este passo vamos criar um novo projeto chamado <code>wasm-airline</code> com o comando <code>cargo new --lib wasm-airline</code>. Em nosso <code>Cargo.toml</code> vamos adicionar o seguinte código:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies]
yew = &quot;0.16&quot;
wasm-bindgen = &quot;0.2&quot;
</code></pre>
<p>Depois vamos ao nosso arquivo <code>src/lib.rs</code> e adicionamos o seguinte código:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app;

use wasm_bindgen::prelude::*;
use yew::prelude::App;


#[wasm_bindgen(start)]
pub fn run_app() {
    App::&lt;app::Airline&gt;::new().mount_to_body();
}
<span class="boring">}
</span></code></pre></pre>
<p>E com isso precisamos criar a struct <code>Airline</code> no módulo <code>app</code>, cuja estrutura base será igual a do exemplo de <code>hello-world</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/app.rs
use yew::prelude::*;

pub struct Airline {}

pub enum Msg {}

impl Component for Airline {
    type Message = Msg;
    type Properties = ();

    fn create(_: Self::Properties, _: ComponentLink&lt;Self&gt;) -&gt; Self {
        Airline {}
    }

    fn change(&amp;mut self, _: &lt;Self as yew::html::Component&gt;::Properties) -&gt; bool {
        false
        // Essa função deve retornar true somente se as `Properties` mudarem
     }

    fn update(&amp;mut self, _msg: Self::Message) -&gt; ShouldRender {
        true
    }

    fn view(&amp;self) -&gt; Html {
        html! {
            &lt;p&gt;{ &quot;Hello world!&quot; }&lt;/p&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>esqueça de criar a pasta <code>static</code> e incluir o arquivo <code>static/index.html</code>:</li>
</ul>
<pre><code class="language-html">&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;Yew Sample App&lt;/title&gt;
        &lt;script type=&quot;module&quot;&gt;
            import init from &quot;./wasm.js&quot;
            init()
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Para executar o projeto vamos criar um <code>Makefile</code> que vai executar os comandos que definimos no capítulo anterior para executar o projeto:</p>
<pre><code class="language-sh">build:
	wasm-pack build --target web --out-name wasm --out-dir ./static

serve:
	miniserve ./static --index index.html

run: build serve
</code></pre>
<p>Ao executar <code>make run</code> podemos acessar <code>localhost:8080</code> e encontrar o texto <code>Hello world!</code>. Se fizermos uma alteração dentro da função <code>view</code> para algo como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; Html {
    html! {
        &lt;div&gt;
            &lt;p&gt;{ &quot;Hello world!&quot; }&lt;/p&gt;
            &lt;p&gt;{ &quot;Hello Julia&quot; }&lt;/p&gt;
        &lt;/div&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Podemos recompilar apenas executando <code>make build</code> e recarregar a página. No próximo capítulo vamos iniciar carregando os dados de <code>BestPrices</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="componente-de-best-prices"><a class="header" href="#componente-de-best-prices">Componente de Best Prices</a></h1>
<p>Vamos começar com o código que corresponde ao componente de Best Prices, aquele que é o carrossel de preços na parte da imagem a seguir.</p>
<p><img src="part-3/../imagens/bestprices.png" alt="Imagem do componente de Best Prices" /></p>
<h2 id="fazendo-o-request-para-para-nosso-serviço-da-parte-2"><a class="header" href="#fazendo-o-request-para-para-nosso-serviço-da-parte-2">Fazendo o request para para nosso serviço da parte 2</a></h2>
<p>A primeira coisa que precisamos fazer para podermos utilizar os dois serviços (frontend e backend) em <code>localhost</code> é implementar um sistema de CORS no serviço GraphQL que fizemos anteriormente. Essa mudanca é bastante simples e impacta muito pouco na estrutura do código. O que vamos fazer é adicionar a crate <code>actix-cors</code> no <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;recommendations-gql&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Julia Naomi &lt;jnboeira@outlook.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
actix-web = &quot;2.0.0&quot;
# ...
redis = &quot;0.16.0&quot;
actix-cors = &quot;0.2.0&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
</code></pre>
<p>Agora no arquivo <code>main.rs</code> precisamos adicionar as configurações de CORS, para isso disponibilizamos <code>Cors</code> através da diretiva <code>use actix_cors::Cors;</code> e dentro da função <code>main</code> criamos o recurso de <code>Cors</code> envolto em um <code>wrap</code> com:</p>
<pre><pre class="playground"><code class="language-rust">#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let resolvers: std::sync::Arc&lt;Resolver&gt; = std::sync::Arc::new(create_resolver());

    HttpServer::new(move || {
        App::new()
            .data(resolvers.clone())
            .wrap(
                Cors::new()
                    // ...
                    .finish(),
            )
            .configure(routes)
            .default_service(web::to(|| async { &quot;404&quot; }))
    })
    .bind(&quot;127.0.0.1:4000&quot;)?
    .run()
    .await
}
</code></pre></pre>
<p>Agora precisamos configurar quais domínios, métodos e headers serão adicionados. Existem duas maneiras de fazer isso, a primeira e mais simples é atraveés da função <code>supported_credentials</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::new()
    .data(resolvers.clone())
    .wrap(
        Cors::new()
            .supports_credentials()
            .max_age(3600)
            .finish(),
    )
    .configure(routes)
    .default_service(web::to(|| async { &quot;404&quot; }))
<span class="boring">}
</span></code></pre></pre>
<p>E a segunda é adicionando explicitamente as informações com as funções <code>allowed_*</code>. Vamos utilizar esta abordagem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::new()
    .data(resolvers.clone())
    .wrap(
        Cors::new()
            .allowed_origin(&quot;http://localhost:8080&quot;)
            .allowed_origin(&quot;http://127.0.0.1:8080&quot;)
            .allowed_origin(&quot;http://0.0.0.0:8080&quot;)
            .allowed_methods(vec![&quot;GET&quot;, &quot;POST&quot;])
            .allowed_headers(vec![header::AUTHORIZATION, header::ACCEPT])
            .allowed_header(header::CONTENT_TYPE)
            .max_age(3600)
            .finish(),
    )
    .configure(routes)
    .default_service(web::to(|| async { &quot;404&quot; }))
<span class="boring">}
</span></code></pre></pre>
<p>Agora basta executar um <code>make redis</code> e depois um <code>make run</code> e esse serviço estará executando.</p>
<h3 id="printando-o-request"><a class="header" href="#printando-o-request">Printando o request</a></h3>
<p>O passo mais básico que podemos fazer com um request é printar sua resposta na tela. Não precisamos de nenhum estilo bonito ou organização neste ponto, serve somente para sabermos que o request foi bem sucedido. Para fazermos isso, podemos começar pensando como será nossa <code>view</code>. Atualmente nossa <code>view</code> está com a seguinte aparência:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; Html {
    html! {
        &lt;div&gt;
            &lt;p&gt;{ &quot;Hello world!&quot; }&lt;/p&gt;
            &lt;p&gt;{ &quot;Hello Julia&quot; }&lt;/p&gt;
        &lt;/div&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Mas se vamos fazer um request precisaremos de um booleano que indica o estado de <code>loading</code> e uma <code>String</code> que representa a resposta do do backend GraphQL:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; Html {
    if self.fetching {
        html! {
            &lt;div class=&quot;loading&quot;&gt;
                {&quot;Loading...&quot;}
            &lt;/div&gt;
        } 
    } else {
        html! {
            &lt;div&gt;
                &lt;p&gt;{ 
                    if let Some(data) = &amp;self.graphql_response {
                        data
                    } else {
                        &quot;Failed to fetch&quot;
                    }
                }&lt;/p&gt;
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, defini as duas propriedades da struct <code>Airline</code> são <code>fetching</code> que indica que um request está sendo feito e <code>graphql_response</code> que corresponde ao corpo da resposta do GraphQL. Nosso <code>view</code> possui duas modalidades definidas pelo <code>if/else</code>, caso o <code>self.fetching</code> seja <code>true</code> vamos exibir o texto <code>Loading...</code> no HTML, que podemos construir utilizando a macro <code>html!</code> e injetando o HTML correspondente os q desejamos executar, no caso <code>html! {&lt;div class=&quot;loading&quot;&gt;{&quot;Loading...&quot;}&lt;/div&gt;}</code>. Já no nosso <code>else</code> utilizamos a macro <code>html!</code> da mesma forma, mas decidimos o que exibir com base no <code>if-let</code> que extrai o campo <code>Option</code> de  <code>graphql_response</code>. Com isso, podemos começar a implementar a struct <code>Airline</code> e implementar a função <code>create</code> que vai definir os valores iniciais de cada propriedade:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use yew::prelude::*;
// ...


pub struct Airline {
    // ...
    fetching: bool,
    graphql_response: Option&lt;String&gt;
}

pub enum Msg {
    // ..
    Fetching(bool)
}

impl Component for Airline {
    type Message = Msg;
    type Properties = ();

    fn create(_: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {
        Airline {
            // ...
            fetching: false,
            graphql_response: None
        }
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que a função <code>create</code> pertence a trait <code>Component</code>, que equivale as funções básicas do React. E o enum <code>Msg</code> do tipo <code>Message</code> funciona de forma que para cada mensagem enviada uma ação é tomada, o que explica os dois estados do <code>if/else</code> reagindo diferentemente ao <code>self.fetching</code>, que é recebido pela opção <code>Msg::Fetching</code> que recebe um <code>bool</code>. Esta funcionalidade de atualizar o estado pertence a função <code>update</code> da trait <code>Component</code>.  Já a função <code>update</code> tem a seguinte aparência:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Component for Airline {
    type Message = Msg;
    type Properties = ();
    // ...
    fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
        match msg {
            // ...
            Msg::Fetching(fetch) =&gt; {
                self.fetching = fetch;
            }
        }
        true
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Na função <code>update</code> para cada opção de <code>Msg</code> o match toma uma ação. Outra função importante nesse contexto é a função <code>create</code> que funciona de forma a atualizar a <code>view</code> em caso de alguma propriedade mudar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Component for Airline {
    type Message = Msg;
    type Properties = ();

    // ...
    fn change(&amp;mut self, _: &lt;Self as yew::html::Component&gt;::Properties) -&gt; bool { 
        false
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Na função <code>change</code>, se alguma propriedade mudar, é preciso retornar <code>true</code>, e se nada acontecer retornar <code>false</code>. Com isso, falamos de todas as funções de implementação obrigatória da trait <code>Component</code>, mas ainda temos uma função extra que podemos utilizar para nossa aplicação, a <code>rendered</code>, que corresponde ao <code>componentDidMount</code> do React, e ela é aplicada de forma diferente para o primeiro <code>render</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rendered(&amp;mut self, first_render: bool) {
    if first_render {
        Msg::Fetching(true);
        self.fetch_data(); 
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para o primeiro <code>render</code> atualizamos o estado de <code>fetching</code> para true com <code>Msg::Fetching(true)</code> para que possamos exibir <code>Loading...</code> na <code>view</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; Html {
    if self.fetching {
        html! {
            &lt;div class=&quot;loading&quot;&gt;
                {&quot;Loading...&quot;}
            &lt;/div&gt;
        } 
    } 
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois disso, temos a função que executa o <code>fetch</code> em si, <code>self.fetch_data()</code>. Para essa função vamos precisar de um novo <code>impl</code> que nos permita acessar o <code>self</code> de <code>Airline</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::gql::fetch_gql;

impl Airline {
    pub fn fetch_data(&amp;mut self) {
        let request = fetch_gql();
  
          let callback = self.link.callback(
              move |response: Response&lt;Text&gt;| {
                  let (meta, data) = response.into_parts();
                  if meta.status.is_success() {
                      Msg::FetchGql(Some(data))
                  } else {
                      Msg::FetchGql(None)
                  }
              },
          );
  
          let request = Request::builder()
              .method(&quot;POST&quot;)
              .header(&quot;content-type&quot;, &quot;application/json&quot;)
              .uri(self.graphql_url.clone())
              .body(Json(&amp;request))
              .unwrap();

          let task = self.fetch.fetch(request, callback).unwrap();
          self.fetch_task = Some(task);
          Msg::Fetching(false);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Primeiro passo de <code>fetch_data</code> é função da <code>fetch_gql</code> do módulo <code>gql</code>, que retorna o Json para executar a query no serviço, que depende da crate <code>serde_json</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::{json, Value};

pub fn fetch_gql() -&gt; Value {
    json!({
        &quot;query&quot;: &quot;{
             bestPrices(departure: \&quot;2020-07-21\&quot;, origin: \&quot;POA\&quot;, destination: \&quot;GRU\&quot;) {
                bestPrices {
                    date
                    available
                    price {amount}
                }
             }
        }&quot;
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Em seguida, encontramos <code>self.link</code>, um novo tipo a ser adicionado a nossa struct <code>Airline</code>, que é do tipo <code>ComponentLink&lt;Self&gt;</code>, cuja principal função é fazer callback. No nosso caso, esses callback processam a resposta da requisição, <code>response</code>, separam a resposta através da funçnao <code>into_parts</code> em metadados, <code>meta</code>, e em corpo, <code>data</code> para executar um pattern matching dos valores. Se a requisição retornou <code>2xx</code>, através da função <code>meta.status.is_success()</code>, enviamos a mensagem <code>Msg::FetchGql(Some(data))</code>, senão enviamos a mensagem <code>Msg::FetchGql(None)</code>.</p>
<p>O próximo passo é montar a requisição com <code>yew::services::fetch::Request::builder()</code>, na qual definimos o método com <code>method(&quot;POST&quot;)</code>, os <code>headers</code>, a <code>url</code> já salva em <code>self.graphql_url</code> e o corpo do request em <code>body</code>, que é o tipo <code>Value</code> retornado em <code>let request = fetch_gql();</code> transformado em Json através da função <code>Json()</code>. Por último definimos o <code>fetch</code> com seu <code>request</code> e seu <code>callback</code>, <code>fetch(request, callback)</code> e passamos seu resultado para <code>FetchTask</code> definida em <code>self.fetch_task</code>, que executará o fetch:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let task = self.fetch.fetch(request, callback).unwrap();
self.fetch_task = Some(task);
<span class="boring">}
</span></code></pre></pre>
<p>Para então definirmos que <code>fetching</code> é false em <code>Msg::Fetching(false)</code>. Agora precisamos adicionar os novos tipos de dados presentes em nossa struct <code>Airline</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use yew::prelude::*;
use yew::services::{
    fetch::{FetchService, FetchTask, Request, Response}
};
use yew::format::{Text, Json};
use crate::gql::fetch_gql;


pub struct Airline {
    fetch: FetchService,
    link: ComponentLink&lt;Self&gt;,
    fetch_task: Option&lt;FetchTask&gt;,
    fetching: bool,
    graphql_url: String,
    graphql_response: Option&lt;String&gt;
}


impl Airline {
    pub fn fetch_data(&amp;mut self) {
        // ...    
    }
}

pub enum Msg {
    FetchGql(Option&lt;Text&gt;),
    Fetching(bool)
}

impl Component for Airline {
    type Message = Msg;
    type Properties = ();

    fn create(_: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {
        Airline {
            fetch: FetchService::new(),
            link: link,
            fetch_task: None,
            fetching: true,
            graphql_url: &quot;http://localhost:4000/graphql&quot;.to_string(),
            graphql_response: None
        }
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Para cada um dos campos:</p>
<ul>
<li><code>fetch: FetchService</code>: <code>FetchService</code> é a struct com conhecimentos de como realizar um Fetch via WebAssembly, algo como o <code>fetch</code> em JavaScript. Para inicializar este valor basta executar <code>FetchService::new()</code>.</li>
<li><code>link: ComponentLink&lt;Self&gt;</code>: como já falamos é responsável por fazer as conexões do <code>Component</code> com <code>callbacks</code>. É inicializado com pelo próprio <code>Component</code>.</li>
<li><code>fetch_task: Option&lt;FetchTask&gt;</code>: é basicamente um handler para os request. Se seu estado é <code>None</code> nada é executado, se seu estado é <code>Some</code> com alguma <code>FetchTask</code> ele a executa. Inicializado com <code>None</code>.</li>
<li><code>fetching: true,</code>: Indica se a aplicação está fazendo um request. Inicializado com <code>true</code> pois é a primeira coisa que o sertviço executa.</li>
<li><code>graphql_url: String,</code>: Url na qual faremos o request, neste caso o nosso endpoint local <code>/graphql</code>, <code>&quot;http://localhost:4000/graphql&quot;</code>.</li>
<li><code>graphql_response: Option&lt;String&gt;</code>: Por enquanto um tipo String que contém os dados da resposta do Graphql. Logo transformaremos em uma struct com domínio próprio.</li>
</ul>
<h2 id="modelando-a-response-de-bestprices"><a class="header" href="#modelando-a-response-de-bestprices">Modelando a response de BestPrices</a></h2>
<p>Nosso Json de resposta é o seguinte:</p>
<pre><code class="language-json">{
  &quot;data&quot;:{
    &quot;bestPrices&quot;:{
      &quot;bestPrices&quot;:[
        {
          &quot;date&quot;:&quot;2020-07-18&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
            &quot;amount&quot;:110.03
          }
        },
        {
          &quot;date&quot;:&quot;2020-07-19&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
            &quot;amount&quot;:110.03
          }
        },
        {
          &quot;date&quot;:&quot;2020-07-20&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
            &quot;amount&quot;:110.03
          }
        },
        {
          &quot;date&quot;:&quot;2020-07-21&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
            &quot;amount&quot;:110.03
          }
        },
        {
          &quot;date&quot;:&quot;2020-07-22&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
            &quot;amount&quot;:110.03
          }
        },
        {
          &quot;date&quot;:&quot;2020-07-23&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
            &quot;amount&quot;:110.03
          }
        },
        {
          &quot;date&quot;:&quot;2020-07-24&quot;,
          &quot;available&quot;:true,
          &quot;price&quot;:{
            &quot;amount&quot;:99.03
          }
        }
      ]
    }
  }
}
</code></pre>
<p>Assim, resumidamente, nosso tipo <code>bestPrices</code> é um vetor de <code>date</code>, <code>available</code> e <code>price</code>:</p>
<pre><code class="language-json">{
    &quot;date&quot;:&quot;2020-07-24&quot;,
    &quot;available&quot;:true,
    &quot;price&quot;:{
        &quot;amount&quot;:99.03
    }
}
</code></pre>
<p>Para este Json vamos precisar da crate <code>serde</code>, basta adicionar ela no <code>Cargo.toml</code>, pois vamos precisar Serializar e Deserializar as informações do response neste momento. Depois, precisamos adicionar as informações básicas da response <code>{&quot;data&quot;:{ &quot;bestPrices&quot;:{ ... }}}</code>, faremos isso com as seguintes structs no módulo <code>gql</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::best_prices::BestPrices;
// ...
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct GqlResponse {
    data: GqlFields
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct GqlFields {
    best_prices: BestPrices
}
<span class="boring">}
</span></code></pre></pre>
<p>Como já expliquei Serde na parte anterior, não vou entrar em detalhes de novo. Agora, precisamos implementar a struct <code>BestPrices</code> no novo módulo <code>best_prices</code>, que conterá as seguintes structs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct BestPrices {
    best_prices: Vec&lt;BestPrice&gt;
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct BestPrice {
    date: String,
    available: bool,
    price: Option&lt;Price&gt;
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Price {
    amount: f64
}
<span class="boring">}
</span></code></pre></pre>
<p>Por último, precisamos modificar <code>Airline</code> para converter o tipo <code>graphql_response</code> em <code>Option&lt;GqlResponse&gt;</code> e atualizar o update para que ele faça a transformação de <code>String</code> para <code>GqlResponse</code> através da função <code>serde_json::from_str(&amp;val).unwrap()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
    Msg::FetchGql(data) =&gt; {
        self.graphql_response = match data {
            Some(Ok(val)) =&gt; {
                self.fetching = false;
                let resp: GqlResponse = from_str(&amp;val).unwrap();
                Some(resp)
            },
            _ =&gt; {
                self.fetching = false;
                None
            }
        }
    },
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Nossa view reclará de tipos incompatíveis agora, para isso, vamos apenas utilizar a função <code>serde_json::to_string</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(data) = &amp;self.graphql_response {
    serde_json::to_string(data).unwrap()
} else {
    &quot;Failed to fetch&quot;.to_string()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="construindo-a-view-de-bestprices"><a class="header" href="#construindo-a-view-de-bestprices">Construindo a <code>view</code> de <code>BestPrices</code></a></h2>
<p>A primeira mudança que vamos fazer é adicionar uma animação de <code>loading</code> no lugar do texto, para isso vamos adicionar um css no caminho <code>static/styles.css</code> e incluir isso no <code>index.html</code>:</p>
<pre><code class="language-html">&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;
        &lt;title&gt;Yew Sample App&lt;/title&gt;
        &lt;script type=&quot;module&quot;&gt;
            import init from &quot;./wasm.js&quot;
            init()
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-css">.loading-margin {
    margin: 25rem;
}

.loader {
    border: 1.25rem solid #f3f3f3; /* Light grey */
    border-top: 1.25rem solid #03253b; /* Blue */
    border-radius: 50%;
    width: 12.5rem;
    height: 12.5rem;
    animation: spin 2s linear infinite;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</code></pre>
<p>E adicionar os estilos no <code>view</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; Html {
    if self.fetching {
        html! {
            &lt;div class=&quot;loading-margin&quot;&gt;
                &lt;div class=&quot;loader&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
        } 
    } // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos implementar a função <code>view</code> para <code>BestPrices</code>, que será basicamente um carrousel com várias células centralizadas, conforme a imagem a seguir e seu css correspondente:</p>
<p><img src="part-3/../imagens/carrousel.png" alt="Carrosel de Best Prices" /></p>
<pre><code class="language-css">/* ... */
.body {
    width: 80%;
    text-align: center;
  }

  .carrousel {
    transform: translate(10%, 50%);
    display: table-row;
}

.cell {
    text-align: center;
    vertical-align: middle;
    font-size: medium;
    height: 100%;
    width: 15rem;
    display: table-cell;
    border: 1px solid lightgrey;
}

.empty-cell {
    padding: 2rem 1rem;
    background-color: #e1e1e1;
}

.full-cell {
    padding: 2rem 1rem;
    background-color: #f1f0f0;
}
</code></pre>
<p>A função <code>view</code> será uma implementação da struct <code>BestPrices</code> e fará uma iteração sob cada um dos 7 elementos do vetor. Note que os dias que vierem com <code>available = false</code>, também virão com <code>price = None</code> e precisamos tratar este caso também. Começamos com algo bem simples como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BestPrices {
    pub fn view(&amp;self) -&gt; VNode {
        let carrousel = format!(&quot;De frente para este {:?}&quot;, &quot;carrosel&quot;);

        html!{
            &lt;div class=&quot;carrousel&quot;&gt; 
                {carrousel}
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Neste caso, o que fizemos foi criar uma implementação pública de <code>BestPrices</code> da função <code>view</code> que retorna um <code>VNode</code>, que é basicamente um nodo virtual deste HTML que está sendo gerado. a variável <code>carrousel</code> está englobada por uma classe css chamada <code>.carrousel</code> que translada o carrosel para baixo e para o meio e transforma-se em uma linha de tabela, <code>table-row</code>. Depois disso, podemos chamar esta função no nosso <code>app</code> com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; Html {
    if self.fetching {
        html! {
            &lt;div class=&quot;loading-margin&quot;&gt;
                &lt;div class=&quot;loader&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
        } 
    } else {
        html! {
            &lt;div class=&quot;body&quot;&gt;
                { 
                    if let Some(data) = &amp;self.graphql_response {
                        data.clone().best_prices().view()
                    } else {
                        html!{
                            &lt;p class=&quot;failed-fetch&quot;&gt;
                                {&quot;Failed to fetch&quot;}
                            &lt;/p&gt;
                        }
                    }
                }
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Antecedendo a chamada da <code>view</code> criei uma função que encurta o retorno do campo <code>best_prices</code>, do tipo <code>BestPrices</code>, e evita que ele seja público. Essa fução pode ser encontrada no módulo <code>gql</code> da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl GqlResponse {
    pub fn best_prices(self) -&gt; BestPrices {
        self.data.best_prices
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>O próximo passo é é transforma a variável <code>carrousel</code> em uma lista de <code>Vec&lt;HTML&gt;</code> para podermos renderizá-la conforme o exercício. Para isso, vamos pegar o valor de <code>self.best_prices</code> e iterar sobre ele aplicando um map que transforma cada <code>Best_rice</code> em um <code>Html</code> da seguinte forma <code>self.best_prices.into_iter().map(|bp| html!{...}).collect::&lt;Html&gt;()</code>. Quanto ao <code>map</code> precisamos definir qual tipo de célula utilizar, especialmente por conta do campo <code>price</code> que é <code>Option</code>, faremos isso com a propriedade <code>bp.available</code>. Se <code>bp.available</code> for <code>true</code>, criamos uma célula cheia com as propriedades de data e preço, se for <code>false</code> criamos uma célula vazia com a propriedade de data e uma indição de preço indisponível como <code>N/A</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.map(|bp| html!{
    &lt;div class=&quot;cell&quot;&gt;
        {
            if bp.available {
                html!{
                    &lt;div class=&quot;full-cell&quot;&gt;
                        {
                            {
                                let date = Utc.datetime_from_str(&amp;format!(&quot;{} 00:00:00&quot;, bp.date), &quot;%Y-%m-%d %H:%M:%S&quot;);
                                date.unwrap().format(&quot;%a %e %b&quot;).to_string()
                            }
                        } &lt;br/&gt;
                        {format!(&quot;R$ {}&quot;, bp.price.unwrap().amount).replace(&quot;.&quot;, &quot;,&quot;)}
                    &lt;/div&gt;
                }
            } else {
                html!{
                    &lt;div class=&quot;empty-cell&quot;&gt;
                        { 
                            {
                                let date = Utc.datetime_from_str(&amp;format!(&quot;{} 00:00:00&quot;, bp.date), &quot;%Y-%m-%d %H:%M:%S&quot;);
                                date.unwrap().format(&quot;%a %e %b&quot;).to_string()
                            }
                         } &lt;br/&gt;
                        {&quot;N/A&quot;}
                    &lt;/div&gt;
                }
            }
        }
    &lt;/div&gt;
})
<span class="boring">}
</span></code></pre></pre>
<p>Nosso <code>map</code> tem a seguinte aparência, uma célula externa que possui as configurações globais pra todas as células, classe <code>.cell</code>, que define tamanho, alinhamento e comportamento de display do tipo célula de tabela, <code>table-cell</code>. Dentro da célula aplicamos um <code>if/else</code> dependendo se o <code>BestPrice</code> está available ou não. Para o casa de <code>available = false</code> retornamos uma célula somente com a data, formatada, e um valor indicando a ausência de preços, <code>N/A</code>, ambos separados por uma quebra de linha <code>&lt;br/&gt;</code>. O estilo desta célula será <code>empty-cell</code>, que é basicamente uma célula mais escura que a célula padrão.</p>
<p>O padrão de data que estamos utilizando é o mesmo do site, que indica o dia da semana seguido pelo dia do mês e o mês correspondente. Para podermos fazer essa modificação vamos utilizar a crate <code>chrono = &quot;0.4.11&quot;</code> importando ela no módulo <code>best_prices</code> com <code>use chrono::prelude::*;</code>. A data que recebemos do <code>best_prices</code> está no formato <code>ano-mes-dia</code> e para fazermos o <code>parse</code> para o <code>Utc</code> precisamos dp formato <code>ano-mes-dia hora:min:seg</code>, e fazemos esta modificação utilizando a macro <code>format!</code>, <code>format!(&quot;{} 00:00:00&quot;, bp.date)</code>. Com isso, teremos o formato <code>&quot;%Y-%m-%d %H:%M:%S&quot;</code> que nos permitirá utilizar a função <code>Utc.datetime_from_str</code> para executar o <code>parse</code> da nossa data, <code>bp.date</code>. Com o resultado desta transformação podemos formatar a <code>date</code> no padrão <code>dia-da-semana dia-do-mes mes</code>, <code>&quot;%a %e %b&quot;</code>.</p>
<p>Para o caso <code>available = true</code> utilizamos o mesmo padrão de formatação de data, mas em vez de utilizar <code>N/A</code> vamos formatar o valor de <code>bp.price</code> para incluir <code>R$</code> e trocar <code>.</code> por <code>,</code>, <code>format!(&quot;R$ {}&quot;, bp.price.unwrap().amount).replace(&quot;.&quot;, &quot;,&quot;)</code>.</p>
<p>Nosso próximo passo é compor todas as recomendações.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="componente-de-recomendações"><a class="header" href="#componente-de-recomendações">Componente de Recomendações</a></h1>
<p>A query que vamos utilizar neste capítulo será a de <code>recommendations</code>, que contém muitas mais informações que a de <code>best_prices</code>, mas será útil para compor os componentes faltantes. A baixo a query de <code>recommendations</code>:</p>
<pre><code class="language-graphql">{
recommendations(departure: &quot;2020-06-28&quot;, 
    origin: &quot;POA&quot;, 
    destination: &quot;GRU&quot;) {
    data{
      recommendedFlightCode
      flights {
        flightCode
        flightDuration
        stops
        arrival {
          cityName
          airportName
          airportCode
          dateTime
        }
        departure {
          cityName
          airportName
          airportCode
          dateTime
        }
        segments {
          flightNumber
          equipment {
            name
            code
          }
        }
        cabins {
          code
          displayPrice
          availabilityCount
        }
      }
    }
  }
}
</code></pre>
<p>Adicionamos esta query a função <code>fetch_gql</code> que executará ambas as queries simultaneamente. E já modificamos a struct <code>GqlField</code> para conter o campo <code>recommendations</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fetch_gql() -&gt; Value {
    json!({
        &quot;query&quot;: &quot;{
            recommendations(departure: \&quot;2020-06-28\&quot;, 
                origin: \&quot;POA\&quot;, 
                destination: \&quot;GRU\&quot;) {
                data{
                recommendedFlightCode
                flights {
                    flightCode
                    flightDuration
                    stops
                    arrival {
                        cityName
                        airportName
                        airportCode
                        dateTime
                    }
                    departure {
                        cityName
                        airportName
                        airportCode
                        dateTime
                    }
                    segments {
                    flightNumber
                    equipment {
                        name
                        code
                    }
                    }
                    cabins {
                        code
                        displayPrice
                        availabilityCount
                    }
                }
                }
            }
            bestPrices(departure: \&quot;2020-06-28\&quot;, origin: \&quot;POA\&quot;, destination: \&quot;GRU\&quot;) {
                bestPrices {
                    date
                    available
                    price {amount}
                }
             }
        }&quot;
    })
}


#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct GqlFields {
    best_prices: BestPrices,
    recommendations: Recommendations,
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta query retorna o seguinte Json:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;recommendations&quot;: {
      &quot;data&quot;: [
        {
          &quot;recommendedFlightCode&quot;: &quot;LA3068&quot;,
          &quot;flights&quot;: [
            {
              &quot;flightCode&quot;: &quot;LA3068&quot;,
              &quot;flightDuration&quot;: &quot;PT1H35M&quot;,
              &quot;stops&quot;: 0,
              &quot;arrival&quot;: {
                &quot;cityName&quot;: &quot;São Paulo&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;dateTime&quot;: &quot;2020-06-28T22:15-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;cityName&quot;: &quot;Porto Alegre&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;dateTime&quot;: &quot;2020-06-28T20:40-03:00&quot;
              },
              &quot;segments&quot;: [
                {
                  &quot;flightNumber&quot;: &quot;3068&quot;,
                  &quot;equipment&quot;: {
                    &quot;name&quot;: &quot;Airbus 320-200&quot;,
                    &quot;code&quot;: &quot;320&quot;
                  }
                }
              ],
              &quot;cabins&quot;: [
                {
                  &quot;code&quot;: &quot;Y&quot;,
                  &quot;displayPrice&quot;: 582.03,
                  &quot;availabilityCount&quot;: 33
                },
                {
                  &quot;code&quot;: &quot;W&quot;,
                  &quot;displayPrice&quot;: 1072.03,
                  &quot;availabilityCount&quot;: 9
                }
              ]
            },
            {
              &quot;flightCode&quot;: &quot;LA3297&quot;,
              &quot;flightDuration&quot;: &quot;PT1H40M&quot;,
              &quot;stops&quot;: 0,
              &quot;arrival&quot;: {
                &quot;cityName&quot;: &quot;São Paulo&quot;,
                &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
                &quot;airportCode&quot;: &quot;GRU&quot;,
                &quot;dateTime&quot;: &quot;2020-06-28T10:45-03:00&quot;
              },
              &quot;departure&quot;: {
                &quot;cityName&quot;: &quot;Porto Alegre&quot;,
                &quot;airportName&quot;: &quot;Salgado Filho&quot;,
                &quot;airportCode&quot;: &quot;POA&quot;,
                &quot;dateTime&quot;: &quot;2020-06-28T09:05-03:00&quot;
              },
              &quot;segments&quot;: [
                {
                  &quot;flightNumber&quot;: &quot;3297&quot;,
                  &quot;equipment&quot;: {
                    &quot;name&quot;: &quot;Airbus 320-200&quot;,
                    &quot;code&quot;: &quot;320&quot;
                  }
                }
              ],
              &quot;cabins&quot;: [
                {
                  &quot;code&quot;: &quot;Y&quot;,
                  &quot;displayPrice&quot;: 842.03,
                  &quot;availabilityCount&quot;: 1
                },
                {
                  &quot;code&quot;: &quot;W&quot;,
                  &quot;displayPrice&quot;: 1137.03,
                  &quot;availabilityCount&quot;: 4
                }
              ]
            }
          ]
        }
      ]
    }
  }
}
</code></pre>
<p>Ou seja, nosso backend retornará um campo <code>data</code>, que pode ser um array vazio, pois pode retornar sem voos. O campo data por sua vez, retornará uma estrutura de <code>RecommendedFLights</code> que é um vetor com o voo recomendado, <code>recommendedFlightCode</code>, e todos os possíveis voos em <code>flights</code>. No primeiro momento, vamos focar apenas a estrutura do seguinte Json:</p>
<pre><code class="language-json">{
    &quot;flightCode&quot;: &quot;LA3068&quot;,
    &quot;flightDuration&quot;: &quot;PT1H35M&quot;,
    &quot;stops&quot;: 0,
    &quot;arrival&quot;: {
        &quot;cityName&quot;: &quot;São Paulo&quot;,
        &quot;airportName&quot;: &quot;Guarulhos Intl.&quot;,
        &quot;airportCode&quot;: &quot;GRU&quot;,
        &quot;dateTime&quot;: &quot;2020-06-28T22:15-03:00&quot;
    },
    &quot;departure&quot;: {
        &quot;cityName&quot;: &quot;Porto Alegre&quot;,
        &quot;airportName&quot;: &quot;Salgado Filho&quot;,
        &quot;airportCode&quot;: &quot;POA&quot;,
        &quot;dateTime&quot;: &quot;2020-06-28T20:40-03:00&quot;
    },
}
</code></pre>
<h2 id="modelando-recommendations-1"><a class="header" href="#modelando-recommendations-1">Modelando Recommendations</a></h2>
<p>A  modelagem do domínio vai seguir o mesmo formato do capítulo anterior e da parte anterior, assim podemos resumir a modelagem de <code>Recommendations</code> inicialmente da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Recommendations {
    data: Vec&lt;RecommendedFlight&gt;
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct RecommendedFlight {
    recommended_flight_code: String,
    flights: Vec&lt;Flight&gt;
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Flight {
    flight_code: String,
    flight_duration: String,
    stops: i32,
    arrival: OriginDestination,
    departure: OriginDestination,
    segments: Vec&lt;Segment&gt;
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct OriginDestination {
    city_name: String,
    airport_name: String,
    airport_code: String,
    date_time: String,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Segment { 
    flight_number: String,
    equipment: Equipment
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Equipment { 
    name: String,
    code: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos começar a implementar o componente da struct <code>Recommendations</code>.</p>
<h2 id="implementando-a-view-para-recommendations"><a class="header" href="#implementando-a-view-para-recommendations">Implementando a <code>view</code> para <code>Recommendations</code></a></h2>
<p>Para este componente vamos utilizar uma forma diferente de criação de <code>view</code>, pois vamos passar as propriedades do nível de superior para que está view gerencie elas. Isso nos permitirá alterar o estado da aplicação de dentro do nosso componente de <code>Recommendations</code>. Agora, na implementação da struct <code>GqlResponse</code> precisamos adicionar uma função que facilite acesso ao campo privado <code>recommendations</code>, fazemos isso com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl GqlResponse {
    pub fn best_prices(self) -&gt; BestPrices {
        self.data.best_prices
    }

    pub fn recommendations(self) -&gt; Recommendations {
        self.data.recommendations
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com isso, podemos chamar a mesma estratégia que usamos com <code>best_prices</code> e chamar a função <code>view</code> de <code>Recommendations</code> dentro da <code>view</code> de <code>Airline</code>. Para podemos chamar dois componentes <code>Html</code> dentro de outro, vamos preciisar separar em várias <code>div</code>s, pois cada conjunto de tag permiite a utilização de apenas um <code>Html</code> do <code>yew</code>. fazemos isso modificandoa  função <code>view</code> de <code>app.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; Html {
    if self.fetching {
        html! {
            &lt;div class=&quot;loading-margin&quot;&gt;
                &lt;div class=&quot;loader&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
        } 
    } else {
        html! {
            &lt;div class=&quot;body&quot;&gt;
                { 
                    if let Some(data) = &amp;self.graphql_response {
                        html!{&lt;div&gt;
                            &lt;div&gt; {data.clone().best_prices().view()} &lt;/div&gt;
                            &lt;div&gt; { data.clone().recommendations().view() } &lt;/div&gt;
                          &lt;/div&gt; }
                    } else {
                        html!{
                            &lt;p class=&quot;failed-fetch&quot;&gt;
                                {&quot;Failed to fetch&quot;}
                            &lt;/p&gt;
                        }
                    }
                }
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos definir a função <code> view</code> para a struct <code>Recommendations</code>, que será invocada em <code>app.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Recommendations {
    pub fn view(&amp;self) -&gt; Html {
      html!{
          &lt;div class=&quot;flight-container&quot;&gt; {
              self.data[0].clone().flights.into_iter()
              .map(|r|
                  html!{
                      &lt;div class=&quot;flight&quot;&gt; 
                          {&quot;Hello from flights&quot;}
                      &lt;/div&gt;
                  }
              )
              .collect::&lt;Html&gt;()
          }
          &lt;/div&gt;}
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="compondo-a-view"><a class="header" href="#compondo-a-view">Compondo a <code>view</code></a></h3>
<p>Anteriormente descrevemos a função <code>view</code> da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn view(&amp;self) -&gt; Html {
  html!{
      &lt;div class=&quot;flight-container&quot;&gt; {
          self.data[0].clone().flights.into_iter()
          .map(|r|
              html!{
                  &lt;div class=&quot;flight&quot;&gt; 
                      // ...
                  &lt;/div&gt;
              }
          )
          .collect::&lt;Html&gt;()
      }
      &lt;/div&gt;}
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que gostaria de salientar é a presenção do <code>clone</code> logo após acessarmos o vetor com <code>[0]</code>, isso se deve ao fato de que temos apenas a referência de um valor, que não vai nos possibilitar executar o <code>move</code> para a macro, conforme o erro a seguir:</p>
<pre><code>  --&gt; src/reccomendation.rs:74:17
   |
74 |                 self.data[0].flights.into_iter()
   |                 ^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `std::vec::Vec&lt;reccomendation::Flight&gt;`, which does not implement the `Copy` trait
   |
</code></pre>
<p>A criação do <code>flight-container</code> é algo bastante simples, pois basta incluirmos a <code>div</code> dentro da macro <code>html!</code>, mas dentro do container precisamos iterar sobre cada um dos voos utilizando <code>self.data[0].clone().flights.into_iter()</code>. Note que o campo <code>data</code> poderia ser <code>Option</code> e neste caso deveriamos utilizar um <code>if let Some(flights)</code> para extrair valor de <code>Some(flights)</code>, ou poderia ser um vetor vazio, e neste caso seriia melhor utilizar a função <code>first</code> e aplicar um <code>match</code>. Uma vez que temos nosso <code>into_iter</code> podemos applicar um <code>map</code> que vai criar nossos <code>Htmls</code>, para depois colecionarmos em um <code>collect::&lt;Html&gt;()</code>. Nosso <code>map</code> começa com um <code>html!</code> que cria a div correspondete a todo o bloco com informações do voo, conforme a imagem a seguir:</p>
<p><img src="part-3/../imagens/flights.png" alt="Componente com cada uma das recomendações de voo" /></p>
<p>O css para está parte é este:</p>
<pre><code class="language-css">
.flight-container {
  width: 70%;
  margin-top: 5rem;
  transform: translate(35%, 0%);
  background-color: #f1f0f0;
}

.flight {
  display: table-row;
  border: 1px solid lightgrey;
}

.flight-cell {
  padding: 2rem 1rem;
  display: table-cell;
  border-bottom: 1px solid lightgray;
}

.origins-destinations {
  width: 22rem;
  display: flex;
}

.arrow {
  font-size: 30px;
  font-weight: bold;
  color: red;
  margin-left: 2rem;
  margin-right: 2rem;
}

.origin-destination {
  font-size: 26px;
  display: flex;
}

.time {
  font-weight: bold;
  color: black;
}

.airport {
  color: rgb(75, 74, 74);
  margin-left: 1rem;
}

.duration {
  padding: 1rem 2rem;
  font-size: 20px;
  color: gray;
}

.stops {
  padding: 1rem 2rem;
  font-size: 20px;
  color: blue;
}

.price {
  font-size: 26px;
  font-weight: bold;
  padding: 1rem 2rem;
  margin-left: 1rem;
  border-left: 1px groove lightgray;
}
</code></pre>
<p>Assim, podemos começar a implementar cada uma das células que formam um voo. Fazemos isso utilizando várias <code>div</code>s com suas configurações definidas no CSS:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;div class=&quot;flight&quot;&gt; 
    &lt;div class=&quot;flight-cell origins-destinations&quot;&gt;
        &lt;div class=&quot;origin-destination&quot;&gt; 
            &lt;div class=&quot;time&quot;&gt; {{
                let date = Utc.datetime_from_str(&amp;r.departure.date_time[..16],&quot;%Y-%m-%dT%H:%M&quot;);
                date.unwrap().format(&quot;%H:%M&quot;).to_string()
            }} &lt;/div&gt;
            &lt;div class=&quot;airport&quot;&gt; {r.departure.airport_code} &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;arrow&quot;&gt;{&quot;&gt;&quot;}&lt;/div&gt;
        &lt;div class=&quot;origin-destination&quot;&gt;
            &lt;div class=&quot;time&quot;&gt; {{
                let date = Utc.datetime_from_str(&amp;r.arrival.date_time[..16],&quot;%Y-%m-%dT%H:%M&quot;);
                date.unwrap().format(&quot;%H:%M&quot;).to_string()
            }} &lt;/div&gt;
            &lt;div class=&quot;airport&quot;&gt; {r.arrival.airport_code} &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;flight-cell duration&quot;&gt; {
        r.flight_duration.replace(&quot;PT&quot;,&quot;&quot;).replace(&quot;H&quot;, &quot;h &quot;).replace(&quot;M&quot;, &quot;min&quot;)
    } &lt;/div&gt;
    &lt;div class=&quot;flight-cell stops&quot;&gt; {
        if r.stops == 0 {
            html!{&lt;p&gt;{&quot;Direto&quot;}&lt;/p&gt;}
        } else {
            html!{&lt;p&gt;{r.stops.to_string()}&lt;/p&gt;}
        }   
    } &lt;/div&gt;
    &lt;div class=&quot;flight-cell price&quot;&gt; {&quot;R$ 582,03&quot;}&lt;/div&gt;
&lt;/div&gt;
<span class="boring">}
</span></code></pre></pre>
<p>A primeira célula, <code>origins-destinations</code>, possui três grandes campos, origem, seta e destino. Origem e destino são iguais em organizacão, mudando apenas o campo para acessar as iinformações de oirgem, <code>departuure</code>, e de destino, <code>arrival</code>. Existe uma pegadiinha no tiipo <code>date_time</code>, que torna parsear ele um pouco complicado para um  parser normal, pois ele não apresenta o campo de  segundos no horário, mas apresenta o timezone <code>-3:00</code>. A forma como podemos lidar com isso é enviando um formater que vai parsear apenas a parte da String de <code>dataTime</code> que temos controle, <code>&quot;%Y-%m-%dT%H:%M&quot;</code>, ou seja, os 16 primeiros caracteres, por isso do slice <code>r.departure.date_time[..16]</code>.</p>
<p>Nos campos faltantes, vamos aplicar algumas funções para alterar seu valor. Por exemplo, o campo <code>flight_duration</code> aparece no formato <code>PT1H40M</code>, mas queremos exibir o formato <code>1h 40min</code>, por isso removemos <code>PT</code>, fazemos o replace de <code>H</code> por <code>h </code> e modificamos <code>M</code> para <code>min</code>. Quanto ao campo <code>stops</code>, a úncia coisa que precisamos garantir é que se a quantidade for zero, vamos escrever <code>Direto</code>, caso não for, mostramos quantas escalas são. O preço veremos a seguir.</p>
<h2 id="introduzindo-cabines"><a class="header" href="#introduzindo-cabines">Introduzindo cabines</a></h2>
<p>O objetivo de introduzir <code>cabins</code> é podermos exibir diferentes preços para diferentes conjuntos de Voos. No exemplo que estamos utilizando possuimos dois tipos de <code>cabin</code>, a <code>Y</code> que corresponde a classe <code>economy</code> e a <code>W</code> que corresponde a <code>premium economy</code>. Para utilizarmos <code>cabins</code> vamos precisar criar o modelo para <code>cabins</code> dentro da struct <code>Flight</code>. O Json correspondente é:</p>
<pre><code class="language-json">{&quot;cabins&quot;: [
    {
      &quot;code&quot;: &quot;Y&quot;,
      &quot;displayPrice&quot;: 842.03,
      &quot;availabilityCount&quot;: 1
    },
    {
      &quot;code&quot;: &quot;W&quot;,
      &quot;displayPrice&quot;: 1137.03,
      &quot;availabilityCount&quot;: 4
    }
  ]
}
</code></pre>
<p>Com isso, podemos notar que o campo <code>cabins</code> é bastante simples, pois é composto por um vetor de <code>Cabin</code> que pode ser definida da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Properties, Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = &quot;camelCase&quot;)]
pub struct Cabin { 
    code: String,
    display_price: f64,
    availability_count: i32
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos filtrar os voos pela <code>Cabin</code> com <code>code</code> igual a <code>Y</code> para exibirmos o <code>display_price</code>, caso a contagem de assentos, <code>availability_count</code>, seja maior que zero. Para fazermos isso precisamos adicionar o campo de filtro no estado de <code>Airline</code>. Isso pode ser feito da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Airline {
    // ...
    graphql_response: Option&lt;GqlResponse&gt;,
    filter_cabin: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>E adicionar este campo nos obriga a adicionar um valor padrão na função <code>create</code> de <code>Airline</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create(_: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {
    Airline {
        fetch: FetchService::new(),
        link: link,
        fetch_task: None,
        fetching: true,
        graphql_url: &quot;http://localhost:4000/graphql&quot;.to_string(),
        graphql_response: None,
        filter_cabin: String::from(&quot;Y&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com isso, precisamos definir uma mensagem para executar <code>updates</code>. Essa mensagem definiremos como <code>Cabin(String)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Msg {
    FetchGql(Option&lt;Text&gt;),
    Fetching(bool),
    Cabin(String)
}
<span class="boring">}
</span></code></pre></pre>
<p>E precisamos definir como o update vai se comportar quando receber a mensagem <code>Cabin</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
  match msg {
      Msg::FetchGql(data) =&gt; {
          // ...
      },
      Msg::Fetching(fetch) =&gt; {
          self.fetching = fetch;
      },
      Msg::Cabin(c) =&gt; {
          self.filter_cabin = c
      }
  }
  true
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, nosso <code>update</code> vai atualizar o campo <code>filter_cabin</code> com o valor recebido dentro da mensagem <code>Cabin</code>. O próximo passo seria enviar para a função <code>view</code> de <code>Recommendations</code> o <code>ComponentLink&lt;Airline&gt;</code> e o <code>filter_cabin</code> como referências emprestadas, fazemos isso utilizando o <code>&amp;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; Html {
    if self.fetching {
       // ...
    } else {
        html! {
            &lt;div class=&quot;body&quot;&gt;
                { 
                    if let Some(data) = &amp;self.graphql_response {
                        html!{&lt;div&gt;
                            &lt;div&gt; {data.clone().best_prices().view()} &lt;/div&gt;
                            &lt;div&gt; { data.clone().recommendations().view(&amp;self.link, 
                                        &amp;self.filter_cabin) } &lt;/div&gt;
                          &lt;/div&gt; }
                    } else {
                        // ...
                    }
                }
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora que sabemos o que devemos passar para a <code>view</code>  de <code>Recommendations</code> podemos atualizar a funcão com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::app::{Airline, Msg};
// ...


impl Recommendations {
    pub fn view(&amp;self, link: &amp;ComponentLink&lt;Airline&gt;, filter_cabin: &amp;str) -&gt; Html {
        html!{
            &lt;div&gt;
                &lt;div class=&quot;cabins&quot;&gt;
                    &lt;div class=&quot;cabin&quot; onclick=link.callback(move |_| Msg::Cabin(&quot;Y&quot;.to_string()))&gt;
                        {&quot;Economy&quot;}&lt;/div&gt;
                    &lt;div class=&quot;cabin&quot; onclick=link.callback(move |_| Msg::Cabin(&quot;W&quot;.to_string()))&gt;
                        {&quot;Premium Economy&quot;}&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;flight-container&quot;&gt; {
                    self.data[0].clone().flights.into_iter()
                    .map(|r|
                        html!{
                            &lt;div class=&quot;flight&quot;&gt; 
                                &lt;div class=&quot;flight-cell origins-destinations&quot;&gt;
                                    &lt;div class=&quot;origin-destination&quot;&gt; 
                                        &lt;div class=&quot;time&quot;&gt; {{
                                            let date = Utc.datetime_from_str(&amp;r.departure.date_time[..16],&quot;%Y-%m-%dT%H:%M&quot;);
                                            date.unwrap().format(&quot;%H:%M&quot;).to_string()
                                        }} &lt;/div&gt;
                                        &lt;div class=&quot;airport&quot;&gt; {r.departure.airport_code} &lt;/div&gt;
                                    &lt;/div&gt;
                                    &lt;div class=&quot;arrow&quot;&gt;{&quot;&gt;&quot;}&lt;/div&gt;
                                    &lt;div class=&quot;origin-destination&quot;&gt;
                                        &lt;div class=&quot;time&quot;&gt; {{
                                            let date = Utc.datetime_from_str(&amp;r.arrival.date_time[..16],&quot;%Y-%m-%dT%H:%M&quot;);
                                            date.unwrap().format(&quot;%H:%M&quot;).to_string()
                                        }} &lt;/div&gt;
                                        &lt;div class=&quot;airport&quot;&gt; {r.arrival.airport_code} &lt;/div&gt;
                                    &lt;/div&gt;
                                &lt;/div&gt;
                                &lt;div class=&quot;flight-cell duration&quot;&gt; {
                                    r.flight_duration.replace(&quot;PT&quot;,&quot;&quot;).replace(&quot;H&quot;, &quot;h &quot;).replace(&quot;M&quot;, &quot;min&quot;)
                                } &lt;/div&gt;
                                &lt;div class=&quot;flight-cell stops&quot;&gt; {
                                    if r.stops == 0 {
                                        html!{&lt;p&gt;{&quot;Direto&quot;}&lt;/p&gt;}
                                    } else {
                                        html!{&lt;p&gt;{r.stops.to_string()}&lt;/p&gt;}
                                    }   
                                } &lt;/div&gt;
                                &lt;div class=&quot;flight-cell price&quot;&gt; {{
                                    let cabin = r.cabins.into_iter()
                                        .filter(|c| c.availability_count &gt; 0 &amp;&amp; &amp;c.code == filter_cabin)
                                        .collect::&lt;Vec&lt;Cabin&gt;&gt;();
                                    match cabin.first() {
                                        Some(c) =&gt; format!(&quot;R$ {:?}&quot;, c.display_price),
                                        None =&gt; String::from(&quot;N/A&quot;)
                                    }
                                }}&lt;/div&gt;
                            &lt;/div&gt;
                        }
                    )
                    .collect::&lt;Html&gt;()
                }
                &lt;/div&gt;
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Os estilos do código anterior são:</p>
<pre><code class="language-css">.cabins {
  text-align: center;
  vertical-align: middle;
  color: rgb(110, 110, 110);
  display: table-row;
  transform: translate(195%, 185%);
  font-size: 20px;
}

.cabin {
  display: table-cell;
  border: 1px solid gray;
  padding: 9px 12px;
}
</code></pre>
<p>A primeira mudança que vamos entender é a adição do <code>display_price</code> para a <code>Cabin</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;div class=&quot;flight-cell price&quot;&gt; {{
    let cabin = r.cabins.into_iter()
        .filter(|c| c.availability_count &gt; 0 &amp;&amp; &amp;c.code == filter_cabin)
        .collect::&lt;Vec&lt;Cabin&gt;&gt;();
    match cabin.first() {
        Some(c) =&gt; format!(&quot;R$ {:?}&quot;, c.display_price),
        None =&gt; String::from(&quot;N/A&quot;)
    }
}}&lt;/div&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Iteramos sobre o valor de <code>cabins</code> com <code>r.cabins.into_iter()</code> que nos permite aplicar um <code>filter</code> para garantir que os voos estão disponíveis, <code>c.availability_count &gt; 0</code> e para garantir q o código da <code>cabin</code>, <code>c.code</code>, é igiual ao <code>filter_cabin</code> que enviamos, <code>&amp;c.code == filter_cabin</code>. Depois, coletamos os calores filtrados com <code>.collect::&lt;Vec&lt;Cabin&gt;&gt;()</code>. Este vetor de <code>Cabin</code> deve conter no máximo um elemento, assim aplicar um <code>first</code> é uma forma segura de garantir que não vamos perder valores. Aplicando um <code>match</code> em <code>abin.first()</code> lidamos com o fato de que podemos não ter uma <code>cabin</code> disponível para aquelec código, retornando <code>String::from(&quot;N/A&quot;)</code>. Para o caso de termos um <code>Some</code> com valor de <code>cabin</code> executamos um <code>format</code> para disponibilizar o valor da passagem, <code>Some(c) =&gt; format!(&quot;R$ {:?}&quot;, c.display_price)</code>.</p>
<p>O próximo passo é criar os <code>links</code> de <code>callbacks</code> que alterem o estado da aplicação:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;div class=&quot;cabins&quot;&gt;
    &lt;div class=&quot;cabin&quot; onclick=link.callback(move |_| Msg::Cabin(&quot;Y&quot;.to_string()))&gt;
        {&quot;Economy&quot;}&lt;/div&gt;
    &lt;div class=&quot;cabin&quot; onclick=link.callback(move |_| Msg::Cabin(&quot;W&quot;.to_string()))&gt;
        {&quot;Premium Economy&quot;}&lt;/div&gt;
&lt;/div&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Criamos uma <code>div</code> que possui as duas cabines que conhecemos, <code>Economy</code> e <code>Premium Economy</code>, dentro de suas prórpias <code>div</code>s. Cada uma das <code>dvi</code>s  vai ter um <code>callback</code> com JavScript  para alterar o estado de <code>fiilter_cabin</code>. Fazemos isso adicionando <code>onclick=link.callback(move |_| Msg::Cabin(&quot;Y&quot;.to_string()))</code> a <code>div</code> de <code>Economy</code> e <code>onclick=link.callback(move |_| Msg::Cabin(&quot;W&quot;.to_string()))</code> a <code>div</code> de <code>Premium Economy</code>.</p>
<p>Nosso próximo passo é defiiniir uma forma de receber os parâmetros da query GraphQL via rota da URL e que possamos atualizar esses dados de forma a executar um novo request com os novos parâmetros.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aplicando-um-router"><a class="header" href="#aplicando-um-router">Aplicando um Router</a></h1>
<p>Neste capítulo vamos aprender a utilizar o <code>Router</code> da <code>YewStack</code>, pois <code>Routers</code> em <em>Single Page Apps</em> (SPA)manipulam a exibição de entidades diferentes, dependendo da <code>URL</code>. Em vez do comportamento padrão de solicitar um recurso remoto diferente quando um link é clicado, o roteador define a URL localmente para apontar para uma rota válida em seu aplicativo. O roteador detecta essa alteração e decide o que renderizar.</p>
<p>Vamos utilizar o <code>YewRouter</code>, adicionando <code>yew-router = &quot;0.13.0&quot;</code> ao <code>Cargo.toml</code>. o <code>YewRouter</code> possui alguns elementos centrais que valem mencionar:</p>
<ul>
<li><code>Route</code>: Contém uma <code>String</code> contendo tudo que aparece após o domínio na <code>URL</code>.</li>
<li><code>RouteService</code>: Comunica com o brrowser para receber e enviar as <code>Routes</code>.</li>
<li><code>RouteAgent</code>: Dono do <code>RouteService</code> e é usado para coordenar os updates quando as rotas mudam, tanto dentro da aplicação quanto por eventos do browser.</li>
<li><code>Switch</code>: É uma trait utilizada na conversão de <code>Route</code>.</li>
<li><code>Router</code>: O <code>Router</code> comunica com o <code>RouteAgent</code> e automaticamente resolve a <code>Route</code> que recebe do <code>RouteAgent</code> para uma das implementações do <code>Switch</code>.</li>
</ul>
<h2 id="explicando-como-funciona-o-router"><a class="header" href="#explicando-como-funciona-o-router">Explicando como funciona o Router</a></h2>
<p><code>Router</code> funciona de forma a aplicar um <em>pattern macthing</em> na url recebida pelo browser que instancia um tipo que implementa a trait <code>Switch</code> para a rota correspondente. Uma coisa importante de salientar é que utilizar tags de referência, <code>&lt;a href=...&gt;&lt;/a&gt;</code>, para a rota que você deseja não irá funcionar imediatamente e, no melhor cenário, irá fazer o servidor recarregar todo o bunde do App. No pior cenário, retorna apenas um código <code>404 - Not Found</code>, caso o serviço não esteja bem configurado. Assim,  utilizar <code>RouteService, RouteAgent, RouterButton, RouterLink</code> para definir a rota via <code>history.push_state()</code> modificará a rota, sem recarregar todo o App novamente.</p>
<p><strong>Configuração do Servidor</strong></p>
<p>Para que um link externo funcione com o App, o servidor precisa estar configurado para retornar o <code>index.html</code> para qualquer request <code>GET</code>, senão o retorno será sempre <code>404</code>. Além disso, não pode ser um redirecionamento <code>3xx</code> para o <code>index.html</code>, pois isso modificará a url no browser causando uma falha de roteamento. Assim, é preciso que a resposta seja um <code>200</code> que contém o <code>index.html</code>. Uma vez que o conteúdo de <code>index.html</code> carregar, resultando no carregamento de todos os assets para iniciar o App, que detectará a rota atual definindo o estado do App para o estado correspondente.</p>
<ol>
<li>O miserve que estamos utilizando já aponta para o diretório <code>static/</code> e para o índice  <code>index.html</code>, <code>miniserve ./static --index index.html</code>.</li>
<li>Se você quiser servir seu App do mesmo servidor que sua API está localizada, uma recomendação é definir a rota da API como <code>/api</code> e montar seus assets sob a rota <code>/</code> fazendo com que ela retorne o conteúdo de <code>index.html</code>.</li>
<li>É possivel também configurar o webpack dev server para apontar seus arquivos para <code>index.hmtl</code>. Mais informações em https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback.</li>
</ol>
<p>Neste livro vamos abordar s estratégias <code>1</code>, mas caso você prefira a estratégia <code>2</code>, poderiamos utilizar o serviço anterior, com a crate <code>actix-files = &quot;0.2.2&quot;</code>, para retornar nosso <code>index.html</code> executando um <code>GET</code> na rota <code>&quot;/&quot;</code>. O serviço fica configurado da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">use actix_files::NamedFile;
use actix_web::{get, middleware, web, App, Error, HttpResponse, HttpServer};

// Caminho para o diretório `static/`
const ASSETS_DIR: &amp;str = &quot;../../static&quot;;

async fn serve_index_html() -&gt; Result&lt;NamedFile, Error&gt; {
    const INDEX_HTML: &amp;str = &quot;index.html&quot;;
    let index_file = format!(&quot;{}/{}&quot;, ASSETS_DIR, INDEX_HTML);

    Ok(NamedFile::open(index_file)?)
}

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_server=info,actix_web=info&quot;);
    env_logger::init();

    let localhost: &amp;str = &quot;0.0.0.0&quot;;
    let port: u16 = 8000;
    let addr = (localhost, port);

    HttpServer::new(move || {
        App::new()
            .wrap(middleware::Logger::default())
            .service(actix_files::Files::new(&quot;/&quot;, ASSETS_DIR).index_file(&quot;index.html&quot;))
            .default_service(web::get().to(serve_index_html))
    })
    .bind(addr)?
    .workers(4)
    .run()
    .await
}
</code></pre></pre>
<h3 id="entendendo-as-rotas"><a class="header" href="#entendendo-as-rotas">Entendendo as Rotas</a></h3>
<p>Agora vamos entender um exemplo genérico de como configurar rotas, pois isto nos permitirá estender a lógica para o caso que vamos utilizar. A primeira coisa que precisamos fazer é definir um <code>enum</code> que seja responsável pelas rotas, no exemplo chamamos de <code>enum AppRoute</code>. Esse <code>enum</code> deve implementar a trait <code>Switch</code>, que vai correlacionar cada rota <code>to</code> a um elemente do <code>enum</code>, como o exemplo do <code>Index</code>. O exemplo do <code>AppRoute::Index</code> aponta para a rota <code>/</code> por conta da derivação <code>#[to = &quot;/&quot;]</code>, o mesmo vale para <code>Profile(u32)</code> que aponta para <code>#[to = &quot;/profile/{id}&quot;]</code>, na qual <code>{id}</code> é um valor do tipo <code>u32</code>. O caso de <code>Forum(ForumRoute),</code> é um pouco mais complicado, pois <code>ForumRoute</code> é uma sub rota associada a outro enum que implementa suas próprias rotas, mas seria possível deestrutura esses valores em uma  struct. Importante também salientar que o <em>pattern matching</em> ocorre de forma sequencial, então se <code>Index</code> fosse o primeiro, nenhuma das outras rotas aconteceria, pois todas as rotas seriam <code>&quot;/&quot;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Switch, Debug)]
pub enum AppRoute {
    #[to = &quot;/profile/{id}&quot;]
    Profile(u32),
    #[to = &quot;/forum{*:rest}&quot;]
    Forum(ForumRoute),
    #[to = &quot;/&quot;]
    Index,
}

#[derive(Switch, Debug)]
pub enum ForumRoute {
    #[to = &quot;/{subforum}/{thread_slug}&quot;]
    SubForumAndThread{subforum: String, thread_slug: String}
    #[to = &quot;/{subforum}&quot;]
    SubForum{subforum: String}
}

html! {
    &lt;Router&lt;AppRoute, ()&gt;
        render = Router::render(|switch: AppRoute| {
            match switch {
                AppRoute::Profile(id) =&gt; html!{&lt;ProfileComponent id = id/&gt;},
                AppRoute::Index =&gt; html!{&lt;IndexComponent/&gt;},
                AppRoute::Forum(forum_route) =&gt; html!{&lt;ForumComponent route = forum_route/&gt;},
            }
        })
    /&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Por último, a construção do <code>Router</code> se da através da tag <code>Router</code> que recebe como propridade <code>&lt;AppRoute, ()&gt;</code> e <code>render</code> que é a implementação da função <code>Router::render</code> no enum <code>AppRouter</code>.</p>
<h2 id="potencializando-o-componente-airline"><a class="header" href="#potencializando-o-componente-airline">Potencializando o componente <code>Airline</code></a></h2>
<p>A ideia agora é tornar nosso componente de <code>Airline</code> mais flexível para tirarmos maior proveito do <code>Router</code>, nesse sentido vamos lidar com as propriedades <code>departure, origin, destination</code> para no componente poder fazer queries customizadas. Para iniciarmos este processo, precisamos criar a <code>struct Props</code>, que conterá estes campos em <code>app.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Properties, Clone)]
pub struct Props {
    pub departure: String,
    pub origin: String,
    pub destination: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Note a presença da macro <code>Properties</code>, ela é quem nos permite tornar esses campos utilizáveis como propriedades do componente e o fato de que todas as propriedades são <code>pub</code> para poderem ser acessadas de fora durante a declaração do componente. Agora precisamos definir <code>Props</code> como o tipo <code>Properties</code> da trait <code>Component</code>, fazemos isso na implementação da trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Component for Airline {
    type Message = Msg;
    type Properties = Props;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Podemos seguir com o próximo passo que é salvar as propriedades no estado de <code>Airline</code>, que pode ser feito simplesmente adicionando os campos a struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Airline {
    // ...
    filter_cabin: String,
    departure: String,
    origin: String,
    destination: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta etapa nos obriga a salvar as propriedades no estado, podemos fazer isso na função <code>create</code> da trait <code>Component</code>, que agora terá o nome <code>props</code> para o argumento <code>Self::Properties</code>, que antes estava como <code>_: Self::Properties</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create(props: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {
    Airline {
        fetch: FetchService::new(),
        link: link,
        fetch_task: None,
        fetching: true,
        graphql_url: &quot;http://localhost:4000/graphql&quot;.to_string(),
        graphql_response: None,
        filter_cabin: String::from(&quot;Y&quot;),
        departure: props.departure,
        origin: props.origin,
        destination: props.destination
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta alteração nos permite passar como argumento para a função <code>fetch_gql</code>, chamada pela função <code>fetch_data</code>, os campos <code>departure, origin, destination</code>, que nos permitem flexibilizar o request para o servidor GraphQL. Em <code>fetch_data</code> a chama de <code>fetch_gql</code> passa a ser da sehguinte forma <code>let request = fetch_gql(self.departure.clone(), self.origin.clone(), self.destination.clone());</code>. Agora a implementação da função <code>fetch_gql</code> no módulo <code>gql</code> muda para comportar os novos argumentos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fetch_gql(departure: String, origin: String, destination: String) -&gt; Value {
    json!({
        // ...
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Estes novos argumentos devem ser passados para a <code>query</code> através da chave <code>variables</code> que conterá um mapa na qual cada chave é o nome da variável que vamos passar para <code>query</code>. Além disso, na chave <code>query</code> agora devemos adicionar os argumentos de query, fazemos isso colocando <code>query($departure: String!, $origin: String!, $destination: String!)</code> antes da primeira chave de abertura, <code>{</code>. Perceba que o nome dos campos possui um <code>$</code> na frente, que nos permite definir como uma variável para utilizar dentro da <code>query</code>, como <code>recommendations(departure: $departure, origin: $origin, destination: $destination)</code>. O exemplo a seguir mostra como a modificação fica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fetch_gql(departure: String, origin: String, destination: String) -&gt; Value {
    json!({
        &quot;variables&quot;: {
            &quot;departure&quot;: departure,
            &quot;origin&quot;: origin,
            &quot;destination&quot;: destination
        },
        &quot;query&quot;: &quot;query($departure: String!, $origin: String!, $destination: String!) {
                recommendations(departure: $departure, 
                    origin: $origin, 
                    destination: $destination) {
                    data{
                    // ...
                    }
                }
                bestPrices(departure: $departure, origin: $origin, destination: $destination) {
                    bestPrices {
                        date
                        available
                        price {amount}
                    }
                }
        }&quot;
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Para utilizamos esta nova <code>query</code>, precisamos passar <code>Props</code> como argumento em <code>run_app</code>, fazemos isso da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![recursion_limit=&quot;1024&quot;]
<span class="boring">fn main() {
</span>mod app;
mod gql;
mod best_prices;
mod reccomendation;

use wasm_bindgen::prelude::*;
use yew::prelude::App;
use app::Props;


#[wasm_bindgen(start)]
pub fn run_app() {
    App::&lt;app::Airline&gt;::new().mount_as_body_with_props(Props {
        origin: &quot;POA&quot;.to_string(),
        destination: &quot;GRU&quot;.to_string(),
        departure: &quot;2020-08-21&quot;.to_string(),
    });
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="criando-o-router"><a class="header" href="#criando-o-router">Criando o <code>Router</code></a></h2>
<p>Para começarmos o sistema de roteamento vamos precisar de um novo componente chamado <code>Model</code> que estará localizado no módulo <code>index</code>. Assim, a primeira coisa que vamos fazer é definir o <code>Model</code> e declarar as rotas no enum <code>AppRoutes</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use yew_router::Switch;
use yew::prelude::*;

#[derive(Switch, Debug, Clone)]
pub enum AppRoute {
    #[to = &quot;/oneway?departure={departure}&amp;origin={origin}&amp;destination={destination}&quot;]
    Oneway {departure: String, origin: String, destination: String},
    #[to = &quot;/&quot;]
    Index
}

#[derive(Debug)]
pub struct Model {}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso <code>AppRoute</code> possui duas rotas, a primeira é a rota inicial, que renderiza logo que acessamos <code>localhost:8080</code>, já a segunda é a rota que navegamos, uma vez que os parâmetros tenham sido definidos. Os parâmetros da rota <code>Oneway</code> são os mesmos da struct <code>Props</code>, e são definidos na declaração da opção. Note que a url possui o nome dos campos dentro de chaves, <code>/oneway?departure={departure}&amp;origin={origin}&amp;destination={destination}</code>, é dessa forma que a macro <code>Switch</code> consegue executar as substituições de valores. Precisamos adicioanr ao estado de <code>Model</code> os campos de <code>Oneway</code>, pois comente assim poderemos altera-los para executar a navegação entre rotas, para isso adicionamos os seguintes campos a <code>Model</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct Model {
    route_service: RouteService&lt;()&gt;,
    route: Route&lt;()&gt;,
    link: ComponentLink&lt;Self&gt;,
    origin: String,
    destination: String,
    departure: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Os campos <code>origin, destination, departure</code> já falamos sobre eles, mas adicionamos outros campos. <code>link</code> já mencionamos quando criamos os callbacks para <code>BestPrices</code>, mas <code>route</code> terá a função de receber uma das rotas que <code>AppRoute</code> define, que poderá ser utilizada em pattern matching depois e <code>route_service</code> serve para fazer a navegação entre as rotas. Além disso, precisamos da diretiva <code>use yew_router::{route::Route, service::RouteService, Switch}</code> para comportar os novos campos. Para começarmos a implementar a trait <code>Component</code> vamos precisar de um enum de mensagens, que também vamos chamar de <code>Msg</code> e conterá, inicialmente, dois campos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Msg {
    RouteChanged(Route&lt;()&gt;),
    ChangeRoute(AppRoute),
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><code>RouteChanged</code> será responsável por avisar ao componente que a rota mudou, enquando <code>ChangeRoute</code> será responsável por efetivamente mudar a rota. Com isso, podemos iniciar a implementação da trait <code>Component</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Component for Model {
    type Message = Msg;
    type Properties = ();

    fn create(_: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {
        let mut route_service: RouteService&lt;()&gt; = RouteService::new();
        let route = route_service.get_route();
        let callback = link.callback(Msg::RouteChanged);
        route_service.register_callback(callback);

        Model {
            route_service,
            route,
            link,
            origin: String::new(),
            destination: String::new(),
            departure: String::new() 
        }
    }

    fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
        match msg {
            Msg::RouteChanged(route) =&gt; self.route = route,
            Msg::ChangeRoute(route) =&gt; {
                self.route = route.into();
                self.route_service.set_route(&amp;self.route.route, ());
            }
        }
        true
    }

    fn change(&amp;mut self, _: Self::Properties) -&gt; ShouldRender {
        false
    }

    fn view(&amp;self) -&gt; VNode {
        html! {
            &lt;div&gt;
                {
                    &quot;route&quot;
                }
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A função <code>create</code> começa um pouco diferente que o usual:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut route_service: RouteService&lt;()&gt; = RouteService::new();
let route = route_service.get_route();
let callback = link.callback(Msg::RouteChanged);
route_service.register_callback(callback);
<span class="boring">}
</span></code></pre></pre>
<p>Nela declaramos o <code>route_service</code> como um <code>RouteService::new()</code> e definimos a <code>route</code> como o atual estado de <code>route_service</code>, <code>route_service.get_route()</code>. Depois disso, criamos o <code>callback</code> que será chamado quando <code>Msg::RouteChanged</code> for enviada para <code>Model</code> e registramos esse <code>callback</code> em <code>route_service</code> com <code>route_service.register_callback(callback)</code>.</p>
<p>Nosso <code>update</code> vai fazer pattern matching nas duas mensagens, na qual <code>RouteChanged</code> atualiza <code>self.route</code> e <code>ChangeRoute</code> define a rota para navegar com <code>self.route_service.set_route(&amp;self.route.route, ())</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
    match msg {
        Msg::RouteChanged(route) =&gt; self.route = route,
        Msg::ChangeRoute(route) =&gt; {
            self.route = route.into();
            self.route_service.set_route(&amp;self.route.route, ());
        }
    }
    true
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="definindo-as-rotas-na-view"><a class="header" href="#definindo-as-rotas-na-view">Definindo as rotas na <code>view</code></a></h3>
<p>Agora podemos elaborar nossa <code>view</code> e para fazermos isso vamos applicar um <code>match</code> na rota, <code>self.route</code>, através a função <code>AppRoute::switch</code> que converte a <code>Route&lt;()&gt;</code> em um <code>Option&lt;AppRoute&gt;</code>. Para o caso <code>None</code>, retornamo <code>404</code> com <code>VNode::from(&quot;404&quot;)</code>, para o caso <code>Some(Index)</code> vamos apresentar a tela inicial para a pessoa inserir <code>origin, destination, departure</code>, para a Rota <code>Some(AppRoute::Oneway{departure, origin, destination})</code> vamos criar o componente <code>Airline</code> com as propriedades anteriores utilizando <code>html!{&lt;Airline departure = departure origin = origin destination = destination /&gt;},</code>. As propriedades são passadas no formato <code>propriedade = valor</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; VNode {
    html! {
        &lt;div&gt;
            {
                match AppRoute::switch(self.route.clone()) {
                    Some(AppRoute::Index) =&gt; self.view_index(),
                    Some(AppRoute::Oneway{departure, origin, destination}) 
                        =&gt; html!{&lt;Airline departure = departure origin = origin destination = destination /&gt;},
                    None =&gt; VNode::from(&quot;404&quot;)
                }
            }
        &lt;/div&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora para a função <code>self.view_index()</code>. Ela deve ser implementada em um <code>impl Model</code> e conterá o HTML a ser exibido para a rota <code>Index</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Model {
    fn change_route(&amp;self, app_route: AppRoute) -&gt; Callback&lt;MouseEvent&gt; {
        self.link.callback(move |_| {
            let route = app_route.clone();
            Msg::ChangeRoute(route)
        })
    }

    fn view_index(&amp;self) -&gt; Html {
        html!{
            &lt;div class=&quot;index&quot;&gt;
                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Origin&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.origin,
                            oninput = self.link.callback(|e: InputData| Msg::UpdateOrigin(e.value)),
                        /&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Destination&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.destination,
                            oninput = self.link.callback(|e: InputData| Msg::UpdateDestination(e.value)),
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Departure&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.departure,
                            oninput = self.link.callback(|e: InputData| Msg::UpdateDeparture(e.value)),
                        /&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;input-cell submit&quot;&gt;
                        &lt;button onclick=&amp;self.change_route(AppRoute::Oneway
                            {departure: self.departure.clone(), 
                            origin: self.origin.clone(), 
                            destination: self.destination.clone()}) &gt; 
                            {&quot;Submit&quot;}
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A view está dividida basicamente uma tabela de duas linhas com dois elementos cada. Os 3 primeiro elementos são tags HTML para inserção de texto e farão isso para as propriedades <code>origin, destination, departure</code>. A estrutura é bastante simples, definimos o tipo do <code>input</code> como <code>type = &quot;text&quot;</code>, o valor, <code>value</code> como <code>&amp;self.&lt;propriedade&gt;</code> e a ação <code>oninput</code> como um <code>callback</code> para uma mensagem que definimos no padrão <code>Update&lt;Propriedade&gt;</code> que recebe o valor de <code>InputData</code>. A última célula da tabela é uma tag <code>button</code> com a ação de navegar para a nova rota. A ação é <code>onclick</code> e recebe a função <code>change_route</code> com uma rota <code>Oneway</code>.</p>
<blockquote>
<p>A mensagem de Update poderia receber um novo parâmetro como um enum que indicasse qual a propriedade e fazer um pattern matching interno.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Origin&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.origin,
                            oninput = self.link.callback(|e: InputData| Msg::Update(Prop::Origin, e.value)),
                        /&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Destination&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.destination,
                            oninput = self.link.callback(|e: InputData| Msg::Update(Prop:Destination, e.value)),
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Departure&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.departure,
                            oninput = self.link.callback(|e: InputData| Msg::Update(Prop::Departure, e.value)),
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p><code>change_route</code> tem uma execução bastante simples, pois define a nova rota através de <code>let route: AppRoute = app_route.clone();</code>, cria a mensagem <code>Msg::ChangeRoute</code> com a rota criada e atribui isso a um <code>callback</code>. Isso nos força a expandirmos <code>Msg</code> para os novos casos que descrevemos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Msg {
    RouteChanged(Route&lt;()&gt;),
    ChangeRoute(AppRoute),
    UpdateOrigin(String),
    UpdateDestination(String),
    UpdateDeparture(String)
}
<span class="boring">}
</span></code></pre></pre>
<p>ou</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Prop {
    Origin,
    Destination,
    Departure
}

pub enum Msg {
    RouteChanged(Route&lt;()&gt;),
    ChangeRoute(AppRoute),
    Update(Prop, String)
}
<span class="boring">}
</span></code></pre></pre>
<p>E como última tarefa precisamos adicionar as novas mensagens a função <code>update</code>. Tanto <code>origin</code>, quanto <code>destination</code> limitei fracamente em três caracteres pois códigos IATAs possuem apenas três caracteres.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
    match msg {
        Msg::RouteChanged(route) =&gt; self.route = route,
        Msg::ChangeRoute(route) =&gt; {
            self.route = route.into();
            self.route_service.set_route(&amp;self.route.route, ());
        },
        Msg::UpdateOrigin(origin) =&gt; self.origin = origin[0..3].to_string(),
        Msg::UpdateDestination(destination) =&gt; self.destination = destination[0..3].to_string(),
        Msg::UpdateDeparture(departure) =&gt; self.departure = departure
    }
    true
}
<span class="boring">}
</span></code></pre></pre>
<p>Seguindo o uso de <code>Prop</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
    match msg {
        Msg::RouteChanged(route) =&gt; self.route = route,
        Msg::ChangeRoute(route) =&gt; {
            self.route = route.into();
            self.route_service.set_route(&amp;self.route.route, ());
        },
        Msg::Update(prop, value) =&gt; match prop {
            Prop::Origin =&gt; self.origin = value[0..3].to_string(),
            Prop::Destinationj =&gt; self.destination = value[0..3].to_string(),
            Prop::Departure =&gt; self.departure = value,
        }
    }
    true
}
<span class="boring">}
</span></code></pre></pre>
<p>Para finalizar o css utilizado em <code>view_index</code>:</p>
<pre><code class="language-css">
.index {
  display: table;
  height: 20%;
  width: auto;
  background-color: darkblue;
  color: wheat;
  transform: translate(150%, 20%);
}

.row {
  display: table-row;
}

.input-cell {
  display: table-cell;
  padding: 1rem;
}

.submit {
  vertical-align: middle;
  text-align: center;
}
</code></pre>
<p>E uma imagem com o resultado de <code>view_index</code> na rota <code>&quot;/&quot;</code>:</p>
<p><img src="part-3/../imagens/view_index.png" alt="View da rota &quot;/&quot;" /></p>
<p>Agora basta subir, no diretório do GraphQL, o Redis com <code>make redis</code>, subir o GraphQL com <code>make run</code> e subir, no diretório wasm, o wasm com <code>make run</code> adicionar suas rotas desejada e datas desejadas e procurar seu próximo voo em sua própria API.</p>
<p>Esta parte nos trouxe alguns conceitos de desenvolvimento front-end com Rust e Wasm, nos permitindo consultar a API que criamos na parte anterior. Aprendemos a criar um componente com a trait <code>COmponent1</code> que realiza um fetch logo no primeiro render da página, comunicando-se por mensagens que alteram o front-end entre um <code>loader</code> e os dados que queremos exibir. Aprendemos a navegar através de um <code>Router</code> e <code>Properties</code> de um componente ao outro e aprendemos a criar componentes the recebem <code>inputs</code> de valores textuais, assim como, componentes que tomam ações com vase em cliques, como o <code>button</code>. Além disso, para o serviço que criamos executar com nosso front-end local precisamos utilizar a crate <code>actix-cors</code> para configurar o <code>CORS</code> da API.</p>
<p>Na API que atendia ao front-end utilizamos a crate <code>juniper</code> para configurar o GraphQL em cima do <code>actix-web</code>, assim como a crate <code>reqwest</code> para realizar requests HTTP para uma API externa e utilizamos a crate <code>redis</code> para configurar a comunicação com um container Redis. Já no nosso outro serviço, aprendemos a configurar middlewares, como Logger, para o Actix, sistema de tolerância a falhas com <code>bastion/fort</code>, uuids, configurações de json com <code>serde</code>, configuramos um DynamoDB com a crate <code>rusoto</code>, assim como um <code>Postgres</code> com a crate <code>diesel</code>, utilizamos a crate <code>chrono</code> para gerenciar datas, fizemos sistemas de autenticação que utilizavam <code>jwt</code> e <code>bcrypt</code> para parsear tokens e senhas, além de  testes extensivos para estes cenários, tanto unitários quanto de integração. Vale mencionar também que configuramos um Travis-CI para este cenário. </p>
<p>Agora você já pode começar a investir em serviços e front-ends Rust para demonstrar seu poder e levar a palavra do Rust a diante.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apêndice-a---benchmarks"><a class="header" href="#apêndice-a---benchmarks">Apêndice A - Benchmarks</a></h1>
<h2 id="techempower"><a class="header" href="#techempower">Techempower</a></h2>
<p>Os benchmarks do Techempower são abertos a comunidade desenvolver seus serviços conforme acreditarem ser melhor e consistem em 5 categorias:</p>
<ol>
<li>Serialização Json, neste teste cada resposta é uma instância com a chave <code>message</code> e o valor <code>Hello, World!</code> para ser serializada como Json. Actix em quinto lugar (rust em terceiro).</li>
<li>Única Query, neste teste cada request é processado fazendo fetch de uma única linha em uma simples tabela no bancl de dadps. A linha é então serializada em JSON. Actix em primeiro lugar.</li>
<li>Multiplas Queries, neste teste cada request processa multiplos fetchs em multiplas linhas de uma tabela simples e serializa essas linhas em Json. Actix em primeiro lugar.</li>
<li>Fortuna, neste teste, o ORM do framework é utilizado para fazer fetch de todas as linhas de uma tabela contendo um número desconhecido de mensagens de biscoitos da sorte. Um biscoito extra é adicionado na lista durante execução e após isso a lista é ordenada alfabeticamente. Actix em primeiro lugar.</li>
<li>Atualização de dados, neste teste verificamos a escrita em banco de dados. Cada request processa multiplos fetchs em multiplas linhas de uma tabela simples, guardamos em memória, modificamos os valores em memória, atualizamos cada linha individualmente  e depois serializamos os valores em memória para retornar como Json. Actix em primeiro lugar.</li>
<li>Texto puro, neste teste o framework responde com <code>plaintext</code> <code>&quot;hello, World&quot;</code>. Actix em quarto lugar (rust em primeiro e segundo).</li>
</ol>
<p><img src="../imagens/techempower.png" alt="Techempower 2018 Fortunes" />
Referência https://www.techempower.com/benchmarks/#section=data-r18&amp;hw=ph&amp;test=fortune</p>
<h2 id="express-vs-actix"><a class="header" href="#express-vs-actix">Express vs Actix</a></h2>
<p>Maxim Vorobjov criou seu próprio benchmark comparando comparando Express Node com Actix Rust e obteve resultados bastante interessantes. Ele comparou a performance, a estabilidade e o custo de um simples microserviço escrito com Express e com Actix. O setup estava limitado a 1 core. </p>
<p>O cenário era um microserviço que permite os clientes procurarem por <code>task</code> que podem ou não estar associadas a <code>workers</code>. Assim, o banco de dados possui apenas duas tabelas, <code>WORKER</code> e <code>TASK</code>, na qual <code>TASK</code> possui um relação com <code>WORKER</code>:</p>
<pre><code class="language-sql">CREATE TABLE worker (
	id SERIAL PRIMARY KEY,
	name varchar(255) NOT NULL,
	email varchar(255) NULL,
	score integer DEFAULT 0
);

CREATE TABLE task (
	id SERIAL PRIMARY KEY,
	summary varchar(255) NOT NULL,
	description text NOT NULL,
	assignee_id integer NULL REFERENCES worker,
	created TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
</code></pre>
<h3 id="teste-de-carga"><a class="header" href="#teste-de-carga">Teste de Carga</a></h3>
<p>Teste de performance foi feito em um  Ubuntu 18 Xeon E5–2660 com 40 cores, e o banco de dados foi inicializado com 100_000 <code>TASK</code> aleatórias com 1000 <code>WORKER</code>s  relacionadas. Os testes foram executados com https://github.com/wg/wrk e os resultados são os seguintes:</p>
<p><img src="../imagens/actixexpressloadrps.png" alt="Requests por segundo, maior é melhor" /></p>
<p><img src="../imagens/actixexpressloadmrt.png" alt="Tempo médio de resposta, ms, menor é melhor" /></p>
<p>Continue lendo em https://medium.com/@maxsparr0w/performance-of-node-js-compared-to-actix-web-37f20810fb1a</p>
<h1 id="apêndice-b---requests"><a class="header" href="#apêndice-b---requests">Apêndice B - Requests</a></h1>
<h2 id="todo-server"><a class="header" href="#todo-server">Todo Server</a></h2>
<h3 id="signup"><a class="header" href="#signup">Signup</a></h3>
<p><code>POST http://localhost:4000/auth/signup</code></p>
<p><strong>Headers</strong></p>
<pre><code class="language-json">{
    &quot;Content-Type&quot;: &quot;application/json&quot;,
    &quot;x-customer-id&quot;: &quot;d8f98c2e-07df-4ed6-8645-7f0b25536fdf&quot;
}
</code></pre>
<p><strong>Body</strong></p>
<pre><code class="language-json">{
	&quot;email&quot;: &quot;my@email.com&quot;,
	&quot;password&quot;: &quot;My cr4zy p@ssw0rd My cr4zy p@ssw0rd&quot;
}
</code></pre>
<h3 id="login"><a class="header" href="#login">Login</a></h3>
<p><code>POST http://localhost:4000/auth/login</code></p>
<p><strong>Headers</strong></p>
<pre><code class="language-json">{
    &quot;Content-Type&quot;: &quot;application/json&quot;,
    &quot;x-customer-id&quot;: &quot;d8f98c2e-07df-4ed6-8645-7f0b25536fdf&quot;
}
</code></pre>
<p><strong>Body</strong></p>
<pre><code class="language-json">{
	&quot;email&quot;: &quot;my@email.com&quot;,
	&quot;password&quot;: &quot;My cr4zy p@ssw0rd My cr4zy p@ssw0rd&quot;
}
</code></pre>
<h3 id="logout"><a class="header" href="#logout">Logout</a></h3>
<p><code>DELETE http://localhost:4000/auth/logout</code></p>
<p><strong>Headers</strong></p>
<pre><code class="language-json">{
    &quot;Content-Type&quot;: &quot;application/json&quot;,
    &quot;x-customer-id&quot;: &quot;d8f98c2e-07df-4ed6-8645-7f0b25536fdf&quot;,
    &quot;x-auth&quot;: &quot;eyJhbGciOiJIUzI1NiIsImRhdGUiOiIyMDIwLTAyLTI4IDAxOjQxOjU2LjA2NjYxNTQwMCBVVEMiLCJ0eXAiOiJqd3QifQ.eyJlbWFpbCI6Im15QGVtYWlsLmNvbSIsImV4cGlyZXNfYXQiOiIyMDIwLTAyLTI5VDAxOjQxOjU2LjA2MzI2ODgwMCIsImlkIjoiZDdjNTk1MTItYjlhYS00NzBhLWEwNjUtZTAwYTYxMTcxYmE0In0.gIycarcQhbbcjvYIHDW_9fVgCFrFs1LjlJFMZGIm_kw&quot;
}
</code></pre>
<p><strong>Body</strong></p>
<pre><code class="language-json">{
	&quot;email&quot;: &quot;my@email.com&quot;
}
</code></pre>
<h3 id="create-todo"><a class="header" href="#create-todo">Create Todo</a></h3>
<p><code>POST http://localhost:4000/api/create</code></p>
<p><strong>Headers</strong></p>
<pre><code class="language-json">{
    &quot;Content-Type&quot;: &quot;application/json&quot;,
    &quot;x-customer-id&quot;: &quot;d8f98c2e-07df-4ed6-8645-7f0b25536fdf&quot;,
    &quot;x-auth&quot;: &quot;eyJhbGciOiJIUzI1NiIsImRhdGUiOiIyMDIwLTAyLTI4IDAxOjQxOjU2LjA2NjYxNTQwMCBVVEMiLCJ0eXAiOiJqd3QifQ.eyJlbWFpbCI6Im15QGVtYWlsLmNvbSIsImV4cGlyZXNfYXQiOiIyMDIwLTAyLTI5VDAxOjQxOjU2LjA2MzI2ODgwMCIsImlkIjoiZDdjNTk1MTItYjlhYS00NzBhLWEwNjUtZTAwYTYxMTcxYmE0In0.gIycarcQhbbcjvYIHDW_9fVgCFrFs1LjlJFMZGIm_kw&quot;
}
</code></pre>
<p><strong>Body</strong></p>
<pre><code class="language-json">{
	{
	&quot;title&quot;: &quot;title&quot;,
	&quot;description&quot;: &quot;descrition&quot;,
	&quot;state&quot;: &quot;Done&quot;,
	&quot;owner&quot;: &quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;,
	&quot;tasks&quot;: [
		{
			&quot;is_done&quot;: true,
			&quot;title&quot;: &quot;blob&quot;
			
		},
		{
			&quot;is_done&quot;: false,
			&quot;title&quot;: &quot;blob2&quot;
			
		}]
}
}
</code></pre>
<h3 id="get-all-todos"><a class="header" href="#get-all-todos">Get All Todos</a></h3>
<p><code>GET http://localhost:4000/api/index</code></p>
<p><strong>Headers</strong></p>
<pre><code class="language-json">{
    &quot;Content-Type&quot;: &quot;application/json&quot;,
    &quot;x-customer-id&quot;: &quot;d8f98c2e-07df-4ed6-8645-7f0b25536fdf&quot;,
    &quot;x-auth&quot;: &quot;eyJhbGciOiJIUzI1NiIsImRhdGUiOiIyMDIwLTAyLTI4IDAxOjQxOjU2LjA2NjYxNTQwMCBVVEMiLCJ0eXAiOiJqd3QifQ.eyJlbWFpbCI6Im15QGVtYWlsLmNvbSIsImV4cGlyZXNfYXQiOiIyMDIwLTAyLTI5VDAxOjQxOjU2LjA2MzI2ODgwMCIsImlkIjoiZDdjNTk1MTItYjlhYS00NzBhLWEwNjUtZTAwYTYxMTcxYmE0In0.gIycarcQhbbcjvYIHDW_9fVgCFrFs1LjlJFMZGIm_kw&quot;
}
</code></pre>
<h2 id="recomendations-graphql"><a class="header" href="#recomendations-graphql">Recomendations GraphQL</a></h2>
<h3 id="graphql-1"><a class="header" href="#graphql-1">GraphQL:</a></h3>
<ul>
<li>Graphich interface: http://localhost:4000/graphiql</li>
<li>Para requests: </li>
</ul>
<h3 id="api-externa"><a class="header" href="#api-externa">API Externa</a></h3>
<ul>
<li>
<p>Recomendações de voos: https://bff.latam.com/ws/proxy/booking-webapp-bff/v1/public/revenue/recommendations/oneway?departure=<YYYY-mm-dd>&amp;origin=<IATA>&amp;destination=<IATA>&amp;cabin=Y&amp;country=BR&amp;language=PT&amp;home=pt_br&amp;adult=1&amp;promoCode=</p>
</li>
<li>
<p>Melhores preços https://bff.latam.com/ws/proxy/booking-webapp-bff/v1/public/revenue/bestprices/oneway?departure=<YYYY-mm-dd>&amp;origin=<IATA>&amp;destination=<IATA>&amp;cabin=Y&amp;country=BR&amp;language=PT&amp;home=pt_br&amp;adult=1&amp;promoCode=</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliografia"><a class="header" href="#bibliografia">Bibliografia</a></h1>
<ol>
<li><a href="https://www.casadocodigo.com.br/products/livro-rust?_pos=2&amp;_sid=0d745f730&amp;_ss=r">Livro de Rust da Casa do Código</a></li>
<li><a href="https://doc.rust-lang.org/book/">Livro Oficial de Rust</a></li>
<li><a href="https://www.casadocodigo.com.br/products/livro-rust-funcional-concorrente?_pos=1&amp;_sid=0d745f730&amp;_ss=r">Livro de Programaçnao Funcional e Concorrente em Rust</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust por Exemplo</a></li>
<li><a href="https://www.rust-lang.org/tools/install">Instalação do Rust</a></li>
<li><a href="https://pragprog.com/book/tvmelixir/adopting-elixir">Adopting Elixir</a></li>
<li><a href="https://pragprog.com/book/dswdcloj3/web-development-with-clojure-third-edition">Web Development with Clojure</a></li>
<li><a href="https://pragprog.com/book/lotdd/modern-c-programming-with-test-driven-development">Modern C++ Programming with Test-Driven Development</a></li>
<li><a href="https://pragprog.com/book/phoenix14/programming-phoenix-1-4">Programming Phoenix 1.4</a></li>
<li><a href="https://github.com/web-dev-rust/todo-server">Código do servidor de tarefas</a></li>
<li><a href="https://github.com/web-dev-rust/airline-tickets">Código do servidor de passagens</a></li>
<li><a href="https://github.com/web-dev-rust/wasm-airline">Código do frontend para visualização de passagens</a></li>
<li><a href="https://actix.rs/">Actix</a></li>
<li><a href="http://diesel.rs/guides/getting-started/">Guia do Diesel</a></li>
<li><a href="https://www.howtographql.com/">How to Graphql</a></li>
<li><a href="https://www.casadocodigo.com.br/products/livro-graphql?_pos=1&amp;_sid=a01bcef18&amp;_ss=r">Livro GraphQL da Casa do Código</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
