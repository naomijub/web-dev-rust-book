<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Desenvolvimento Web em Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro/1-about.html">Sobre autora</a></li><li class="chapter-item expanded affix "><a href="intro/2-Audience.html">Público alvo</a></li><li class="chapter-item expanded affix "><a href="intro/3-book.html">Como o livro está organizado</a></li><li class="chapter-item expanded affix "><a href="intro/4-setup.html">Instalando Rust</a></li><li class="chapter-item expanded affix "><a href="intro/5-exercício.html">Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded affix "><a href="part-1/00-capa.html">Parte 1</a></li><li class="chapter-item expanded "><a href="part-1/01-ping-pong.html"><strong aria-hidden="true">1.</strong> Configurando os primeiros endpoints</a></li><li class="chapter-item expanded "><a href="part-1/02-create.html"><strong aria-hidden="true">2.</strong> Criando Tarefas</a></li><li class="chapter-item expanded "><a href="part-1/03-get.html"><strong aria-hidden="true">3.</strong> Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded "><a href="part-1/04-serving.html"><strong aria-hidden="true">4.</strong> Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded "><a href="part-1/05-auth.html"><strong aria-hidden="true">5.</strong> Autenticação</a></li><li class="chapter-item expanded "><a href="part-1/06-middleware.html"><strong aria-hidden="true">6.</strong> Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded "><a href="part-1/07-ci.html"><strong aria-hidden="true">7.</strong> Configurando um CI</a></li><li class="chapter-item expanded "><a href="part-1/08-conclusao.html"><strong aria-hidden="true">8.</strong> Concluindo o serviço</a></li><li class="chapter-item expanded affix "><a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.html">Topo</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="intro/2-Audience.html">Próximo</a></p>
<h1 id="sobre-a-autora"><a class="header" href="#sobre-a-autora">Sobre a autora</a></h1>
<p>Julia Naomi Boeira é uma engenheira de software com experiência em programação funcional e concorrente, games e sistemas distribuídos. Atualmente trabalha com open source em Rust e C++. Algumas empresas em seu currículo são Ubisoft, Creditas, Chorus One, Nubank, Thoughtworks, Latam e Globo.com.</p>
<p>Por este livro, agradeço ao Otávio Pace, ao Bruno Tavares e ao pessoal da Rust in Poa (Julio Biason, Douglas, Ruan Nunes e a todos os exercícios do Exercism.io que fizemos).</p>
<p><a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="intro/2-Audience.html">Próximo</a></p>
<p><a href="intro/1-about.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="intro/3-book.html">Próximo</a></p>
<h1 id="audiência"><a class="header" href="#audiência">Audiência</a></h1>
<p>Este livro é para todas as pessoas que estão cansadas de lidar com projetos gigantes e arcaicos, com frameworks burocráticos e que têm muita dor de cabeça na hora de otimizar o código. Rust é uma linguagem de programação de baixo nível, como C, mas com abstrações de alto nível, como Ruby e JavaScript, que garante segurança na criação de processos e evita que threads diferentes concorram e mutem os mesmos dados ao mesmo tempo. Além disso, Rust cuida para ter duas características principais, uma comunidade inclusiva e uma linguagem de fácil entendimento, isso se mostra através dos milhares de livros completíssimos para aprender Rust e suas ferramentas. Infelizmente as partes de <code>macros</code>, <code>borrow checker</code> e <code>lifetimes</code> não são tão simples de aprender — acredito que sejam as partes mais difíceis do Rust —, mas acredito que o <code>borrow checker</code> será a única parte que você precisará conviver diariamente.</p>
<p>Existem alguns grandes casos de uso de Rust em produção, tirando a Mozilla, empresa criadora da linguagem e hoje uma das principais mantenedoras dela. Os maiores casos são:</p>
<ul>
<li><strong>NPM</strong> - Escalando um serviço ligado a CPU com bilhões de requests. Rust foi escolhido entre C, C++, Java e Go. C e C++ foram descartados devido à insegurança a nível de memória, Java por conta da necessidade de deployar a JVM e Go por ter tido uma performance pior que Rust com muito mais trabalho em relação a ferramental básico.</li>
<li><strong>Tilde</strong> - Tilde fez seu MVP para monitoramento do espaço com Ruby on Rails, mas infelizmente a quantidade brutal de memória consumida fazia com que eles não tivessem competitividade do produto. Avaliando uma solução em C++, perceberam que a quantidade de crashes podia aumentar exponencialmente e que treinar uma equipe rubysta para manter um código C++ era bem complicado. Foi aí que entrou o Rust, a ausência de coletor de lixo e a segurança em memória garantiram a performance que o projeto queria.</li>
<li><strong>Dropbox</strong> - Para a Dropbox, o diferencial do uso de Rust foi desenvolver um serviço que aumentasse a velocidade de entrega e que diminuísse o espaço consumido. Rust com seu runtime quase mínimo e sua performance excepcional foi a solução preferida.</li>
<li><strong>Discord</strong> - Quando o Elixir para de performar bem para a quantidade de dados que você precisa processar, está na hora de delegar esse processamento para quem é bom nisso. No caso do Discord foi o Rust.</li>
</ul>
<p>Ou seja, Rust é ideal para quem quer produzir serviços com performance excepcional, uma linguagem simples, pouco consumo de memória e muita felicidade. Acredito que seja um livro para pessoas que pelo menos já brincaram um ou dois dias com Rust, mas caso seja necessário, recomendo conferir os livros da documentação oficial e os maravilhosos livros que a Casa do Código possui sobre Rust antes de ler este.</p>
<p><a href="intro/2-Audience.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="intro/4-setup.html">Próximo</a></p>
<h1 id="como-este-livro-é-organizado"><a class="header" href="#como-este-livro-é-organizado">Como este livro é organizado</a></h1>
<p>Nos capítulos de introdução teremos um guia de instalação e um exercício básico. Nosso primeiro projeto será um servidor de gerenciamento de tarefas baseado em Actix Web. Actix Web é um framework de desenvolvimento web em Rust que tem feito muito barulho por suas constantes primeiras colocações em benchmarks de performance, principalmente da TechEmpower, e por algumas confusões pelo uso de <code>unsafe</code>. Acredito que o framework seja bastante simples de entender e muito completo, mais informações sobre os benchmarks no apêndice A. Vamos utilizar diversas ferramentas da stack Actix para garantir um serviço completo e algumas ferramentas clássicas da comunidade Rust, como Serde para serialização de JSON e clientes de bancos de dados. Para este projeto vamos utilizar DynamoDB como banco de dados via biblioteca Rusoto para salvar os dados de gerenciamento de tarefas e Postgres com Diesel para salvar informações de autorização. O padrão de arquitetura de software utilizado para esta parte é inspirado no framework Phoenix do Elixir. </p>
<p>Na segunda parte, vamos modelar um serviço que retorna valores e rotas de passagens aéreas via queries GraphQL. Esse serviço realizará requests para serviços reais e será desenvolvido no padrão de arquitetura Hexagonal, ou, como também é conhecido, Cebola, que é inspirado no livro <strong>Clean Architecture</strong> de Robert C. Martin. A idéia central deste padrão é separarmos funções puras na parte mais interna da arquitetura e funções impuras na parte mais externa. Na terceira parte do livro, que está associada à parte anterior, construiremos um front-end utilizando a Yew Stack, que é baseada em WebAssembly, para a representação das opções de passagens. Lembrando que HTML e CSS serão mantidos de forma primitiva por não serem o foco deste livro.</p>
<ul>
<li>Para a parte 2 do livro, recomendo conhecer os conceitos de GraphQL. Livros e tutoriais estão indicados na bibliografia. </li>
<li>Para a parte 3 do livro, recomendo conhecer os conceitos de WebAssembly. O livro oficial gratuito está indicado na bibliografia.</li>
</ul>
<h3 id="por-que-utilizar-o-dynamodb"><a class="header" href="#por-que-utilizar-o-dynamodb">Por que utilizar o DynamoDB</a></h3>
<p>Existem dois motivos para eu ter escolhido utilizar o DynamoDB para nosso serviço.</p>
<ol>
<li>Existem centenas de ótimos exemplos utilizando o banco Postgres com a crate Diesel. Inclusive integrados com AWS e em português. Além do mais, vamos utilizar o Postgres com Diesel, só que não como nosso principal banco de dados, já que é bastante comum aplicações diferentes possuirem mais de um tipo de banco de dados. A escolha do Diesel para o middleware de autorização não tem nenhuma relação com segurança ou performance, foi somente o recurso que me ocorreu usar no momento.</li>
<li>Em um mundo cada vez mais voltado para cloud, escolher uma tecnologia nativa de cloud parece uma boa solução.
Agora, isso não quer dizer que o DynamoDB seja o banco que modela perfeitamente nosso domínio ou as relações entre ele, mas é um banco com uma performance excepcional que permite muita flexibilidade ao modelar domínios. Alguns limites associados a transações e tipos no DynamoDB:</li>
</ol>
<ul>
<li>O tamanho máximo de uma String é limitada a 400KB, assim como para binários. </li>
<li>Uma String de expressão pode ter no máximo 4KB.</li>
<li>Uma transação não pode conter mais de 25 itens únicos, assim como não pode conter mais de 25MB de dados.</li>
<li>É possível ter até 50 requests simultâneos para criar, atualizar ou deletar tabelas.</li>
<li><code>BatchGetItem</code>, buscar um conjunto de itens pode trazer no máximo 100 itens e um total de 16MB de dados.</li>
<li><code>BatchWriteItem</code>, como <code>PutItem</code> e <code>DeleteItem</code>, pode conter até 25 itens e um total de 16MB de dados.</li>
<li><code>Query</code> e <code>Scan</code> tem um limite de 1MB por chamada.</li>
</ul>
<h3 id="phoenix-mvc"><a class="header" href="#phoenix-mvc">Phoenix MVC</a></h3>
<p>O que eu gosto no modelo que o Phoenix utiliza para organizar seus módulos é a divisão entre a lógica web e a lógica core, ou seja, ele separa a camada de comunicação com o mundo da camada de comunicação interna. Por exemplo, uma API chamada de <code>TodoApi</code> vai possuir módulos com os nomes <code>todo_api_web</code> para a lógica web e <code>todo_api</code> para a lógica core. O formato interno do <code>todo_api_web</code> é bastante comum e geralmente utiliza a nomenclatura do MVC, na qual seus modelos representando o domínio estão dentro de um módulo chamado <code>models</code>; seus operadores entre camadas, geralmente sem lógica, ou controllers, estão em um módulo chamado <code>controllers</code>, e as visualizações das telas estão em um módulo chamado <code>views</code>. Caso você esteja utilizando GraphQL, a divisão do MVC pode ficar um pouco diferente, como <code>queries</code> e <code>mutations</code> em um módulo de <code>schemas</code>, seus objetos de entrada e saída em um módulo chamado <code>models</code> e seus resolvers em um módulo <code>resolvers</code>. Seria esse padrão o <code>MRS</code> (<em>Models Resolvers Schema</em>)?</p>
<p>Quanto ao módulo <code>todo_api</code>, ele estaria organizado em um módulo para gerenciar a fonte dos dados, geralmente denominado <code>repo</code> ou <code>db</code>, e em um outro módulo para organizar as estruturas de dados correspondentes chamado de <code>models</code>. Aqui é comum existir uma camada que adapta os modelos de <code>todo_api</code> para <code>todo_api_web</code>, geralmente chamado de <code>adapters</code>. Para serviços que se comunicam por mensagens, é comum um módulo <code>message</code> aqui também. Resumindo graficamente seria:</p>
<pre><code>todo_api
    main
    |-&gt; todo_api
        |-&gt; adapters
        |-&gt; db (ou repo)
        |-&gt; message
        |-&gt; models
    |-&gt; todo_api_web
        |-&gt; controllers
        |-&gt; http (configurações do sistema e middlewares)
        |-&gt; models
        |-&gt; routes (rotas do sistema)
        |-&gt; views
</code></pre>
<h3 id="hexagonal"><a class="header" href="#hexagonal">Hexagonal</a></h3>
<p>O modelo hexagonal é mais simples em organização, e talvez mais fácil para quem estiver começando a trabalhar em um sistema, mas talvez menos prático para quem já conhece o sistema. Ele consiste em algumas camadas que vão das camadas impuras com efeitos colaterais chamadas de <code>boundaries</code> ou <code>diplomat</code> até as camadas mais puras chamadas de <code>core</code> ou <code>logic</code>, assim como as camadas de modelagem. No módulo <code>boundaries</code> vamos ter coisas como <code>web</code>, <code>db</code> e <code>messaging</code>, ou seja, qualquer coisa que cause efeitos colaterais. Depois disso vamos ter uma camada que recebe esses efeitos colaterais e chama funções puras para lidar com eles, comumente chamado de <code>controllers</code>. Os <code>controllers</code> utilizam principalmente duas camadas para tratar os efeitos colaterais, a camada de <code>adapters</code>, que transforma as entidades de <code>boundaries</code> em entidades internas, e a camada de <code>core</code>, que é dona de toda lógica do sistema, <code>core</code> pode ainda possuir uma separação de negócio, <code>business</code>, e outra computacional ou de apoio, <code>compute</code>. Por último, a parte mais interna são os <code>models</code>, que correspondem a estrutura de dados do sistema. Resumindo graficamente, em ordem de mais impura até mais pura, seria:</p>
<pre><code>todo_api
    main
    |-&gt; boundaries
        |-&gt; web
        |-&gt; db
        |-&gt; message
    |-&gt; controllers/resolvers
    |-&gt; adapters
    |-&gt; core 
        |-&gt; business
        |-&gt; compute
    |-&gt; models/schemas
</code></pre>
<h3 id="considerações"><a class="header" href="#considerações">Considerações</a></h3>
<ul>
<li>
<p>Qual nomenclatura ou quais nomes específicos você vai dar para seus módulos é menos relevante do que a forma como as coisas estarão organizadas, a única coisa importante de lembrar é a necessidade de seu código e sua organização ser inteligível para todas as pessoas.</p>
</li>
<li>
<p>Este livro utiliza apenas o framework Actix para servidores web, mas exemplos com outros frameworks podem ser encontrados no livro <code>Programação Funcional e Concorrente em Rust</code>. Actix é o framework de <code>actors</code> do Rust, e tem como framework web o <code>actix-web</code>. </p>
</li>
<li>
<p>A versão de Rust utilizada neste livro é a 1.40 da edição 2018, assim, caso a linguagem evolua mais rápido que o livro, você pode fazer Pull Request nos repositórios do livro. Só peço que explique no Pull Request a que parte ele se refere, qual a modificação, o porquê da modificação e caso ela derive de um erro preexistente, salientar o motivo. Algumas modificações na organização e renomeação de arquivos podem ser bastante interessantes também.</p>
</li>
</ul>
<p><a href="intro/2-Audience.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="intro/4-setup.html">Próximo</a></p>
<p><a href="intro/3-book.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="intro/5-exerc%C3%ADcio.html">Próximo</a></p>
<h1 id="instalando-rust"><a class="header" href="#instalando-rust">Instalando Rust</a></h1>
<p>O primeiro passo para instalar Rust é a instalação do <code>rustup</code>, uma ferramenta de linha de comando para gerenciar versões do Rust e todo ferramental a sua volta. Para fazer download do <code>rustup</code> em Linux e macOS, basta digitar <code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code> em seu terminal e seguir as instruções. Para a instalação em Windows, basta ir ao site https://www.rust-lang.org/tools/install e garantir que você possui o <code>C++ build tools for Visual Studio 2013</code> ou posterior instalado em sua máquina. </p>
<p>Para atualizar o <code>rustup</code>, basta digitar <code>rustup update</code> em seu terminal e, para desinstalar o Rust, <code>rustup self uninstall</code>. Caso você precise saber a versão do Rust, basta digitar <code>rustc --version</code> e você verá a resposta no formato <code>rustc x.y.z (abcabcabc yyyy-mm-dd)</code>, na qual <code>x.y.z</code> correspondente à versão, <code>abcabcabc</code> ao commit da versão <code>x.y.z</code> e <code>yyyy-mm-dd</code> à data da versão <code>x.y.z</code>. Se estiver desconectada da internet e quiser ver a documentação, basta digitar <code>rustup doc</code>.</p>
<p>Não esqueça de experimentar a utilização do <code>cargo</code>, gerenciador de pacotes e de build do Rust. Para ver se ele está bem em sua máquina, basta digitar <code>cargo --version</code>. Para criar um pacote, você pode digitar <code>cargo new &lt;nome do pacote&gt; --lib</code> e, para criar um executável, você pode digitar <code>cargo new &lt;nome do executável&gt; --bin</code>. Caso você omita as opções <code>--lib</code> e <code>--bin</code>, o padrão atual é criar um executável. </p>
<p>A minha experiência de desenvolvimento Rust tem sido muito agradável com o Racer e o RLS configurados no VSCode ou no emacs. Para o VSCode, basta adicionar os plugins <code>Rust</code> e <code>Rust (rls)</code>. Caso seu path do cargo tenha algum problema, será necessário apontar o caminho para o <code>racer</code> dentro do pacote do <code>cargo</code>.</p>
<p>Pronto, agora podemos resolver um exercício básico.</p>
<p><a href="intro/4-setup.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="intro/part-1/00-capa.html">Próximo</a></p>
<h1 id="exercício-maior-produto-de-uma-série"><a class="header" href="#exercício-maior-produto-de-uma-série">Exercício Maior Produto de uma Série</a></h1>
<p>Este exercício é retirado do site exercism.io da track de Rust, e em inglês é chamado de <em>Largest Series Product</em>. Ele consiste no seguinte problema:</p>
<blockquote>
<p>Dada uma string de dígitos, calcular o maior produto contínuo de uma substring de tamanho <code>n</code>. Por exemplo, para a string <code>&quot;1027839564&quot;</code> o maior produto com <code>n = 3</code> seria <code>9 * 5 * 6 = 270</code>, e o maior produto para <code>n = 5</code> seria <code>7 * 8 * 3 * 9 * 5 = 7560</code>.</p>
</blockquote>
<p>Você pode utilizar a ferramenta do exercism.io para realizar as configurações deste exercício. Para isso, pule para o subcapítulo <strong>Resolvendo o primeiro teste</strong>. Bom, a primeira coisa que precisamos fazer é criar uma lib para rodar esses testes. Para isso, executamos em nosso terminal <code>cargo new largest-series-product --lib &amp;&amp; cd largest-series-product</code>. Abra em seu editor favorito e seu projeto deverá ser da seguinte forma:</p>
<p><img src="intro/imagens/cargoproj.png" alt="Projeto de pacote básico do Cargo" /></p>
<p>Agora, precisamos criar uma pasta para conter todos os testes, a pasta <code>tests</code>. O padrão em Rust é que os testes de integração fiquem na pasta <code>tests</code> enquanto os testes unitários fiquem junto ao arquivo. Como o exercism já nos dispõe um conjunto bom de testes, podemos simplesmente colar eles no caminho <code>tests/largest-series-product.rs</code>. Os testes são:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use largest_series_product::*;

#[test]
fn return_is_a_result() {
    assert!(lsp(&quot;29&quot;, 2).is_ok());
}

#[test]
#[ignore]
fn find_the_largest_product_when_span_equals_length() {
    assert_eq!(Ok(18), lsp(&quot;29&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_two_with_numbers_in_order() {
    assert_eq!(Ok(72), lsp(&quot;0123456789&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_two_with_numbers_not_in_order() {
    assert_eq!(Ok(48), lsp(&quot;576802143&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_three_with_numbers_in_order() {
    assert_eq!(Ok(504), lsp(&quot;0123456789&quot;, 3));
}

#[test]
#[ignore]
fn find_the_largest_product_of_three_with_numbers_not_in_order() {
    assert_eq!(Ok(270), lsp(&quot;1027839564&quot;, 3));
}

#[test]
#[ignore]
fn find_the_largest_product_of_five_with_numbers_in_order() {
    assert_eq!(Ok(15120), lsp(&quot;0123456789&quot;, 5));
}

#[test]
#[ignore]
fn span_of_six_in_a_large_number() {
    assert_eq!(
        Ok(23520),
        lsp(&quot;73167176531330624919225119674426574742355349194934&quot;, 6)
    );
}

#[test]
#[ignore]
fn returns_zero_if_number_is_zeros() {
    assert_eq!(Ok(0), lsp(&quot;0000&quot;, 2));
}

#[test]
#[ignore]
fn returns_zero_if_all_products_are_zero() {
    assert_eq!(Ok(0), lsp(&quot;99099&quot;, 3));
}

#[test]
#[ignore]
fn a_span_is_longer_than_number_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;123&quot;, 4));
}

// There may be some confusion about whether this should be 1 or error.
// The reasoning for it being 1 is this:
// There is one 0-character string contained in the empty string.
// That's the empty string itself.
// The empty product is 1 (the identity for multiplication).
// Therefore LSP('', 0) is 1.
// It's NOT the case that LSP('', 0) takes max of an empty list.
// So there is no error.
// Compare against LSP('123', 4):
// There are zero 4-character strings in '123'.
// So LSP('123', 4) really DOES take the max of an empty list.
// So LSP('123', 4) errors and LSP('', 0) does NOT.
#[test]
#[ignore]
fn an_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;&quot;, 0));
}

#[test]
#[ignore]
fn a_non_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;123&quot;, 0));
}

#[test]
#[ignore]
fn empty_string_and_non_zero_span_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;&quot;, 1));
}

#[test]
#[ignore]
fn a_string_with_non_digits_is_an_error() {
    assert_eq!(Err(Error::InvalidDigit('a')), lsp(&quot;1234a5&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos explicar rapidamente o que estamos vendo aqui. A primeira linha contém <code>use largest_series_product::*;</code>, isso corresponde a uma diretiva de importar todas as funcionalidades (<code>::*</code>) do pacote <code>largest_series_product</code>. Poderíamos importar somente a diretiva <code>lsp</code> com <code>use largest_series_product::lsp;</code> ou mais de uma diretiva com <code>use largest_series_product::{lsp, db::xps}</code>. Note que a diretiva <code>xps</code> vem de um pacote interno chamado <code>db</code>. Nas linhas seguintes, percebemos as anotações <code>#[test]</code> e <code>#[ignore]</code>, consideradas atributos que indicam como essa função deve se comportar. No caso do atributo <code>#[test]</code>, a função descrita a seguir executará somente com a execução de testes no <code>cargo test</code>, enquanto o atributo <code>#[ignore]</code>, pulará esse teste. Depois disso, temos a declaração de uma função com o seguinte formato:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nome_da_funcao_em_snake_case() {
    //corpo da funcnao
    // ...
}
 pub fn nome_da_funcao_em_snake_case(arg1: TArgs1, arg2: TArgs2, // ... argn: TArgsn) -&gt; TResposta {
     //corpo da funcnao
    // ...
 }
<span class="boring">}
</span></code></pre></pre>
<p>Em Rust, a declaração de uma função começa com a palavra-chave <code>fn</code> seguida pelo nome da função em snake_case. Caso existam, os argumentos são separados como <code>argumento: TipoDoArgument</code> e, caso a função retorne algum tipo, se adiciona a linha <code>-&gt; TipoDeRetorno</code>. A última linha da função, caso não tenha <code>;</code> no final é sempre retornada. Agora para o corpo da função de teste vemos <code>assert!(lsp(&quot;29&quot;, 2).is_ok());</code>. <code>assert!</code> e <code>assert_eq!</code> são macros de teste de assertividade, isso quer dizer que <code>assert!</code> retorna verdade caso o argumento dentro de seu corpo seja verdadeiro, como lsp de 29 e duas casas é do tipo <code>Ok</code> (<code>lsp(&quot;29&quot;, 2).is_ok()</code>), e <code>assert_eq!</code> recebe dois argumentos, separados por vírgula e procura igualdade e identidade entre eles.</p>
<h2 id="resolvendo-o-primeiro-teste"><a class="header" href="#resolvendo-o-primeiro-teste">Resolvendo o primeiro teste</a></h2>
<p>Vamos para a primeira função que temos e vamos tentar dissecá-la:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn return_is_a_result() {
   assert!(lsp(&quot;29&quot;, 2).is_ok());
}
<span class="boring">}
</span></code></pre></pre>
<p>Sabemos que é uma função de teste, <code>#[test]</code>, e que existe uma chamada para função <code>lsp</code> que recebe dois argumentos, <code>&quot;29&quot;</code> (um <code>&amp;str</code>) e <code>2</code> (um <code>inteiro</code>). Além disso, sabemos que retorna um tipo <code>Result</code>, pois estamos esperando um resultado do tipo <code>Ok</code>. Para este teste passar precisamos fazer muito pouco, assim a implementação dele passa a ser:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub enum Error {
    SpanTooLong,
    InvalidDigit(char),
}

pub fn lsp(_: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    Ok(0u64)
}
<span class="boring">}
</span></code></pre></pre>
<p>Tanto faz o valor que retornamos para esse teste, pois somente queremos saber se é <code>Ok()</code>. Agora removemos o <code>#[ignore]</code> do teste a seguir e mudamos nosso <code>Ok(0u64)</code> para <code>Ok(18u64)</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_when_span_equals_length() {
    assert_eq!(Ok(18), lsp(&quot;29&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>O próximo teste nos exige um pouco mais:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_two_with_numbers_in_order() {
    assert_eq!(Ok(72), lsp(&quot;0123456789&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para este teste podemos pegar os dois últimos números da string e multiplicá-los.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    let mut digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
    digits.reverse();
    Ok(digits.iter().take(2).fold(1u64, |acc, i| acc * i))
}
<span class="boring">}
</span></code></pre></pre>
<p>Como sabemos que os dois últimos dígitos de ambos os casos são o maior produto, não precisamos nos preocupar muito com o resto. Assim, aplicamos a função <code>split(&quot;&quot;)</code> ao valor de entrada, que gerará um vetor contendo cada um dos elementos, como <code>vec![&quot;2&quot;, &quot;9&quot;]</code>, para o caso do <code>&quot;29&quot;</code>. Depois aplicamos um <code>parse</code> deles para o tipo inferido em <code>let mut digits: Vec&lt;u64&gt; =</code>, filtramos para evitar elementos que resultaram em <code>Err</code> e assim podemos utilizar o <code>unwrap</code> sem problemas. Coletamos tudo com o <code>collect</code> e revertemos a lista para obter somente os dois primeiros elementos, que após o <code>reverse</code> passaram de últimos a primeiros. Depois aplicamos o <code>.fold(1u64, |acc, i| acc * i))</code>, que inicia a multiplicação com um <code>1u64</code>, e depois multiplicamos cada um deles pelo acumulador <code>acc</code>. Tudo isso envolvido em um <code>Ok()</code>. Existem formas mais simples de resolver esse problema em Rust, como o uso de <code>slices</code>, mas acredito que seja uma boa solução para quem precisa revisar a linguagem.</p>
<p>Ao rodarmos o próximo teste, podemos perceber que nossa estratégia falha e que novas implementações são necessárias:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_two_with_numbers_not_in_order() {
    assert_eq!(Ok(48), lsp(&quot;576802143&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Felizmente parte de nossa solução, a variável <code>digits</code>, já é bastante útil, pois converteu a <code>&amp;str</code> em um vetor de <code>u64</code>. Agora precisamos de uma função que atue sobre os vetores e agrupe-os de dois em dois. Para poupar nosso tempo, a implementacão de <code>Vec</code> em Rust já possui uma função assim, ela chama <code>window</code> e recebe como argumento um <code>self</code> e um span do tipo <code>usize</code>, retornando um <code>Window&lt;T&gt;</code>, no qual <code>T</code> representa um genérico correspondente ao tipo do vetor. A struct <code>Window&lt;T&gt;</code> corresponde a um iterável com valores internos do tipo slice com o tamanho de cada slice do valor span <code>usize</code>, se fossemos comparar a um vetor seria um <code>vec![ &amp;[&quot;a&quot;, &quot;b&quot;], &amp;[&quot;b&quot;, &quot;c&quot;], &amp;[&quot;c&quot;, &quot;d&quot;], // ...]</code> para o afaltabeto separado <code>2usize</code>. Agora, precisamos de uma função que nos retorne o valor de cada <code>Window</code> e ordene os valores de forma que o maior seja o primeiro ou o último. Chamei essa função de <code>window_values</code>, e ela recebe como argumento o vetor que criamos anteriormente, <code>digits: Vec&lt;u64&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    let digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
            
    Ok(window_values(digits)
        .first()
        .unwrap()
        .to_owned())
}

fn window_values(digits: Vec&lt;u64&gt;) -&gt; Vec&lt;u64&gt; {
    let mut window_values = digits
        .windows(2usize)
        .map(|w| w.to_vec())
        .map(|v| v.iter().fold(1,|acc, i| acc * i))
        .collect::&lt;Vec&lt;u64&gt;&gt;();
    window_values.sort();
    window_values.reverse();
    window_values
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que a função <code>lsp</code> não mudou muito, o que mudou nela é que chamamos a função <code>window_values</code> com o <code>digits</code>, que deixou de ser mutável. Na função <code>window_values</code>, estamos criando windows de tamanho <code>2usize</code>, depois aplicando <code>map</code> para converter o tipo <code>&amp;[T;usize]</code> em vetor e, no <code>map</code> seguinte, transformamos esse vetor gerado em um iterável que consome eles em um fold de multiplicação. Depois ordenamos a lista de maior para menor, e depois revertemos para termos o maior produto como primeiro elemento (podíamos deixar sem o reverse e aplicar um <code>last</code> em vez de <code>first</code> à solução da função). A chamada de função <code>to_owned</code> ocorre porque o resultado do first é um <em>borrow</em>, ou seja <code>&amp;u64</code> e precisamos de um <code>u64</code>.</p>
<p>O próximo teste inclui apenas uma diferença: o valor de <code>span</code> deixa de ser <code>2</code> e passa a ser <code>3</code>. Para isso, precisamos passar span como argumento para <code>window_values</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_three_with_numbers_in_order() {
    assert_eq!(Ok(504), lsp(&quot;0123456789&quot;, 3));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora a solução passa a ser (note o valor <code>span</code> adicionado nas funções):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}

fn window_values(digits: Vec&lt;u64&gt;, span: usize) -&gt; Vec&lt;u64&gt; {
    let mut str_chunks = digits
        .windows(span)
        .map(|x| x.to_vec())
        .map(|i| i.iter().fold(1,|acc, x| acc * x))
        .collect::&lt;Vec&lt;u64&gt;&gt;();
    str_chunks.sort();
    str_chunks.reverse();
    str_chunks
}
<span class="boring">}
</span></code></pre></pre>
<p>Com essas mudanças, os próximos três testes passam sem grandes esforços:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_three_with_numbers_not_in_order() {
    assert_eq!(Ok(270), lsp(&quot;1027839564&quot;, 3));
}

#[test]
fn find_the_largest_product_of_five_with_numbers_in_order() {
    assert_eq!(Ok(15120), lsp(&quot;0123456789&quot;, 5));
}

#[test]
fn span_of_six_in_a_large_number() {
    assert_eq!(
        Ok(23520),
        lsp(&quot;73167176531330624919225119674426574742355349194934&quot;, 6)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Os testes seguintes também passam, mas quis separá-los para chamar a atenção em relação aos <code>0</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn returns_zero_if_number_is_zeros() {
    assert_eq!(Ok(0), lsp(&quot;0000&quot;, 2));
}

#[test]
fn returns_zero_if_all_products_are_zero() {
    assert_eq!(Ok(0), lsp(&quot;99099&quot;, 3));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, o próximo teste já falha, pois apesar de termos a implementação do tipo <code>Error</code>, não estamos usando o <code>Error</code>. Note que o teste consiste em retornar um Result<Err> por conta do tamanho da <code>window</code> ser maior que o tamanho total das strings:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn a_span_is_longer_than_number_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;123&quot;, 4));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos adicionar um <code>if</code> que valida se o tamanho da string é maior que o tamanho da <code>window</code>. <code>span &gt; string_digits.len()</code> e que caso verdadeiro retorne <code>Err(Error::SpanTooLong)</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    SpanTooLong,
    InvalidDigit(char),
}

pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }

    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Os próximos dois testes se referem à mesma coisa. Se o valor do <code>span</code> for zero, o resultado sempre será <code>Ok(1u64)</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn an_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;&quot;, 0));
}

#[test]
fn a_non_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;123&quot;, 0));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver esse teste basta adicionar mais um <code>if</code>, <code>if span == 0 { return Ok(1u64); }</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }

    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, o teste seguinte também passa:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn empty_string_and_non_zero_span_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;&quot;, 1));
}
<span class="boring">}
</span></code></pre></pre>
<p>O próximo e último teste traz um novo conceito: falha por conta de um dígito não válido, como um caractere alfabético. Vamos incluir este caractere como argumento do erro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn a_string_with_non_digits_is_an_error() {
    assert_eq!(Err(Error::InvalidDigit('a')), lsp(&quot;1234a5&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver esse teste precisamos fazer um <code>match</code> por tipos alfabéticos e retornar o primeiro que falha. O <code>if</code> que garante que existe uma falha é <code>if string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;().len() &gt; 0</code> e assim bastaria adicionar o seguinte código a <code>lsp</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }
    else if string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;().len() &gt; 0 {
        let digit = string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;();
        return Err(Error::InvalidDigit(digit
                .first().unwrap()
                .to_owned()
                .to_string()
                .pop().unwrap()));
    }

    let digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, com o resultado de <code>string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;()</code> podemos obter o primeiro com <code>first</code>, e depois aplicar o <code>pop</code> para retirar o valor de <code>char</code>. Além disso, podemos perceber que a conta <code>string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;()</code> está sendo executada duas vezes, assim podemos extrair para um valor, <code>v_alphanumeric</code>, antes dos ifs/elses:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    let v_alphanumeric = string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;();
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }
    else if v_alphanumeric.len() &gt; 0 {
        return Err(Error::InvalidDigit(v_alphanumeric
                .first().unwrap()
                .to_owned()
                .to_string()
                .pop().unwrap()));
    }
// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora que revisamos Rust podemos iniciar nosso primeiro serviço.</p>
<p><a href="intro/4-setup.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="intro/part-1/00-capa.html">Próximo</a></p>
<p><a href="part-1/intro/5-exerc%C3%ADcio.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/01-ping-pong.html">Próximo</a></p>
<h1 id="todo-server-com-actix"><a class="header" href="#todo-server-com-actix">Todo Server com Actix</a></h1>
<p>Nesta primeira parte vamos desenvolver um Todo Server aplicando um modelo semelhante ao MVC do projeto Phoenix, da comunidade Elixir. Este modelo foi explicado no capítulo <code>Como este livro é organizado</code>, mas agora vamos detalhar um pouco quais serão as características deste serviço.</p>
<p>Vamos criar um RESTful Todo Server que seria facilmente utilizado em produção pois contará com uma série de recursos como:</p>
<ol>
<li>Endpoints de monitoramento:
<ul>
<li><code>ping</code> que funciona como <code>health check</code>.</li>
<li><code>~/ready</code> que funciona como disponibilidade do servico, <code>readiness probe</code>.</li>
</ul>
</li>
<li>Endpoints para salvar as informações dos <code>TODO</code>s, <code>create</code> <code>show</code> <code>show-by-id</code> e <code>update</code>.</li>
<li>Sistema de logs, headers padrão e middlewares de autenticação.</li>
<li>Endpoints de autenticação, com <code>signup</code>, <code>login</code> e <code>logout</code> utilizando tokens <code>JWT</code> e banco de dados Postgres via Diesel.</li>
<li>Bastion para tornar o sistema tolerante a falhas.</li>
<li>Dockerização de todos os serviços.</li>
<li>CI executando as pipelines de teste.</li>
<li>Serde para serialização e deserialização de Json.</li>
</ol>
<p><a href="part-1/00-capa.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/02-create.html">Próximo</a></p>
<h1 id="configurando-os-primeiros-endpoints"><a class="header" href="#configurando-os-primeiros-endpoints">Configurando os primeiros endpoints</a></h1>
<p>O nosso objetivo inicial é fazer nosso servidor responder <code>pong</code> na rota <code>/ping</code> e executar uma função de baixo custo na rota <code>/~/ready</code> retornando 200 ou algum valor de status superior a 400, bastante simples. O objetivo disso é definir em nosso servidor endpoints que respondam se o servidor está disponível e saudável, <code>/ping</code>, assim como responder se esta pronto para executar mais uma operação, <code>/~/ready</code>. Para isso, precisamos criar nosso <code>todo-server</code> com o cargo rodando o comando <code>cargo new todo-server --bin</code>, que irá gerar os arquivos a seguir:</p>
<ol>
<li>todo-server/src/main.rs</li>
<li>todo-server/Cargo.lock </li>
<li>todo-server/Cargo.toml</li>
</ol>
<p>O arquivo <code>main.rs</code> é bastante simples, pois possui somente uma linha executando uma impressão no console de <code>&quot;Hello, world!&quot;</code> da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Já o arquivo <code>Cargo.toml</code> possui todas as informações sobre o binário gerado:</p>
<pre><code class="language-toml">[package]
name = &quot;todo-server&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Julia Naomi @naomijub&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>Já o arquivo <code>Cargo.lock</code> corresponde às configurações geradas para o <code>Cargo.toml</code> com o registro de versões de dependências, assim como o <code>package-lock.json</code> no Node.</p>
<h2 id="adicionando-actix"><a class="header" href="#adicionando-actix">Adicionando Actix</a></h2>
<p>Nossa principal dependência é o <code>Actix</code>, assim precisamos adicionar a dependência <code>actix-web = &quot;2.0&quot;</code> à seção <code>[dependencies]</code> do <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;todo-server&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Julia Naomi @naomijub&quot;]
edition = &quot;2018&quot;

[dependencies]
actix-web = &quot;2.0&quot;
</code></pre>
<h3 id="implementando-o-endpoint-ping"><a class="header" href="#implementando-o-endpoint-ping">Implementando o endpoint <code>/ping</code></a></h3>
<p>Este endpoint é comum a muitos serviços, mas em alguns casos é chamado de <code>/healthy</code>, <code>/healthcheck</code> ou <code>/~/healthy</code>, digamos que seja um exemplo com aplicações práticas de um <code>hello world</code>. Neste primeiro momento vamos apresentar primeiro a implementção do <code>/ping</code> e depois explicar, pois acredito que neste caso seja importante ter visão do todo antes de entrar nos detalhes. Assim, uma implementação bem simples de <code>/ping</code> seria:</p>
<pre><pre class="playground"><code class="language-rust">use actix_web::{web, App, HttpResponse, HttpServer, Responder};

async fn pong() -&gt; impl Responder {
   HttpResponse::Ok().body(&quot;pong&quot;)
}

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
   HttpServer::new(|| {
       App::new().service(
           web::scope(&quot;/&quot;)
               .route(&quot;ping&quot;, web::get().to(pong))
               .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
       )
   })
   .workers(6)
   .bind(&quot;127.0.0.1:4000&quot;)
   .unwrap()
   .run()
   .await
}
</code></pre></pre>
<p>E seu funcionamento seria:</p>
<p><img src="part-1/imagens/pingpong.png" alt="Endpoint /ping" /></p>
<p><img src="part-1/imagens/notfound.png" alt="Endpoint Not Found para a rota /" /></p>
<p>Agora podemos começar a descrever o endpoint <code>/ping</code>: </p>
<ol>
<li>A primeira coisa que vemos é a diretiva <code>use</code> associada a lib <code>actix_web</code>. Essa dirtiva nos permite disponibilizar no nosso código as funções e estruturas de <code>actix_web</code> para uso posterior, assim a diretiva <code>use actix_web::HttpServer</code> disponibilizaria a estrutura <code>HttpServer</code> para usarmos. </li>
<li>Depois vemos a função <code>async fn pong() -&gt; impl Responder</code>. Essa função é uma função assíncrona, devido as palavras reservadas <code>async fn</code>, cujo nome é <code>pong</code>, recebe nenhum argumento <code>()</code> e como tipo de resposta implementa a trait <code>Responder</code>, que tem como tipo de retorno <code>Future&lt;Output = Result&lt;Response, Self::Error&gt;&gt;</code>. A resposta de <code>pong</code> é um status code <code>Ok()</code> com um <code>body(&quot;pong&quot;)</code>, porém seria possível também implementar com a função <code>with_status</code> da trait <code>Responder</code>, ficando <code>&quot;pong&quot;.with_status(StatusCode::NotFound)</code>, que seria classificado como um <code>CustomResponder</code>, ou um <code>Responder</code> customizado.</li>
<li>a seguir encontramos a macro <code>#[actix_rt::main]</code>, essa macro exige adicionarmos uma nova dependência ao <code>Cargo.toml</code>, <code>actix-rt = &quot;1.0&quot;</code>. A função dessa macro é executar qualquer função marcada como <code>async</code> no runtime de actix.</li>
<li>Agora temos a função de execução <code>main</code> como <code>async fn main() -&gt; std::io::Result&lt;()&gt; </code>. É principalmente aqui que entra a macro <code>#[actix_rt::main]</code>, já que ela nos permite utilizar a função <code>main</code> como <code>async</code>. Assim, essa função <code>main</code> é basicamente um código padrão para conformar com a macro.</li>
<li>A linha <code>HttpServer::new(|| {..})</code> permite criar um servidor HTTP com uma <code>application factory</code>, assim como permite configurar a instância do servidor, como <code>workers</code> e <code>bind</code>, que veremos a seguir.</li>
<li>Assim, a linha <code>App::new().service(..)</code> é um <code>application builder</code> baseado no padrão <em>builder</em> para o <code>App</code>, que é uma struct correspondente a aplicação do actix-web, seu objetivo é configurar rotas e settings padrões. A função <code>service</code> registra um serviço no servidor, já a função <code>web::scope(&quot;/&quot;)</code> define um escopo comum para as rotas a seguir, e o <code>route</code> define as rotas.</li>
<li>Quanto a rota, <code>.route(&quot;/ping&quot;, web::get().to(pong))</code>, primeiro deve se passar uma <code>&amp;str</code> com a rota a partir do escopo comum, depois um método de chamada HTTP como <code>GET</code> e <code>POST</code>, representados por <code>web::get()</code> e <code>web::post()</code> e uma função de envio do request como <code>.to(pong)</code>.</li>
<li>O módulo <code>web</code> possui uma série de funções auxiliares e e tipos auxiliares para o actix-web.</li>
<li>Depois disso, vemos <code>workers(6)</code>, uma função de <code>HttpServer</code> que define a quantidade de threads trabalhadoras que estarão envolvidas nesse executável. Por padrão, o valor de <code>workers</code> é a quantidade de CPUs lógicas disponíveis.</li>
<li>Agora temos o <code>bind</code>, que recebe o IP e a porta a qual esse servidor se conectará.</li>
<li><code>run</code> e <code>await</code> para executar o serviço e esperar pelo <code>async</code> definido anteriormente.</li>
</ol>
<p>É importante também implementarmos um teste para <code>NOT_FOUND</code>. Esse teste consiste em um request para uma rota que não existe e um status <code>NOT_FOUND</code>: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
    async fn not_found_route() {
        let mut app = test::init_service(
            App::new().service(
            web::scope(&quot;/&quot;)
                .route(&quot;ping&quot;, web::get().to(pong))
                .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
            )
        ).await;

        let req = test::TestRequest::get()
            .uri(&quot;/crazy-route&quot;)
            .to_request();

        let resp = app.call(req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::NOT_FOUND);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementando-o-endpoint-ready"><a class="header" href="#implementando-o-endpoint-ready">Implementando o endpoint /~/ready</a></h3>
<p>Este endpoint é comum especialmente em serviços kubernetes e sua execução é via <code>kubectl</code>. Usualmente o <code>kubectl</code> espera que o processo ocorra via HTTP, TCP-gRPC ou uma execução de comando no contêiner. Para um contexto simples de contêineres, ter esse endpoint permite um monitoramento mais elevado de serviços, como os <em>Golden Signals</em> (sinais dourados apresentados pelo Google no livro Engenharia de Confiabilidade de Sites). Assim, ele permite um pouco mais de informações além de saber se o servidor está vivo (<code>/ping</code>), já que verifica se o serviço é capaz de realizar um pequeno processo. Outros endpoints comuns para esse tipo de prova são <code>/readiness</code> ou <code>/~/readiness</code>. O nosso endpoint vai executar um simples <code>$ echo hello</code> e retornar <code>accepted</code> para um resultado <code>Ok</code> e <code>internal server error</code> para um resultado <code>Err</code>. </p>
<p>O primeiro passo para essa prova é definir a rota que vamos chamar, no caso <code>/~/ready</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::new().service(
  web::scope(&quot;/&quot;)
    .route(&quot;ping&quot;, web::get().to(pong))
    .route(&quot;~/ready&quot;, web::get().to(readiness))
    .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
)
<span class="boring">}
</span></code></pre></pre>
<p>Note que o endpoint está implementado como rota, mas não como função de <code>Responder</code>, que chamamos de <code>readiness</code>. Para implementarmos esse <code>Responder</code>, podemos usar a seguinte função:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn readiness() -&gt; impl Responder {
    let process = std::process::Command::new(&quot;sh&quot;)
            .arg(&quot;-c&quot;)
            .arg(&quot;echo hello&quot;)
            .output();

    match process {
        Ok(_) =&gt; HttpResponse::Accepted(),
        Err(_) =&gt; HttpResponse::InternalServerError(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que criamos um valor chamado <code>process</code> que é um comando executado pela crate de <code>OS</code> <code>std::process::Command</code>. Para o <code>readiness</code> o comando que estamos executando é <code>sh -c echo hello</code>, que imprime <code>hello</code> no console. Depois disso fazemos pattern matching do resultado e se for <code>Ok</code> retornamos um <code>2XX</code> ou retornamos <code>500</code> para um <code>Err</code>.</p>
<h3 id="refatorando"><a class="header" href="#refatorando">Refatorando</a></h3>
<p>Agora que nosso código está funcionando podemos começar a pensar em organizá-lo, já que nosso arquivo <code>main</code> está com muitas funções. A ideia é seguir o padrão do framework Phoenix do Elixir, assim vamos separar o código em  3 conjuntos:</p>
<ol>
<li><code>main.rs</code>, que contém todas as informações de configuração do servidor, ou seja, a própria instância do servidor.</li>
<li><code>todo_api</code>, que contém todos os módulos responsáveis por lógica e banco de dados.</li>
<li><code>todo_api_web</code>, que contém todos os módulos responsáveis pelo gerenciamento do conteúdo web, como views e controllers, no nosso caso somente controllers.</li>
</ol>
<p>Assim, nossa primeira refatoração seria mover as funcões que implementam a trait <code>Responder</code> para um módulo de controller, <code>src/todo_api/controller/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, Responder};

pub async fn pong() -&gt; impl Responder {
    HttpResponse::Ok().body(&quot;pong&quot;)
}

pub async fn readiness() -&gt; impl Responder {
    let process = std::process::Command::new(&quot;sh&quot;)
            .arg(&quot;-c&quot;)
            .arg(&quot;echo hello&quot;)
            .output();

    match process {
        Ok(_) =&gt; HttpResponse::Accepted(),
        Err(_) =&gt; HttpResponse::InternalServerError(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, nosso arquivo <code>main.rs</code> agora consome nosso módulo:</p>
<pre><pre class="playground"><code class="language-rust">use actix_web::{web, App, HttpResponse, HttpServer};

mod todo_api_web;

use todo_api_web::controller::{pong, readiness};

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new().service(
            web::scope(&quot;/&quot;)
                .route(&quot;ping&quot;, web::get().to(pong))
                .route(&quot;~/ready&quot;, web::get().to(readiness))
                .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
        )
    })
    .workers(6)
    .bind(&quot;127.0.0.1:4000&quot;)
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<p>Note a presença do módulo <code>todo_api_web</code> declarado como <code>mod todo_api_web;</code> e importando as funções <code>pong</code> e <code>readiness</code> através de <code>use todo_api_web::controller::{pong, readiness};</code>. Além disso, na imagem a seguir podemos perceber a presença de um arquivo <code>lib.rs</code> no sistema de arquivos, esse arquivo serve para podermos exportar nossos módulos internos para testes de integração. Assim, atualmente o único módulo declarado em <code>lib.rs</code> é <code>pub mod todo_api_web;</code>.</p>
<p><img src="part-1/imagens/basicfilesystem.png" alt="Sistema de arquivos após a refatoração" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//src/todo_web_api/mod.rs
pub mod controller;
<span class="boring">}
</span></code></pre></pre>
<p>Outro ponto que creio ser interessante rafatorar é dar a capacidade de nosso servidor adaptar o número de <code>workers</code> a quantidade de cores lógicos que a máquina hospedeira possui. Por exemplo, minha máquina pessoal possui 4 cores lógicos e decidi usar uma estratégia de leve estresse aos cores que geralmente se resume a <code>número de cores lógicos + 2</code>, ela se torna uma opção segura pelo fato de estarmos utilizando <code>async</code> no nosso serviço, ou seja, defini 6 <code>workers</code>, mas se meu computador possuísse 8 cores lógicos, eu poderia estar utilizando 10 <code>workers</code>. Para resolver este problema podemos utilizar uma lib conhecida como <code>num_cpus</code>, basta adicionar ela ao <code>[dependencies]</code> do Cargo.toml <code>num_cpus = &quot;1.0&quot;</code> e substituir em nosso código da seguinte maneira:</p>
<pre><pre class="playground"><code class="language-rust">async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new().service(
            web::scope(&quot;/&quot;)
                .route(&quot;ping&quot;, web::get().to(pong))
                .route(&quot;~/ready&quot;, web::get().to(readiness))
                .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
        )
    })
    .workers(num_cpus::get() + 2)
    .bind(&quot;127.0.0.1:4000&quot;)
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<h2 id="testando-os-endpoints"><a class="header" href="#testando-os-endpoints">Testando os endpoints</a></h2>
<p>Uma coisa importante antes de continuarmos é criarmos testes para os endpoints implementados, especialmente agora que já aprendemos como funciona o a criação de rotas e controllers. No caso de rotas e controllers é mais eficiente começar com testes de integração, inclusive por já termos implementado as rotas anteriormente. Assim, precisamos criar alguns arquivos para executar nossos testes de integração. O primeiro arquivo que precisamos é o arquivo <code>lib</code> dentrod e <code>tests</code>, <code>tests/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate todo_server;

mod todo_api_web;
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, agora precisamos criar o módulo <code>todo_api_web</code> com um módulo interno <code>controller</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/todo_api_web/mod.rs
mod controller;
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos começar a criar os testes de controller no arquivo <code>tests/todo_api_web/controller.rs</code>. O primeiro teste que vamos escrever é a verificação se o conteúdo de texto da rota <code>/ping</code> é <code>pong</code>. Para isso, precisamos utilizar um módulo de suporte para testes do actix chamado <code>actix_web::test</code> e incorporar como <code>[dev-dependencies]</code> duas libs que nos apoiarão no uso de testes, a <code>bytes = &quot;0.5.3&quot;</code> para processar os bytes da resposta gerada no endpoint, e a <code>actix-service = &quot;1.0.5&quot;</code>, que apoia nos testes para chamar um mock de <code>App</code> do actix na rota desejada. Sugiro isolar os testes dos controllers <code>pong</code> e <code>readiness</code> em um módulo conforme a seguir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ping_readiness {
    use todo_server::todo_api_web::controller::{pong, readiness};

    use bytes::Bytes;
    use actix_web::{
        test, web, App,
    };

    #[actix_rt::test]
    async fn test_ping_pong() {
        let mut app = test::init_service(
            App::new().service(
                web::resource(&quot;/ping&quot;)
                .route(web::get().to(pong))
            )
        ).await;

        let req = test::TestRequest::get()
            .uri(&quot;/ping&quot;)
            .to_request();
        let resp = test::read_response(&amp;mut app, req).await;

        assert_eq!(resp, Bytes::from_static(b&quot;pong&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>O teste apresentado possui uma macro de teste diferente do usual no Rust. Em vez de ser <code>#[test]</code>, utilizamos uma macro de teste que disponibiliza o runtime de actix com <code>#[actix_rt::test]</code>. Além disso, note que agora nossa função de teste passa a ser <code>async</code> e utilizamos vários <code>await</code> dentro do teste.</p>
<p>Agora vamos explicar as partes do teste: <code>test::init_service</code> disponibiliza um mock de serviço do Actix que recebe como argumento um tipo <code>App</code> com a rota, <code>web::resource(&quot;/ping&quot;)</code>, e designa a essa rota um controller, <code>.route(web::get().to(pong))</code>. Além disso, criamos uma instância de <code>Request</code> para teste com <code>test::TestRequest</code> utilizando o método <code>get()</code> na <code>uri(&quot;/ping&quot;)</code>. Depois disso, a <code>resp</code> corresponde a ler a resposta que esse serviço <code>app</code> daria para o <code>Request</code> <code>req</code>. Como a resposta de <code>read_response</code> são <code>bytes</code>, precisamos da biblioteca <code>byte</code> para converter o array de <code>u8</code>, <code>b&quot;pong&quot;</code>, em <code>bytes</code> e fazer a comparação de igualdade.</p>
<p>Com o teste de <code>pong</code> implementado, podemos criar o teste de <code>readiness</code>. No teste de <code>readiness</code> não nos interessa saber o corpo da resposta, assim a sugestão é somente saber se a execução retornou um status <code>Accepted</code>. Para esse teste, vamos utilizar o recurso da crate <code>actix-service</code>, que nos possibilita fazer chamadas a um serviço através de <code>&lt;App&gt;.call(&lt;Request&gt;).await</code>. Assim podemos utilizar o <code>call</code> para retornar uma response, na qual podemos acessar o <code>status()</code>. O bloco de testes fica assim:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ping_readiness {
    use todo_server::todo_api_web::controller::{pong, readiness};

    use bytes::Bytes;
    use actix_web::{
        test, web, App,
        http::StatusCode,
    };
    use actix_service::Service;

    #[actix_rt::test]
    async fn test_ping_pong() {
        // ...
    }

    #[actix_rt::test]
    async fn test_readiness_ok() {
        let mut app = test::init_service(
            App::new()
                .service(web::resource(&quot;/readiness&quot;).to(readiness))
        ).await;
    
        let req = test::TestRequest::with_uri(&quot;/readiness&quot;).to_request();
    
        let resp = app.call(req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::ACCEPTED);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com tudo testado, o próximo passo é configurar nosso serviço para criar uma tarefa todo.</p>
<ul>
<li>O código deste capítulo está na bibliografia e solicitações de mudança serão bem vindas para manter o código exemplo atualizado.</li>
</ul>
<p><a href="part-1/00-capa.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/02-create.html">Próximo</a></p>
<p><a href="part-1/01-ping-pong.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/03-get.html">Próximo</a></p>
<h1 id="criando-tarefas"><a class="header" href="#criando-tarefas">Criando tarefas</a></h1>
<p>O primeiro passo para criar nossa tarefa será entender o que é uma tarefa. A ideia de uma tarefa é conter informações sobre ela e que outras pessoas do time tenham visibilidade do que se trata a tarefa. Assim vamos começar por modelar o domínio de entrada e saída. Usaremos a <code>struct</code> do Rust para modelar:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Task {
    is_done: bool,
    title: String
}

enum State {
    Todo,
    Doing,
    Done,
}

struct TodoCard {
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;Task&gt;,
    state: State
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, nossa struct principal é a <code>TodoCard</code>, que possui os campos <code>String</code> <code>title</code> e <code>description</code>, correspondentes ao título da tarefa e a sua descrição. Depois disso, podemos ver que existe um campo do tipo <code>Uuid</code> (inclua a crate <code>uuid</code> com as <code>features</code> <code>serde</code> e <code>v4</code> ativadas em seu <code>Cargo.toml</code>), que é um <code>owner</code>, ou seja, a pessoa dona da tarefa. Cada tarefa possui um conjunto de subtarefas a fazer, que podem estar completas ou não. Essas subtarefas são chamadas de <code>Task</code>, e é uma struct que possui um título, <code>title</code>, e um estado booleano que chamamos de <code>is_done</code>. Em seguida temos o estado da tarefa no fluxo de cards, <code>state</code>, que corresponde ao enum <code>State</code>, com os campos <code>Todo</code>, <code>Doing</code> e <code>Done</code>. O primeiro passo do serviço será algo bastante simples, receber um <code>POST</code> JSON com o <code>TodoCard</code> e respondermos um <code>TodoCardId</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoCardId {
    id: Uuid
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Uuid</strong></p>
<p>A crate Uuid possui várias configurações, mas para o que vamos utilizar precisamos de compatibilidade com <code>Serde</code> e a versão 4. Serde para garantir que ela é serializável e desserializável para JSON, e versão 4, pois é o formato que vamos utilizar. Assim, essas configurações são adicionadas ao <code>[dependencies]</code> do <code>Cargo.toml</code> como <code>uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }</code>.</p>
</blockquote>
<p>Um exemplo de <code>POST</code> em json de uma <code>TodoCard</code> seria:</p>
<pre><code class="language-json">{
    &quot;title&quot;: &quot;This is a card&quot;,
    &quot;description&quot;: &quot;This is the description of the card&quot;,
    &quot;owner&quot;: &quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;,
    &quot;tasks&quot;: [
        {
            &quot;title&quot;: &quot;title 1&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 2&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 3&quot;,
            &quot;is_done&quot;: false
        }
    ],
    &quot;state&quot;: &quot;Doing&quot;
}
</code></pre>
<p>Agora que modelamos nosso <code>TodoCard</code> podemos começar sua implementação com testes.</p>
<h2 id="criando-o-primeiro-teste-de-todocard"><a class="header" href="#criando-o-primeiro-teste-de-todocard">Criando o primeiro teste de <code>TodoCard</code></a></h2>
<p>O novo teste envolve uma série de alterações no código, como criar um novo <code>scope</code> para rotas de <code>api</code>, enviar <code>payloads</code> e responder objetos JSON. Assim, a estratégia desse teste vai envolver enviar um <code>TodoCard</code> para ser criado e termos como resposta um JSON contendo o id desse <code>TodoCard</code>. Lembrando que agora que vamos manipular JSON, precisamos poder serializar e desserializar eles, e para isso devemos incluir a biblioteca <code>serde</code> no Cargo.toml:</p>
<pre><code class="language-toml">// ...
[dependencies]
actix-web = &quot;2.0&quot;
actix-rt = &quot;1.0&quot;
uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
num_cpus = &quot;1.0&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
actix-service = &quot;1.0.5&quot;
</code></pre>
<p>Assim, podemos escrever nosso teste sem conflito de dependências em <code>tests/todo_api_web/controller.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod create_todo {
    use todo_server::todo_api_web::{
        controller::todo::create_todo,
        model::TodoIdResponse,
    };

    use actix_web::{
        test, web, App,
    };
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        String::from(
            &quot;{
                \&quot;title\&quot;: \&quot;This is a card\&quot;,
                \&quot;description\&quot;: \&quot;This is the description of the card\&quot;,
                \&quot;owner\&quot;: \&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442\&quot;,
                \&quot;tasks\&quot;: [
                    {
                        \&quot;title\&quot;: \&quot;title 1\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 2\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 3\&quot;,
                        \&quot;is_done\&quot;: false
                    }
                ],
                \&quot;state\&quot;: \&quot;Doing\&quot;
            }&quot;
        )
    }

    #[actix_rt::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(
            App::new()
                .service(
                    web::resource(&quot;/api/create&quot;)
                    .route(web::post().to(create_todo))
            )
        ).await;
    
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(post_todo().as_bytes().to_owned())
            .to_request();

        let resp = test::read_response(&amp;mut app, req).await;

        let id: TodoIdResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Duas características já se destacam, <code>controller::todo::create_todo</code> e <code>model::TodoIdResponse</code>, que correspondem ao recursos que de fato estão sendo testados. <code>TodoIdResponse</code> corresponde ao Json com o id de criação da <code>TodoCard</code>, sua definição é a seguinte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct TodoIdResponse {
    id: Uuid,
}
<span class="boring">}
</span></code></pre></pre>
<p>Perceba que utilizamos as macros de <code>Serialize, Deserialize</code> para sua fácil conversão entre JSON e String. Além disso, <code>TodoIdResponse</code> possui um campo <code>id</code> que é do tipo <code>Uuid</code>, um <code>Uuid</code> do tipo <code>v4</code>, conforme definimos no <code>Cargo.toml</code>. Agora temos também o controller <code>create_todo</code>, que receberá um <code>POST</code> do tipo JSON, fará sua inserção no banco de dados e retornará seu id. Felizmente, para este primeiro momento, não precisamos fazer a inserção no banco, pois o teste espera somente um tipo de retorno <code>id</code>. </p>
<p>Outro ponto importante é o uso da biblioteca <code>use serde_json::from_str;</code>. Essa função em especial serve para converter uma <code>&amp;str</code> em uma das structs serializáveis, conforme a linha <code>let id: TodoIdResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();</code>. Note que como a função não sabe para qual struct deve converter a resposta <code>resp</code>, tivemos de definir seu tipo na declaração do valor id, <code>id: TodoIdResponse</code>. O JSON do <code>payload</code> do <code>POST</code> está definido como uma string na função auxiliar de teste <code>post_todo</code>.</p>
<p>A seguir possuímos a definição do teste e o uso do runtime do actix, seguidos da definição do <code>App</code>, que vamos utilizar para mockar o serviço e suas rotas:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//definição do teste
#[actix_rt::test]
async fn valid_todo_post()
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Definição do App
let mut app = test::init_service(
    App::new()
        .service(
            web::resource(&quot;/api/create&quot;)
            .route(web::post().to(create_todo))
    )
).await;
<span class="boring">}
</span></code></pre></pre>
<p>Note duas mudanças na definição do <code>App</code>: nossa rota possui um padrão diferente <code>/api/create</code> e o controller <code>create_todo</code> está sendo passado para um método <code>post()</code>. Outro detalhe é que estamos utilizando mais recursos na criação do request:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let req = test::TestRequest::post()
    .uri(&quot;/api/create&quot;)
    .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
    .set_payload(post_todo().as_bytes().to_owned())
    .to_request();
<span class="boring">}
</span></code></pre></pre>
<p>Veja que <code>TestRequest</code> agora instancia um tipo <code>POST</code> antes de adicionar informações ao seu builder, <code>TestRequest::post()</code>. As duas outras mudanças são a adição das funções <code>header</code> e <code>set_payload</code>, <code>.header(&quot;Content-Type&quot;, &quot;application/json&quot;).set_payload(post_todo().as_bytes().to_owned())</code>. <code>header</code> define o tipo de conteúdo que estamos enviando e sua ausência nesse caso pode implicar em uma resposta com o status <code>400</code>. <code>set_payload</code> recebe um array de bytes com o conteúdo do <code>payload</code>, ou seja <code>post_todo</code>.</p>
<p>Depois podemos ler a resposta normalmente, <code>let resp = test::read_response(&amp;mut app, req).await;</code>, e transformar essa resposta em uma struct conhecida pelo serviço, <code>let id: TodoIdResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();</code>. O último passo é garantir que a resposta contendo o <code>TodoIdResponse</code> seja de fato um id válido e para isso utilizamos a macro <code>assert!</code> em <code>assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());</code>. Note a função auxiliar <code>get_id</code>, se nosso teste estivesse dentro do nosso módulo em vez de na pasta de testes de integração, seria possível anotar ela com <code>#[cfg(test)]</code> e economizar espaço no executável e tempo de compilação. Eu optei por deixá-la visível e testar o controller nos testes de integração, mas a escolha é sua:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TodoIdResponse {
    // #[cfg(test)]
    pub fn get_id(self) -&gt; String {
        format!(&quot;{}&quot;, self.id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementando-o-controller-do-teste-anterior"><a class="header" href="#implementando-o-controller-do-teste-anterior">Implementando o controller do teste anterior</a></h3>
<p>Agora, com o teste implementado, precisamos entender quais são as coisas que necessitamos implementar:</p>
<ol>
<li>Controller <code>create_todo</code>.</li>
<li>O controller recebe um Json do tipo <code>TodoCard</code> , que precisa ser deserializável com a macro <code>#[derive(Deserialize)]</code>.</li>
<li>Um struct <code>TodoIdResponse</code> que precisa ser serializável com <code>#[derive(Serialize)]</code>.</li>
</ol>
<p>Como os itens 2 e 3 já foram mencionados na seção anterior, vou mostrar como eles ficaram com as macros de serialização e desserialização. Além disso, inclui a macro de <code>Debug</code>, pois pode ser útil durante o desenvolvimento, se você achar necessário retirá-la no futuro pode ajudar a economizar espaço do binário.</p>
<ul>
<li>Para utilizar as macros de serde, lembre-se de incluir <code>#[macro_use] extern crate serde;</code> em <code>lib.rs</code> e em <code>main.rs</code> (versões mais antigas do Rust).</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/model/mod.rs
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug)]
struct Task {
    is_done: bool,
    title: String,
}

#[derive(Serialize, Deserialize, Debug)]
enum State {
    Todo,
    Doing,
    Done,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct TodoCard {
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;Task&gt;,
    state: State,
}

#[derive(Serialize, Deserialize)]
pub struct TodoIdResponse {
    id: Uuid,
}

impl TodoIdResponse {
    // #[cfg(test)]
    pub fn get_id(self) -&gt; String {
        format!(&quot;{}&quot;, self.id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para o item 1, <code>create_todo</code> controller, devemos novamente criar uma função <code>async</code>, que tem como tipo de resposta uma implementação da trait <code>Responder</code>, a <code>impl Responder</code>, como fizemos com <code>pong</code> e <code>readiness</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/conytoller/todo.rs
use actix_web::{HttpResponse, web, Responder};
use uuid::Uuid;
use crate::todo_api_web::model::{TodoCard, TodoIdResponse};

pub async fn create_todo(_info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let new_id = Uuid::new_v4();
    HttpResponse::Created()
        .content_type(&quot;application/json&quot;)
        .body(serde_json::to_string(&amp;TodoIdResponse::new(new_id)).expect(&quot;failed to serialize ContactsBatchResponseId&quot;)
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>As primeiras coisas que podemos perceber são a create de <code>Uuid</code> para gerar novos <code>uuids</code> com <code>Uuid::new_v4()</code>, e os tipos de entrada e de saída, <code>TodoCard, TodoIdResponse</code>, respectivamente. O actix possui uma forma interna de desserializar objetos JSON que é definido no módulo <code>web</code> com <code>web::Json&lt;T&gt;</code> e é em <code>T</code> que vamos incluir nossa struct <code>TodoCard</code>. Veja que o tipo de retorno <code>TodoIdResponse</code> está sendo serializado pelo <code>serde_json</code> e retornado ao <code>body</code>. Caso algo dê errado, obteremos um erro do tipo <code>&quot;failed to serialize ContactsBatchResponseId&quot;</code>. Note também que adicionamos o header <code>Content-type</code> através da função <code>content_type(&quot;application/json&quot;)</code>. Assim já seria suficiente para nosso teste passar, mas se quisermos testar essa rota com um <code>curl</code> é preciso adicionar ao <code>App</code> de <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HttpServer::new(|| {
    App::new().service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                    .route(&quot;create&quot;, web::post().to(create_todo))
            )
            .route(&quot;ping&quot;, web::get().to(pong))
            .route(&quot;~/ready&quot;, web::get().to(readiness))
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    )
})
<span class="boring">}
</span></code></pre></pre>
<h3 id="refatorando-as-rotas"><a class="header" href="#refatorando-as-rotas">Refatorando as rotas</a></h3>
<p>No nosso teste anterior, percebemos que nossas rotas da <code>main.rs</code> são desconectadas das rotas do teste (<code>tests/todo_api_web/controller</code>), pois iniciamos um servidor de teste (<code>test::init_service</code>) que pode possuir uma rota aleatória, já que iniciamos um novo <code>App</code> dentro dele. Assim, basta direcionarmos a rota a um controller correto e fazer o request ser direcionado para essa rota que tudo ocorrerá bem. Para resolver isso, a sugestão é refatorarmos o <code>App</code> de forma que suas rotas sejam configuradas em um único lugar e possam ser utilizadas tanto na <code>main.rs</code> quanto nos testes. Para isso, vamos refatorar nosso <code>main</code> para extrair todo o <code>web::scope</code> de forma que as configurações venham de um módulo de rotas. Assim, devemos criar um módulo de rotas em <code>src/todo_api_web/routes.rs</code> e adicionar o seguinte código:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web, HttpResponse};
use crate::todo_api_web::controller::{
    pong, readiness,
    todo::create_todo
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
                .service(
                    web::scope(&quot;api/&quot;)
                        .route(&quot;create&quot;, web::post().to(create_todo))
                )
                .route(&quot;ping&quot;, web::get().to(pong))
                .route(&quot;~/ready&quot;, web::get().to(readiness))
                .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound()))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Basicamente estamos extraindo todas as rotas para uma nova função que alterará o está do configuração do serviço dentro de  <code>App</code> com a função <code>config.service</code>. Isso impacta também nosso <code>main</code>, pois agora somente vamos precisar declarar a função <code>app_routes</code>:</p>
<pre><pre class="playground"><code class="language-rust">// main.rs
#[macro_use] extern crate serde;

use actix_web::{App, HttpServer};

mod todo_api_web;

use todo_api_web::{
    routes::app_routes
};

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new().configure(app_routes)
    })
    .workers(num_cpus::get() + 2)
    .bind(&quot;127.0.0.1:4000&quot;)
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<p>Agora podemos fazer a mesma refatoração nos testes, <code>tests/todo_api_web/controller</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ping_readiness {
    use todo_server::todo_api_web::routes::app_routes;

    use bytes::Bytes;
    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use actix_service::Service;

    #[actix_rt::test]
    async fn test_ping_pong() {
        let mut app = test::init_service(
            App::new().configure(
                app_routes
            )
        ).await;

        let req = test::TestRequest::get()
            .uri(&quot;/ping&quot;)
            .to_request();
        let resp = test::read_response(&amp;mut app, req).await;

        assert_eq!(resp, Bytes::from_static(b&quot;pong&quot;));
    }

    #[actix_rt::test]
    async fn test_readiness_ok() {
        let mut app = test::init_service(
            App::new()
                .configure(app_routes)
        ).await;
    
        let req = test::TestRequest::with_uri(&quot;/readiness&quot;).to_request();
    
        let resp = app.call(req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::ACCEPTED);
    }
}

mod create_todo {
    use todo_server::todo_api_web::{
        model::TodoIdResponse,
        routes::app_routes
    };

    use actix_web::{
        test, App,
    };
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        String::from(
            &quot;{
                \&quot;title\&quot;: \&quot;This is a card\&quot;,
                \&quot;description\&quot;: \&quot;This is the description of the card\&quot;,
                \&quot;owner\&quot;: \&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442\&quot;,
                \&quot;tasks\&quot;: [
                    {
                        \&quot;title\&quot;: \&quot;title 1\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 2\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 3\&quot;,
                        \&quot;is_done\&quot;: false
                    }
                ],
                \&quot;state\&quot;: \&quot;Doing\&quot;
            }&quot;
        )
    }

    #[actix_rt::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(
            App::new()
                .configure(app_routes)
        ).await;
    
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(post_todo().as_bytes().to_owned())
            .to_request();

        let resp = test::read_response(&amp;mut app, req).await;

        let id: TodoIdResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com estas alterações podemos perceber que um teste falha ao executarmos <code>cargo test</code>, esse é o teste <code>test todo_api_web::controller::ping_readiness::test_readiness_ok</code>, que falha com um <code>404</code>. Isso se deve ao fato de que a rota que estamos enviando o request de <code>readiness</code> estava errada esse tempo todo, pois escrevemos <code>/readiness</code>, enquanto a rota real é <code>/~/ready</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_readiness_ok() {
    let mut app = test::init_service(
        App::new()
            .configure(app_routes)
    ).await;

    let req = test::TestRequest::with_uri(&quot;/~/ready&quot;).to_request();

    let resp = app.call(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::ACCEPTED);
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso próximo passo é incluir nosso <code>TodoCard</code> em nossa base de dados.</p>
<h2 id="configurando-a-base-de-dados"><a class="header" href="#configurando-a-base-de-dados">Configurando a base de dados</a></h2>
<p>A base de dados que vamos utilizar agora é o DyanmoDB. O objetivo de utilizar essa base de dados é salvar as <code>TodoCards</code> para podermos buscá-las no futuro, assim o primeiro passo é configurar e modelar a base de dados para que nosso servidor a reconheça. A instância que vamos utilizar é derivada de um contêiner docker cuja imagem é <code>amazon/dynamodb-local</code> e pode ser executada com <code>docker run -p 8000:8000 amazon/dynamodb-local</code>. Observe que a porta que o DynamoDB está expondo é a <code>8000</code>. Eu gosto muito de utilizar Makefiles, pois eles facilitam a vida quando precisamos rodar vários comandos, especialmente em serviços diferentes. Assim, criei o seguinte Makefile para executar o DynamoDB:</p>
<pre><code class="language-sh">db:
	docker run -p 8000:8000 amazon/dynamodb-local

</code></pre>
<h3 id="escrevendo-no-banco-de-dados"><a class="header" href="#escrevendo-no-banco-de-dados">Escrevendo no banco de dados</a></h3>
<p>Como essa primeira feature envolve exploração, primeiro vou apresentar a lógica de como fazemos para depois escrever os testes e generalizações. O próximo passo para termos a lógica do banco de dados é criar um novo módulo em <code>lib.rs</code> (e no <code>main.rs</code>) chamado <code>todo_api</code>, que por sua vez possuirá o módulo <code>db</code>, que vai gerenciar todas as relações com o DynamoDB. Antes de seguir com o servidor em si, vou comentar a atual função <code>main</code> e substituir por outra simples, <code>fn main() {// ...}</code>, que utiliza somente o módulo <code>todo_api</code> para executar a criação de uma <code>TodoCard</code> no banco de dados, depois disso podemos conectar as partes novamente.</p>
<p>Para podermos nos comunicar facilmente com o DynamoDB em Rust, existem duas bibliotecas. Uma que relaciona todos os serviços da AWS chamada <code>rusoto_core</code> e outra, a <code>rusoto_dynamodb</code>, voltada ao DynamoDB. Basta adicioná-las às dependências no <code>Cargo.toml</code>. (Atualmente a rusoto está sem novos desenvolvimentos em prol da sdk Rust da AWS que está em Beta)</p>
<pre><code class="language-toml">[dependencies]
actix-web = &quot;2.0&quot;
actix-rt = &quot;1.0&quot;
actix-http = &quot;1.0.1&quot;
uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
num_cpus = &quot;1.0&quot;
rusoto_dynamodb = &quot;0.41.0&quot;
rusoto_core = &quot;0.41.0&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
actix-service = &quot;1.0.5&quot;
</code></pre>
<p>Com a biblioteca <code>rusoto_dynamodb</code> disponível, podemos começar a pensar em como nos comunicar com o DynamoDB. Podemos fazer isso adicionando um módulo <code>helpers</code> dentro de <code>todo_api/db</code> e criando uma função que retorna o cliente:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rusoto_core::Region;
use rusoto_dynamodb::DynamoDbClient;

pub fn client() -&gt; DynamoDbClient {
    DynamoDbClient::new(Region::Custom {
        name: String::from(&quot;us-east-1&quot;),
        endpoint: String::from(&quot;http://localhost:8000&quot;),
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos criar uma tabela, para nosso caso não vou utilizar uma migracão pois acredito que em um cenário real este banco de dados será configurado por outro serviço, algo mais próximo a um ambiente cloud. Assim, vamos criar a função <code>create_table</code> em <code>todo_api/db/helpers.rs</code>, que fará a configuração da tabela para nós:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use rusoto_dynamodb::{
    DynamoDb, DynamoDbClient, CreateTableInput, KeySchemaElement, 
    AttributeDefinition, ProvisionedThroughput
};
// ...
pub static TODO_CARD_TABLE: &amp;str = &quot;TODO_CARDS&quot;;

pub fn create_table() {
    let client = client();
    let create_table_input = CreateTableInput {
        table_name: TODO_CARD_TABLE.to_string(),
        key_schema: vec![KeySchemaElement {
            attribute_name: &quot;id&quot;.into(),
            key_type: &quot;HASH&quot;.into(),
        }],
        attribute_definitions: vec![AttributeDefinition {
            attribute_name: &quot;id&quot;.into(),
            attribute_type: &quot;S&quot;.into(),
        }],
        provisioned_throughput: Some(ProvisionedThroughput {
            read_capacity_units: 1,
            write_capacity_units: 1,
        }),
        ..CreateTableInput::default()
    };

    match client.create_table(create_table_input).sync() {
        Ok(output) =&gt;  {
            println!(&quot;Output: {:?}&quot;, output);
        },
        Err(error) =&gt; {
            println!(&quot;Error: {:?}&quot;, error);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para testarmos esta configuração precisamos executar o comando <code>make db</code>, adicionar uma simples mudança no <code>main.rs</code> e executar <code>cargo run</code> em outro terminal:</p>
<pre><pre class="playground"><code class="language-rust">// ...
use todo_api::db::helpers::create_table;

fn main() {
    create_table();
}
</code></pre></pre>
<p>Executando esta sequência de comandos, recebemos o seguinte output:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CreateTableOutput { 
    table_description: Some(TableDescription { 
        attribute_definitions: Some([AttributeDefinition { attribute_name: &quot;id&quot;, attribute_type: &quot;S&quot; }]),
        billing_mode_summary: Some(BillingModeSummary { 
            billing_mode: Some(&quot;PROVISIONED&quot;), 
            last_update_to_pay_per_request_date_time: Some(0.0) }), 
        creation_date_time: Some(1580524670.506), 
        global_secondary_indexes: None, 
        item_count: Some(0), 
        key_schema: Some([KeySchemaElement { attribute_name: &quot;id&quot;, key_type: &quot;HASH&quot; }]), 
        latest_stream_arn: None, 
        latest_stream_label: None, 
        local_secondary_indexes: None, 
        provisioned_throughput: Some(
            ProvisionedThroughputDescription { 
                last_decrease_date_time: Some(0.0), 
                last_increase_date_time: Some(0.0), 
                number_of_decreases_today: Some(0), 
                read_capacity_units: Some(1), 
                write_capacity_units: Some(1) }), 
        restore_summary: None, 
        sse_description: None, 
        stream_specification: None, 
        table_arn: Some(&quot;arn:aws:dynamodb:ddblocal:000000000000:table/TODO_CARDS&quot;), 
        table_id: None, 
        table_name: Some(&quot;TODO_CARDS&quot;), 
        table_size_bytes: Some(0), 
        table_status: Some(&quot;ACTIVE&quot;) 
    }) 
}
<span class="boring">}
</span></code></pre></pre>
<p>Tabela criada! Mas se executarmos <code>cargo run</code> de novo, receberemos um erro dizendo que não é possível criar uma tabela que já existe:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Error: Service(ResourceInUse(&quot;Cannot create preexisting table&quot;))
<span class="boring">}
</span></code></pre></pre>
<p>Para corrigir esse erro, sugiro modificar o método <code>create_table</code> para verificar se existem tabelas com a função <code>client.list_tables(list_tables_input).sync()</code>. Para isso, fazemos a seguinte modificação:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rusoto_dynamodb::{
    AttributeDefinition, CreateTableInput, DynamoDb, DynamoDbClient, KeySchemaElement,
    ProvisionedThroughput, ListTablesInput
};

// ...
pub fn create_table() {
    let client = client();
    let list_tables_input: ListTablesInput = Default::default();

    match client.list_tables(list_tables_input).sync() {
        Ok(list) =&gt; {
            match list.table_names {
                Some(table_vec) =&gt; {
                    if table_vec.len() &gt; 0 {
                        println!(&quot;Error: {:?}&quot;, &quot;Table already exists&quot;);
                    } else {
                        create_table_input()
                    }
                }
                None =&gt; create_table_input(),
            };
        }
        Err(_) =&gt; {
            create_table_input();
        }
    }
}

fn create_table_input() {
    let client = client();

    let create_table_input = CreateTableInput {
        table_name: TODO_CARD_TABLE.to_string(),
        key_schema: vec![KeySchemaElement {
            attribute_name: &quot;id&quot;.into(),
            key_type: &quot;HASH&quot;.into(),
        }],
        attribute_definitions: vec![AttributeDefinition {
            attribute_name: &quot;id&quot;.into(),
            attribute_type: &quot;S&quot;.into(),
        }],
        provisioned_throughput: Some(ProvisionedThroughput {
            read_capacity_units: 1,
            write_capacity_units: 1,
        }),
        ..CreateTableInput::default()
    };

    match client.create_table(create_table_input).sync() {
        Ok(output) =&gt; {
            println!(&quot;Output: {:?}&quot;, output);
        }
        Err(error) =&gt; {
            println!(&quot;Error: {:?}&quot;, error);
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Note que, quando verificamos as listas existentes na tabela, surgiram várias situações possíveis e para facilitar a criação da tabela, extraímos sua lógica para <code>create_table_input</code>. A primeira situação é <code>Err</code>, que possivelmente representa algum problema de listagem de tabelas na base, indicando ausência de tabelas, que nos permite criar tabelas. O segundo caso, dentro do <code>Ok</code> é um <code>None</code>, que pode significar os mais diversos problemas. Depois disso obtemos a listagem em <code>Some</code>, mas esta listagem pode estar vazia, sendo um caso para criar tabela, o <code>else</code>, e se a listagem for maior que zero, não criamos a tabela.</p>
<h3 id="inserindo-conteúdo-na-tabela"><a class="header" href="#inserindo-conteúdo-na-tabela">Inserindo conteúdo na tabela</a></h3>
<p>Para inserirmos a tabela, vamos precisar de uma struct de <code>rusoto_dynamo</code> chamada <code>PutItemInput</code>, que nos permitirá inserir o JSON que recebemos na tabela, porém o JSON que recebemos em <code>TodoCard</code> não possui o id do card. Para podermos utilizar o <code>PutItemInput</code> como definimos na tabela, vamos criar um <code>model</code> que possua um id.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/mod.rs
use rusoto_dynamodb::AttributeValue;
use std::collections::HashMap;
use uuid::Uuid;

#[derive(Debug, Clone)]
struct TaskDb {
    is_done: bool,
    title: String,
}

#[derive(Debug, Clone)]
enum StateDb {
    Todo,
    Doing,
    Done,
}

#[derive(Debug, Clone)]
pub struct TodoCardDb {
    id: Uuid,
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;TaskDb&gt;,
    state: StateDb,
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos criar uma função que permita transformar um <code>TodoCard</code> em um <code>TodoCardDb</code>, em <code>src/todo_api/model/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::model::{State, TodoCard};
use actix_web::web;

impl TodoCardDb {
    pub fn new(card: web::Json&lt;TodoCard&gt;) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            title: card.title.clone(),
            description: card.description.clone(),
            owner: card.owner,
            tasks: card
                .tasks
                .iter()
                .map(|t| TaskDb {
                    is_done: t.is_done,
                    title: t.title.clone(),
                })
                .collect::&lt;Vec&lt;TaskDb&gt;&gt;(),
            state: match card.state {
                State::Doing =&gt; StateDb::Doing,
                State::Done =&gt; StateDb::Done,
                State::Todo =&gt; StateDb::Todo,
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, podemos fazer nosso <code>controller</code> momentaneamente gerenciar todas as ações com o banco de dados:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use uuid::Uuid;
use crate::todo_api_web::model::{TodoCard, TodoIdResponse};
use crate::todo_api::model::{TodoCardDb};


pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = TodoCardDb::new(info);

    match put_todo(todo_card) {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
            .content_type(&quot;application/json&quot;)
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(&quot;Failed to serialize todo card&quot;))
    }
}

/// A partir daqui vamos extrair logo mais
use rusoto_dynamodb::{DynamoDb, PutItemInput};

use crate::{
    todo_api::db::helpers::{TODO_CARD_TABLE, client},
};

pub fn put_todo(todo_card: TodoCardDb) -&gt;  Option&lt;uuid::Uuid&gt; {
    let client = client();
    let put_item = PutItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        item: todo_card.clone().into(),
        ..PutItemInput::default()
    };
    
    match client.put_item(put_item).sync() {
        Ok(_) =&gt; {
            Some(todo_card.id)
        },
        Err(_) =&gt; {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que nosso controller ficou muito mais funcional agora. Ele recebe um JSON do tipo <code>TodoCard</code>, transforma esse JSON em um <code>TodoCardDb</code> e envia para a função <code>put_todo</code> inserir no banco de dados. Caso ocorra algum problema com a inserção fazemos pattern matching com o <code>None</code> e retornamos algo como <code>HttpResponse::BadRequest()</code> ou <code>HttpResponse::InternalServerError()</code>, mas caso o retorno seja um id em <code>Some</code>, retornamos um JSON contendo <code>TodoIdResponse</code>. Note que foi necessário adicionar a função <code>body</code> ao <code>HttpResponse::BadRequest()</code> para garantir que os dois pattern matchings tivessem o mesmo tipo de retorno <code>Response</code>, em vez de <code>ResponseBuilder</code>. </p>
<p>Mais à frente, na função <code>put_todo</code>, nos deparamos com a struct <code>PutItemInput</code>, struct responsável por configurar como será a inserção do item via função <code>put_item(item).sync</code>. Ao mesmo tempo, se você estiver utilizando o <code>rls</code> do rust, vai perceber que o <code>into</code> de <code>item: todo_card.clone().into(),</code> está destacado, isso se deve ao fato de que precisamos implementar a função <code>into</code> para o tipo <code>TodoCardDB</code> de forma que retorne <code>HashMap&lt;String, AttributeValue&gt;</code>. Para isso, utilizamos a declaração <code>impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb</code> com a seguinte implementação:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/mod.rs
use rusoto_dynamodb::AttributeValue;
use std::collections::HashMap;

impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb {
    fn into(self) -&gt; HashMap&lt;String, AttributeValue&gt; {
        let mut todo_card = HashMap::new();
        todo_card.insert(&quot;id&quot;.to_string(), val!(S =&gt; Some(self.id.to_string())));
        todo_card.insert(&quot;title&quot;.to_string(), val!(S =&gt; Some(self.title)));
        todo_card.insert(&quot;description&quot;.to_string(), val!(S =&gt; Some(self.description)));
        todo_card.insert(&quot;owner&quot;.to_string(), val!(S =&gt; Some(self.owner.to_string())));
        todo_card.insert(&quot;state&quot;.to_string(), val!(S =&gt; Some(self.state.to_string())));
        todo_card.insert(&quot;tasks&quot;.to_string(), val!(L =&gt; task_to_db_val(self.tasks)));
        todo_card
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Se você está utilizando <code>rls</code> vai perceber que o <code>state.to_string()</code> e o <code>task_to_db_val</code> estão destacados como errados, assim como a macro <code>val!</code>. Vamos falar do <code>val!</code> logo, mas primeiro vamos entender como funciona a criação do tipo <code>AttributeValue</code> para ser inserido dentro do banco. A função <code>into</code> espera como retorno um tipo <code>HashMap&lt;String, AttributeValue&gt;</code>, no qual <code>AttributeValue</code> é uma struct com a seguinte estrutura:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AttributeValue {
    pub b: Option&lt;Bytes&gt;,
    pub bool: Option&lt;bool&gt;,
    pub bs: Option&lt;Vec&lt;Bytes&gt;&gt;,
    pub l: Option&lt;Vec&lt;AttributeValue&gt;&gt;,
    pub m: Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;,
    pub n: Option&lt;String&gt;,
    pub ns: Option&lt;Vec&lt;String&gt;&gt;,
    pub null: Option&lt;bool&gt;,
    pub s: Option&lt;String&gt;,
    pub ss: Option&lt;Vec&lt;String&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>AttributeValue</code></p>
<p>Os tipos <code>T</code> dentro do <code>Option&lt;T&gt;</code> são os tipos possíveis dentro do DynamoDB. Veja que alguns tipos são bem fáceis de perceber como <code>bool</code>, <code>Vec&lt;AttributeValue&gt;</code> e <code>HashMap&lt;String, AttributeValue&gt;</code>, isto é, um valor booleano, um vetor de atributos do dynamo e um mapa com keys strings e valores como atributos, respectivamente. Outros valores podem ser confusos, como as chaves <code>s</code>, <code>ss</code>, <code>n</code> e <code>ns</code>. As chaves dos tipos <code>b</code> e <code>bs</code> são para valores binários como <code>&quot;B&quot;: &quot;dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk&quot;</code>, além disso o tipo <code>n</code> serve para representar um tipo numérico, enquanto o tipo <code>s</code> serve para tipos String. Os tipos <code>ss</code> e <code>ns</code> são as versões vetores de <code>s</code> e de <code>n</code>, respectivamente.</p>
</blockquote>
<p>Para resovermos a falha de compilação em <code>state.to_string()</code> precisamos implementar a trait <code>std::fmt::Display</code> que nos permite transformar o valor de <code>state</code> em uma String:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl std::fmt::Display for StateDb {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, &quot;{:?}&quot;, self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos verificar a função <code>task_to_db_val</code>, cujo objetivo é transformar um vetor do tipo <code>TaskDb</code> em um vetor de <code>AttributeValue</code>. Essa transformação nos permite inserir as <code>tasks</code> como um único campo contendo um vetor de objetos, como se diria na linguagem JSON, <code>TaskDB</code>. A função <code>task_to_db_val</code> é bastante simples, pois recebe uma <code>tasks</code> do tipo <code>Vec&lt;TaskDb&gt;</code> e aplica um mapa sobre cada <code>TaskDb</code> para substituí-las por um <code>AttributeValue</code> da chave <code>m</code>, <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code>, e depois coleciona todos esses <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code> em um vetor <code>Vec&lt;AttributeValue&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn task_to_db_val(tasks: Vec&lt;TaskDb&gt;) -&gt; Vec&lt;AttributeValue&gt; {
    tasks
        .iter()
        .map(|t| {
            let mut tasks_hash = HashMap::new();
            tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; Some(t.title.clone())));
            tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; t.is_done));
            val!(M =&gt; tasks_hash)
        })
        .collect::&lt;Vec&lt;AttributeValue&gt;&gt;()
}
<span class="boring">}
</span></code></pre></pre>
<p>Ainda falta falarmos da <code>val!</code>. <code>val!</code> é uma macro criada para transformar os valores de nossa struct em valores do DynamoDB. Inseri essa macro em um novo módulo chamado <code>adapter</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
#[macro_export]
macro_rules! val {
    (B =&gt; $bval:expr) =&gt; {{
        let mut attr = AttributeValue::default();
        attr.bool = Some($bval);
        attr
    }};
    (L =&gt; $val:expr) =&gt; {{
        let mut attr = AttributeValue::default();
        attr.l = Some($val);
        attr
    }};
    (S =&gt; $val:expr) =&gt; {{
        let mut attr = AttributeValue::default();
        attr.s = $val;
        attr
    }};
    (M =&gt; $val:expr) =&gt; {{
        let mut attr = AttributeValue::default();
        attr.m = Some($val);
        attr
    }};
}
<span class="boring">}
</span></code></pre></pre>
<p>Para que essa macro esteja disponível dentro do módulo <code>todo_api</code>, precisamos utilizar <code>#[macro_use]</code> na declaração dos módulos:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
pub mod adapter;
pub mod db;
pub mod model;
<span class="boring">}
</span></code></pre></pre>
<p>Agora tudo deve estar funcionando. Podemos executar <code>make db</code> e <code>cargo run</code> para fazer um <code>curl</code> em <code>http://localhost:4000/api/create</code> com o seguinte JSON:</p>
<pre><code class="language-json">{
	&quot;title&quot;: &quot;title&quot;,
	&quot;description&quot;: &quot;descrition&quot;,
	&quot;state&quot;: &quot;Done&quot;,
	&quot;owner&quot;: &quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;,
	&quot;tasks&quot;: [
        {
			&quot;is_done&quot;: true,
			&quot;title&quot;: &quot;blob&quot;
			
		}
    ]
}
</code></pre>
<p>E vamos receber um <code>Uuid</code> como resposta e o status <code>201</code>:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;ae1cb12c-6c67-4337-bd7b-b557d7568c60&quot;
}
</code></pre>
<h3 id="organizando-nosso-código"><a class="header" href="#organizando-nosso-código">Organizando nosso código</a></h3>
<p>Nosso controller possui um conjunto de códigos que não fazem sentido dentro do contexto de controller, no caso a função <code>put_todo</code>, como descrita a seguir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rusoto_dynamodb::{DynamoDb, PutItemInput};

use crate::{
    todo_api::db::helpers::{TODO_CARD_TABLE, client},
};

pub fn put_todo(todo_card: TodoCardDb) -&gt;  Option&lt;uuid::Uuid&gt; {
    let client = client();
    let put_item = PutItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        item: todo_card.clone().into(),
        ..PutItemInput::default()
    };
    
    match client.put_item(put_item).sync() {
        Ok(_) =&gt; {
            Some(todo_card.id)
        },
        Err(_) =&gt; {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que vamos fazer é criar um módulo <code>todo</code> dentro de <code>todo_api/db</code> que conterá toda a lógica de banco de dados para o <code>todo</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/db/todo.rs
use rusoto_dynamodb::{DynamoDb, PutItemInput};
use uuid::Uuid;
use crate::{
    todo_api::{
        db::helpers::{TODO_CARD_TABLE, client},
        model::TodoCardDb
    }
};

pub fn put_todo(todo_card: TodoCardDb) -&gt;  Option&lt;Uuid&gt; {
    let client = client();
    let put_item = PutItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        item: todo_card.clone().into(),
        ..PutItemInput::default()
    };
    
    match client.put_item(put_item).sync() {
        Ok(_) =&gt; {
            Some(todo_card.id)
        },
        Err(_) =&gt; {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E agora podemos simplificar muito nosso controller com:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use crate::{
    todo_api::{
        db::todo::put_todo,
        model::{TodoCardDb}
    },
    todo_api_web::model::{TodoCard, TodoIdResponse}
};


pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = TodoCardDb::new(info);

    match put_todo(todo_card) {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
            .content_type(&quot;application/json&quot;)
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(&quot;Failed to serialize todo card&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que para declarar todos os módulos internos utilizei o <code>use crate::{// ...}</code>, pois ajuda na organização. Além disso, na minha opinião, a função <code>new</code> de <code>TodoCardDb</code> é um adapter e pode estar mal localizada. Uma possível solução para isso seria mover e renomear a função <code>new</code> para o módulo adapter com nome de <code>todo_json_to_db</code>, mas isso implicaria em tornar todos os campos de <code>TodoCardDb</code> públicos, assim como de <code>TaskDb</code>. Por isso, essa parte da refatoração fica a seu critério de estilo, mas vou fazer para exemplificar:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
// ...
use actix_web::web;
use uuid::Uuid;
use crate::{
    todo_api_web::model::{State, TodoCard},
    todo_api::model::{StateDb, TodoCardDb, TaskDb}
};

pub fn todo_json_to_db(card: web::Json&lt;TodoCard&gt;) -&gt; TodoCardDb {
    TodoCardDb {
        id: Uuid::new_v4(),
        title: card.title.clone(),
        description: card.description.clone(),
        owner: card.owner,
        tasks: card
            .tasks
            .iter()
            .map(|t| TaskDb {
                is_done: t.is_done,
                title: t.title.clone(),
            })
            .collect::&lt;Vec&lt;TaskDb&gt;&gt;(),
        state: match card.state {
            State::Doing =&gt; StateDb::Doing,
            State::Done =&gt; StateDb::Done,
            State::Todo =&gt; StateDb::Todo,
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A compilação falha pois <code>StateDB</code> e <code>TaskDB</code> são privados, assim como quase todos campos de <code>TodoCardDb</code>, para isso modificamos o módulo <code>todo_api/model</code> para:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[derive(Debug, Clone)]
pub struct TaskDb {
    pub is_done: bool,
    pub title: String,
}

#[derive(Debug, Clone)]
pub enum StateDb {
    Todo,
    Doing,
    Done,
}

#[derive(Debug, Clone)]
pub struct TodoCardDb {
    pub id: Uuid,
    pub title: String,
    pub description: String,
    pub owner: Uuid,
    pub tasks: Vec&lt;TaskDb&gt;,
    pub state: StateDb,
}

impl TodoCardDb {
    #[allow(dead_code)]
    pub fn get_id(self) -&gt; Uuid {
        self.id
    }
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Também precisamos mudar o controller para utilizar nossa nova função:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use crate::{
    todo_api::{
        db::todo::put_todo,
        adapter
    },
    todo_api_web::model::{TodoCard, TodoIdResponse}
};


pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = adapter::todo_json_to_db(info);

    match put_todo(todo_card) {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
            .content_type(&quot;application/json&quot;)
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(&quot;Failed to serialize todo card&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Uma última refatoração que podemos fazer é a função <code>task_to_db_val</code>, já que sua função é essencialmente transformar <code>TaskDb</code> em um tipo <code>AttributeValue</code>. Assim, podemos implementar uma função que faça isso com <code>TaskDb</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb {
    fn into(self) -&gt; HashMap&lt;String, AttributeValue&gt; {
        let mut todo_card = HashMap::new();
        todo_card.insert(&quot;id&quot;.to_string(), val!(S =&gt; Some(self.id.to_string())));
        todo_card.insert(&quot;title&quot;.to_string(), val!(S =&gt; Some(self.title)));
        todo_card.insert(&quot;description&quot;.to_string(), val!(S =&gt; Some(self.description)));
        todo_card.insert(&quot;owner&quot;.to_string(), val!(S =&gt; Some(self.owner.to_string())));
        todo_card.insert(&quot;state&quot;.to_string(), val!(S =&gt; Some(self.state.to_string())));
        todo_card.insert(&quot;tasks&quot;.to_string(), 
            val!(L =&gt; self.tasks.into_iter().map(|t| t.to_db_val()).collect::&lt;Vec&lt;AttributeValue&gt;&gt;()));
        todo_card
    }
}

impl TaskDb {
    fn to_db_val(self) -&gt; AttributeValue {
        let mut tasks_hash = HashMap::new();
            tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; Some(self.title.clone())));
            tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; self.is_done));
            val!(M =&gt; tasks_hash)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora  faltam alguns testes.</p>
<h2 id="aplicando-testes-a-nosso-endpoint"><a class="header" href="#aplicando-testes-a-nosso-endpoint">Aplicando testes a nosso endpoint</a></h2>
<p>Creio que uma boa abordagem agora seja começar pelos testes mais unitários, por isso vamos começar pelo adapter. Nosso primeiro teste será com a função <code>converts_json_to_db</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;
    use actix_web::web::Json;
    use crate::{
        todo_api::model::{StateDb, TaskDb, TodoCardDb},
        todo_api_web::model::{State, Task, TodoCard},
    };

    #[test]
    fn converts_json_to_db() {
        let id = uuid::Uuid::new_v4();
        let owner = uuid::Uuid::new_v4();
        let json = Json(TodoCard {
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: owner,
            state: State::Done,
            tasks: vec![Task {is_done: true, title: &quot;title&quot;.to_string()}]
        });
        let expected = TodoCardDb {
            id: id,
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: owner,
            state: StateDb::Done,
            tasks: vec![TaskDb {is_done: true, title: &quot;title&quot;.to_string()}]
        };
        assert_eq!(todo_json_to_db(json, id),
                    expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que, para facilitar a testabilidade, mudamos a assinatura da função para receber um <code>id</code>, <code>todo_json_to_db(json, id)</code>. Isso se deve ao fato de que gerar id randomicamente não ajuda os testes e testar campo a campo não parece uma boa solução. Além disso, adicionamos a macro <code>PartialEq</code> nas structs <code>StateDb</code>, <code>TaskDb</code> e <code>TodoCardDb</code> para fins de comparabilidade. Agora precisamos testar a função <code>to_db_val</code> de <code>TaskDb</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn task_db_to_db_val() {
        let actual = TaskDb {
            title: &quot;blob&quot;.to_string(),
            is_done: true
        }.to_db_val();
        let mut tasks_hash = HashMap::new();
        tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; Some(&quot;blob&quot;.to_string())));
        tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; true));
        let expected = val!(M =&gt; tasks_hash);

        assert_eq!(actual, expected);
        
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A lógica do teste <code>task_db_to_db_val</code> é basicamente a mesma que a implementação da função, mas já vale como um simples teste unitário. Agora podemos testar a função <code>into</code>, que também teria a mesma implementação da própria função, note que estamos utilizando apenas um id:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
    fn todo_card_db_to_db_val() {
        let id = uuid::Uuid::new_v4();
        let actual: HashMap&lt;String, AttributeValue&gt; = TodoCardDb {
            id: id,
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: id,
            state: StateDb::Done,
            tasks: vec![TaskDb {is_done: true, title: &quot;title&quot;.to_string()}]
        }.into();
        let mut expected = HashMap::new();
        expected.insert(&quot;id&quot;.to_string(), val!(S =&gt; Some(id.to_string())));
        expected.insert(&quot;title&quot;.to_string(), val!(S =&gt; Some(&quot;title&quot;.to_string())));
        expected.insert(&quot;description&quot;.to_string(), val!(S =&gt; Some(&quot;description&quot;.to_string())));
        expected.insert(&quot;owner&quot;.to_string(), val!(S =&gt; Some(id.to_string())));
        expected.insert(&quot;state&quot;.to_string(), val!(S =&gt; Some(StateDb::Done.to_string())));
        expected.insert(&quot;tasks&quot;.to_string(), 
            val!(L =&gt; vec![TaskDb {is_done: true, title: &quot;title&quot;.to_string()}.to_db_val()]));
        
        assert_eq!(actual, expected);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos <code>cargo test</code> enquanto o <code>make db</code> roda, teremos duas situações: uma em que a base de dados já está configurada e tudo ocorre normalmente e outra em que ela não está configurada e o teste falha. Para resolvermos esse problema, bastaria adicionar o <code>create_table</code> ao cenário de teste assim:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn valid_todo_post() {
    todo_server::todo_api::db::helpers::create_table();
    let mut app = test::init_service(
        App::new()
            .configure(app_routes)
    ).await;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>É bem claro para mim que um teste que precisa executar o contêiner do banco de dados para passar é bastante frágil. Assim vamos precisar fazer algumas modificações para tornar o teste passável. A mudança que vamos fazer é, na minha opinião, uma forma mais elegante de fazer mocks em rust, pois ela não necessita criar uma trait e uma struct para mockar uma função específica, basta definirmos que para modo de compilação em test, <code>#[cfg(test)]</code>, a função terá outro comportamento, geralmente evitando efeitos colaterais com base de dados. Agora, o que vai mudar é que nosso teste de controller deixará de estar presente na pasta <code>tests</code> e passará a ser um módulo <code>#[cfg(test)]</code> junto ao controller:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod create_todo {
    use crate::todo_api_web::{
        model::TodoIdResponse,
        routes::app_routes
    };

    use actix_web::{
        test, App,
    };
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        // ...
    }

    #[actix_rt::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(
            App::new()
                .configure(app_routes)
        ).await;
    
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(post_todo().as_bytes().to_owned())
            .to_request();

        let resp = test::read_response(&amp;mut app, req).await;
        println!(&quot;{:?}&quot;, resp);

        let id: TodoIdResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, agora precisamos fazer com que nossa interação com o banco de dados seja &quot;mockada&quot;, para isso reescrevi o módulo <code>src/todo_api/db/todo.rs</code> para conter duas formas de compilacão &quot;com testes&quot; e  &quot;sem testes&quot;:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[cfg(not(test))]
pub fn put_todo(todo_card: TodoCardDb) -&gt; Option&lt;Uuid&gt; {
    use rusoto_dynamodb::DynamoDb;
    use crate::todo_api::db::helpers::client;

    let client = client();
    let put_item = PutItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        item: todo_card.clone().into(),
        ..PutItemInput::default()
    };

    match client.put_item(put_item).sync() {
        Ok(_) =&gt; Some(todo_card.id),
        Err(_) =&gt; None,
    }
}

#[cfg(test)]
pub fn put_todo(todo_card: TodoCardDb) -&gt; Option&lt;Uuid&gt; {
    let _ = PutItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        item: todo_card.clone().into(),
        ..PutItemInput::default()
    };
    Some(todo_card.id)
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que <code>put_todo</code> com <code>cfg(test)</code> ativado pula a etapa <code>client.put_item(put_item).sync()</code> e simplesmente retorna  um <code>Option&lt;Uuid&gt;</code>. </p>
<blockquote>
<p>No momento, a biblioteca rusoto dispõe de uma maneira muito primitiva de testar seus serviços, por isso, para o caso do DyanmoDB, não creio que ela seja suficiente para realizar um teste real.</p>
</blockquote>
<p>Outro modo de fazer esse teste, utilizando <code>cfg</code>, é utilizar <code>features</code>, mas por ser um pouco mais sensível deixei para apresentar depois. Neste repositório, vamos utilizar <code>features</code> para testar os controllers, o que deixará o código mais limpo, porém mais difícil de gerenciar, podendo fazer com que uma feature indesejada suba para a produção. Assim, recomendo fortemente que os builds de produção utilizem a flag <code>--release</code> e que os <code>cfg</code> mapeie corretamente isso. Para utilizar essa feature, uma boa prática é adicioná-la ao campo <code>[features]</code> do <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;todo-server&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Julia Naomi &lt;jnboeira@outlook.com&gt;&quot;]
edition = &quot;2018&quot;

[features]
dynamo = []

// ...
</code></pre>
<p>Além disso, precisamos gerar a nova função, muito semelhante ao <code>cfg(test)</code> de antes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn put_todo(todo_card: TodoCardDb) -&gt; Option&lt;Uuid&gt; {
    use crate::todo_api::db::helpers::client;
    use rusoto_dynamodb::DynamoDb;

    let client = client();
    let put_item = PutItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        item: todo_card.clone().into(),
        ..PutItemInput::default()
    };

    match client.put_item(put_item).sync() {
        Ok(_) =&gt; Some(todo_card.id),
        Err(_) =&gt; None,
    }
}

#[cfg(feature = &quot;dynamo&quot;)]
pub fn put_todo(todo_card: TodoCardDb) -&gt; Option&lt;Uuid&gt; {
    let _ = PutItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        item: todo_card.clone().into(),
        ..PutItemInput::default()
    };
    Some(todo_card.id)
}
<span class="boring">}
</span></code></pre></pre>
<p>E movemos novamente nosso teste para a pasta <code>tests</code>. Para executar todos os testes corretamente usamos <code>cargo teste --features &quot;dynamo&quot;</code>, é sempre bom adicionar este comando a um Makefile.</p>
<pre><code class="language-sh">db:
	docker run -p 8000:8000 amazon/dynamodb-local

test:
	cargo test --features &quot;dynamo&quot;
</code></pre>
<p>O último passo para nossos testes é gerar ums função de teste que nos permita retirar a grosseria que é a função de teste <code>post_todo</code>. Assim, faremos uma função que le um arquivo <code>json</code> e retorna uma string contendo seu conteúdo. Vamos chamá-la de <code>read_json</code> e vai receber como argumento uma string com o nome do arquivo. A primeira mudança que faremos é adicionar <code>mod helpers</code> no arquivo <code>tests/lib.rs</code>. Depois vamos criar o módulo <code>tests/helpers.rs</code> e adicionar a função <code>read_json</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Read;

pub fn read_json(file: &amp;str) -&gt; String {
    let path = String::from(&quot;dev-resources/&quot;) + file;
    let mut file = File::open(&amp;path).unwrap();
    let mut data = String::new();
    file.read_to_string(&amp;mut data).unwrap();
    data
}
<span class="boring">}
</span></code></pre></pre>
<p>Com a função <code>read_json</code> pronta, podemos adicionar o Json <code>post_todo.json</code> na pasta (que vamos criar junto) <code>dev-resources</code> do projeto:</p>
<pre><code class="language-json">{
    &quot;title&quot;: &quot;This is a card&quot;,
    &quot;description&quot;: &quot;This is the description of the card&quot;,
    &quot;owner&quot;: &quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;,
    &quot;tasks&quot;: [
        {
            &quot;title&quot;: &quot;title 1&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 2&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 3&quot;,
            &quot;is_done&quot;: false
        }
    ],
    &quot;state&quot;: &quot;Doing&quot;
}
</code></pre>
<p>Agora, podemos remover a função <code>post_todo()</code> do módulo <code>create_todo</code> encontrado no módulo <code>tests/todo_api_web/controller.rs</code> e adicionar o <code>use</code> da função <code>read_json</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod create_todo {
    // ...
    use crate::helpers::read_json;

    #[actix_rt::test]
    async fn valid_todo_post() {
        // ...
    
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        // ...
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>No próximo capítulo vamos aprender a obter todos os <code>TodoCard</code> que criamos na base de dados para depois podermos melhorar as configurações do serviço, por exemplo logs.</p>
<p><a href="part-1/01-ping-pong.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/03-get.html">Próximo</a></p>
<p><a href="part-1/02-create.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/04-serving.html">Próximo</a></p>
<h1 id="obtendo-todas-as-todo-cards-inseridas"><a class="header" href="#obtendo-todas-as-todo-cards-inseridas">Obtendo todas as Todo Cards inseridas</a></h1>
<p>Existem muitas abordagens para como vamos adicionar um novo endpoint no nosso sistema, mas a abordagem que eu gostaria de tratar aqui é a de começar de cima para baixo, ou seja, criamos um endpoint <code>GET</code> que lé todas as <code>TodoCard</code> e nos retorna elas no formato Json. Dessa vez vamos começar escrevendo um teste para este novo endpoint:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod read_all_todos {
    use todo_server::todo_api_web::{
        routes::app_routes
    };

    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use actix_service::Service;

    #[actix_rt::test]
    async fn test_todo_index_ok() {
        let mut app = test::init_service(
            App::new()
                .configure(app_routes)
        ).await;
    
        let req = test::TestRequest::with_uri(&quot;/api/index&quot;).to_request();
    
        let resp = app.call(req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::OK);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Felizmente, nosso teste falha retornanto um <code>NOT_FOUND</code> e nos obriga a implementar a nova rota, <code>index</code> em <code>src/todo_api_web/routes.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                .route(&quot;create&quot;, web::post().to(create_todo))
                .route(&quot;index&quot;, web::get().to(show_all_todo)))
            .route(&quot;ping&quot;, web::get().to(pong))
            .route(&quot;~/ready&quot;, web::get().to(readiness))
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora estamos utilizando uma nova função controller chamada de <code>show_all_todo</code>, ela precisa ser incorporada no escopo da função, fazemos isso através de <code>use crate::todo_api_web::controller::todo::show_all_todo</code> e recebemos um aviso de que ela não existe, assim devemos implementá-la no módulo <code>src/todo_api_web/controller/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_all_todo() -&gt; impl Responder {
    HttpResponse::Ok()
}
<span class="boring">}
</span></code></pre></pre>
<p>Como nosso teste checa apenas o retorno do status <code>200</code>, isso é suficiente. Nosso próximo passo é implementar um teste um pouco mais robusto. Esse teste consiste em garantir que o JSON recebido possua um vetor de tamanho 1 após um post em <code>api/create</code> ser enviado:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>od read_all_todos {
    use todo_server::todo_api_web::{
        model::TodoCardsResponse,
        routes::app_routes
    };

    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use actix_service::Service;
    use serde_json::from_str;

    use crate::helpers::read_json;

    #[actix_rt::test]
    async fn test_todo_index_ok() {
        // ...
    }

    #[actix_rt::test]
    async fn test_todo_cards_count() {
        let mut app = test::init_service(
            App::new()
                .configure(app_routes)
        ).await;
    
        let post_req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let _ = app.call(post_req).await.unwrap();
        let req = test::TestRequest::with_uri(&quot;/api/index&quot;).to_request();
        let resp = test::read_response(&amp;mut app, req).await;

        let todo_cards: TodoCardsResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
        assert_eq!(todo_cards.cards.len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para fazer isso vamos criar uma struct serializável para o formato Json. Essa struct se encontrará em <code>sr/todo_api_web/model/mod.rs</code> e se chamará <code>TodoCardsResponse</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct TodoCardsResponse {
    pub cards: Vec&lt;String&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que no momento não precisamos nos preocupar com o tipo de resposta, somente com a struct e seus campos. Agora precisamos fazer nosso controller retornar um vetor com uma String:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//src/todo_api_web/controller/todo.rs
pub async fn show_all_todo() -&gt; impl Responder {
    HttpResponse::Ok()
        .content_type(&quot;application/json&quot;)
        .body(serde_json::to_string(&amp;TodoCardsResponse{cards: vec![String::from(&quot;test&quot;)]}).expect(&quot;Failed to serialize todo cards&quot;))
}
<span class="boring">}
</span></code></pre></pre>
<p>Com este teste pronto, nosso próximo teste fica bastante simples, pois agora precisamos fazer um teste quase igual, mas que garanta que o retorno seja um <code>TodoCard</code> com as informações que postamos. Note que como este teste conterá um mock da resposta do banco de dados, podemos simplesmente adicionar um <code>Uuid</code> pré-determinado no mock. Vou criar uma função de teste, no módulo de <code>helpers</code> que retorna um vetor com uma <code>TodoCard</code>, <code>mock_get_todos</code>.</p>
<blockquote>
<p>Note que <code>TodoCard</code> não possui um id, assim temos duas opções: a primeira é criar um <code>TodoCardResponse</code>, que contém um Id e a segunda é modificarmos a <code>TodoCard</code> para conter um campo <code>id: Option&lt;Uuid&gt;</code>. Nós vamos seguir a segunda abordagem, cuja única mudança será adicionar <code>id: None,</code> no teste <code>converts_json_to_db</code> encontrado em <code>src/todo_api/adapter/mod.rs</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use todo_server::todo_api_web::model::{State, Task, TodoCard};

// ...

pub fn mock_get_todos() -&gt; Vec&lt;TodoCard&gt; {
    vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
        title: String::from(&quot;This is a card&quot;),
        description: String::from(&quot;This is the description of the card&quot;),
        owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
        tasks: vec![
            Task {
                title: String::from(&quot;title 1&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 2&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 3&quot;),
                is_done: false,
            },
        ],
        state: State::Doing,
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>Com nossa função implementada, podemos criar o novo cenário de teste no submódulo <code>read_all_todos</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_todo_cards_with_value() {
    let mut app = test::init_service(
        App::new()
            .configure(app_routes)
    ).await;

    let post_req = test::TestRequest::post()
        .uri(&quot;/api/create&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
        .to_request();

    let _ = app.call(post_req).await.unwrap();
    let req = test::TestRequest::with_uri(&quot;/api/index&quot;).to_request();
    let resp = test::read_response(&amp;mut app, req).await;

    let todo_cards: TodoCardsResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
    assert_eq!(todo_cards.cards, mock_get_todos());
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que agora os tipos de <code>todo_cards.cards, mock_get_todos()</code> são incompatíveis, assim, devemos modificar a a struct <code>TodoCardsResponse</code> para:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, PartialEq)]
pub struct TodoCardsResponse {
    pub cards: Vec&lt;TodoCard&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Também é necessário, para fins de teste, implementarmos a trait <code>PartialEq</code> para todas as structs, e enums, derivadas de <code>TodoCardsResponse</code>. Com essa mudança, precisamos modificar a lógica do nosso controller já que agora é necessário que ele busque <code>TodoCard</code>s no banco. Faremos isso pela função <code>get_todos</code>, que retornará <code>Vec&lt;TodoCard&gt;</code>. Caso o <code>match</code> retorne, não podemos enviar um erro <code>500</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_all_todo() -&gt; impl Responder {
    match get_todos() {
        None =&gt; HttpResponse::InternalServerError().body(&quot;Failed to read todo cards&quot;),
        Some(todos) =&gt; HttpResponse::Ok()
            .content_type(&quot;application/json&quot;)
            .body(serde_json::to_string(&amp;TodoCardsResponse{cards: todos}).expect(&quot;Failed to serialize todo cards&quot;)),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar a função <code>get_todos</code>, mas antes vamos implementar a versão de teste (<code>feature = dynamo</code>) da função em <code>src/todo_api/db/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dynamo&quot;)]
pub fn get_todos() -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use crate::todo_api_web::model::{State, Task};
    use rusoto_dynamodb::DynamoDb;

    let _ = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        ..ScanInput::default()
    };

    Some(vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
        title: String::from(&quot;This is a card&quot;),
        description: String::from(&quot;This is the description of the card&quot;),
        owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
        tasks: vec![
            Task {
                title: String::from(&quot;title 1&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 2&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 3&quot;),
                is_done: false,
            },
        ],
        state: State::Doing,
    }])
}
<span class="boring">}
</span></code></pre></pre>
<p>Note a presença da struct <code>ScanInput</code>. Ela está presente como forma de garantir em teste que a construção dela está coerente. Ao rodarmos o teste (comente o <code>#[cfg(feature = &quot;dynamo&quot;)]</code>), obtemos sucesso! Agora podemos partir para a leitura da base de dados de fato. Nossa função de <code>get_todos</code> vai precisar de algumas mudanças como um <code>let client = client()</code> e fazer esse <code>client</code> executar um <code>scan</code> no banco de dados com o valor de <code>scan_item</code>. Em caso de <code>Err</code> no <code>match</code> retornamos <code>None</code> e em caso de sucesso precisamos passar a função por um <code>adapter</code> que transforma um <code>ScanOutput</code> em um vetor de <code>TodoCard</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn get_todos() -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use crate::todo_api::db::helpers::client;
    use rusoto_dynamodb::DynamoDb;

    let client = client();
    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        ..ScanInput::default()
    };

    match client.scan(scan_item).sync() {
        Ok(resp) =&gt; Some(adapter::scanoutput_to_todocards(resp)),
        Err(_) =&gt; None,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que limitamos o <code>ScanInput</code> a <code>100i64</code>, isso se deve ao fato de que o Dynamo não vai responder mais de 100 itens. Se você precisar de mais, é importante realizar filtros no scan. Antes de implementarmos o <code>adapter</code>, seria bom dar uma olhada em como é um <code>ScanOutput</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ScanOutput { 
    consumed_capacity: None, 
    count: Some(2), 
    items: Some([
        {&quot;title&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;title&quot;), ss: None }, 
        &quot;description&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;descrition&quot;), ss: None }, 
        &quot;owner&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;), ss: None }, 
        &quot;state&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;Done&quot;), ss: None }, 
        &quot;id&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;), ss: None }, 
        &quot;tasks&quot;: AttributeValue { b: None, bool: None, bs: None, l: Some([
            AttributeValue { b: None, bool: None, bs: None, l: None, m: Some({
                &quot;is_done&quot;: AttributeValue { b: None, bool: Some(true), bs: None, l: None, m: None, n: None, ns: None, null: None, s: None, ss: None }, 
                &quot;title&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;blob&quot;), ss: None }
            }), 
            n: None, ns: None, null: None, s: None, ss: None }]), m: None, n: None, ns: None, null: None, s: None, ss: None }
        }, 
        {&quot;owner&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;), ss: None }, 
        &quot;description&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;descrition&quot;), ss: None }, 
        &quot;id&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;23997c2c-cd10-477f-8838-e88f2f6d7e7d&quot;), ss: None }, 
        &quot;state&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;Done&quot;), ss: None }, 
        &quot;title&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;title&quot;), ss: None }, 
        &quot;tasks&quot;: AttributeValue { b: None, bool: None, bs: None, l: Some([
            AttributeValue { b: None, bool: None, bs: None, l: None, m: Some({
                &quot;title&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;blob&quot;), ss: None }, 
                &quot;is_done&quot;: AttributeValue { b: None, bool: Some(true), bs: None, l: None, m: None, n: None, ns: None, null: None, s: None, ss: None }}), n: None, ns: None, null: None, s: None, ss: None }
            ]),m: None, n: None, ns: None, null: None, s: None, ss: None }
        }]), 
    last_evaluated_key: None, 
    scanned_count: Some(2) }
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos começar a implementar a função <code>scanoutput_to_todocards</code> e, para isso, vamos escrever o primeiro teste com apenas um <code>items</code> em <code>src/todo_api/adapters/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod scan_to_cards {
    use super::scanoutput_to_todocards;
    use crate::todo_api_web::model::{Task, TodoCard, State};
    use rusoto_dynamodb::ScanOutput;

    fn scan_with_one() -&gt; ScanOutput {
        let mut tasks_hash = std::collections::HashMap::new();
        tasks_hash.insert(&quot;title&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;blob&quot;.to_string()), ss: None });
        tasks_hash.insert(&quot;is_done&quot;.to_string(), AttributeValue{ b: None, bool: Some(true), bs: None, l: None, m: None, n: None, ns: None, null: None, s: None, ss: None });
        let mut hash = std::collections::HashMap::new();
        hash.insert(&quot;title&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;title&quot;.to_string()), ss: None });
        hash.insert(&quot;description&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;description&quot;.to_string()), ss: None });
        hash.insert(&quot;owner&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;.to_string()), ss: None });
        hash.insert(&quot;id&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;.to_string()), ss: None });
        hash.insert(&quot;state&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;Done&quot;.to_string()), ss: None });
        hash.insert(&quot;tasks&quot;.to_string(), AttributeValue { b: None, bool: None, bs: None, l: Some(vec![
            AttributeValue { b: None, bool: None, bs: None, l: None, m: Some(tasks_hash), n: None, ns: None, null: None, s: None, ss: None }]), m: None, n: None, ns: None, null: None, s: None, ss: None });

        ScanOutput { 
            consumed_capacity: None, 
            count: Some(1), 
            items: Some(vec![hash]), 
            last_evaluated_key: None, 
            scanned_count: Some(1) }
    }

    #[test]
    fn scanoutput_has_one_item() {
        let scan = scan_with_one();
        let todos = vec![
            TodoCard {
                title: &quot;title&quot;.to_string(),
                description: &quot;description&quot;.to_string(),
                state: State::Done,
                id: Some(uuid::Uuid::parse_str(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;).unwrap()),
                owner: uuid::Uuid::parse_str(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;).unwrap(),
                tasks: vec![
                    Task {
                        is_done: true,
                        title: &quot;blob&quot;.to_string()
                    }
                ]
            }
        ];

        assert_eq!(scanoutput_to_todocards(scan), todos)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos finalmente implementar nossa função <code>scanoutput_to_todocards</code> para o caso de 1 <code>items</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scanoutput_to_todocards(scan: ScanOutput) -&gt; Vec&lt;TodoCard&gt; {
    let item = scan.items.unwrap()[0].to_owned();

    vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(&amp;item.get(&quot;id&quot;).unwrap().s.clone().unwrap()).unwrap()),
        owner: uuid::Uuid::parse_str(&amp;item.get(&quot;owner&quot;).unwrap().s.clone().unwrap()).unwrap(),
        title: item.get(&quot;title&quot;).unwrap().s.clone().unwrap(),
        description: item.get(&quot;description&quot;).unwrap().s.clone().unwrap(),
        state: State::from(item.get(&quot;state&quot;).unwrap().s.clone().unwrap()),
        tasks: item .get(&quot;tasks&quot;).unwrap().l .clone().unwrap()
            .iter()
            .map(|t| Task {
                title: t.clone().m.unwrap().get(&quot;title&quot;).unwrap()
                    .s.clone().unwrap(),
                is_done: t.clone().m.unwrap().get(&quot;is_done&quot;).unwrap()
                    .bool.clone().unwrap(),
            })
            .collect::&lt;Vec&lt;Task&gt;&gt;(),
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>Infelizmente o código de <code>scanoutput_to_todocards</code> conta com muitas referências e tipos <code>Option</code>, o que nos força a ter um excesso de <code>clone()</code> e <code>unwrap()</code>, mas basicamente estamos navegando por dentro dos tipos de <code>AttributeValue</code> e, quando o tipo é um <code>HashMap</code>, utilizamos <code>get</code>. Agora podemos testar o caso para um <code>scan</code> com dois conjuntos de <code>AttributeValue</code>. Para isso, vamos isolar a criação dos <code>HashMap</code> em <code>scan_with_one</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attr_values() -&gt; std::collections::HashMap&lt;String, AttributeValue&gt; {
        let mut tasks_hash = std::collections::HashMap::new();
        tasks_hash.insert(
            &quot;title&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None, 
                ns: None, null: None, s: Some(&quot;blob&quot;.to_string()), ss: None,
            },
        );
        tasks_hash.insert(
            &quot;is_done&quot;.to_string(),
            AttributeValue {
                b: None, bool: Some(true), bs: None, l: None,
                m: None, n: None, ns: None, null: None, s: None,  ss: None,
            },
        );
        let mut hash = std::collections::HashMap::new();
        hash.insert(
            &quot;title&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None, s: Some(&quot;title&quot;.to_string()), ss: None,
            },
        );
        hash.insert(
            &quot;description&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None,s: Some(&quot;description&quot;.to_string()), ss: None,
            },
        );
        hash.insert(
            &quot;owner&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None, s: Some(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;.to_string()),
                ss: None,
            },
        );
        hash.insert(
            &quot;id&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None, s: Some(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;.to_string()),
                ss: None,
            },
        );
        hash.insert(
            &quot;state&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None, s: Some(&quot;Done&quot;.to_string()), ss: None,
            },
        );
        hash.insert(
            &quot;tasks&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None,
                l: Some(vec![AttributeValue {
                    b: None, bool: None, bs: None, l: None,
                    m: Some(tasks_hash), n: None, ns: None,
                    null: None, s: None, ss: None,
                }]),
                m: None, n: None, ns: None, null: None, s: None,  ss: None,
            },
        );
        hash
    }
<span class="boring">}
</span></code></pre></pre>
<p>Assim a função <code>scan_with_one</code> fica:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_with_one() -&gt; ScanOutput {
    let hash = attr_values();

    ScanOutput {
        consumed_capacity: None,
        count: Some(1),
        items: Some(vec![hash]),
        last_evaluated_key: None,
        scanned_count: Some(1),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E podemos fazer a <code>scan_with_two</code> ser:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_with_two() -&gt; ScanOutput {
        let hash = attr_values();

        ScanOutput {
            consumed_capacity: None,
            count: Some(2),
            items: Some(vec![hash.clone(), hash]),
            last_evaluated_key: None,
            scanned_count: Some(2),
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>E assim já implementamos o seguinte teste (lembre-se de adicionar a trait <code>Clone</code> a <code>TodoCard</code> e seus derivados):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn scanoutput_has_two_items() {
    let scan = scan_with_two();
    let todo = TodoCard {
        title: &quot;title&quot;.to_string(),
        description: &quot;description&quot;.to_string(),
        state: State::Done,
        id: Some(uuid::Uuid::parse_str(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;).unwrap()),
        owner: uuid::Uuid::parse_str(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;).unwrap(),
        tasks: vec![Task {
            is_done: true,
            title: &quot;blob&quot;.to_string(),
        }],
    };
    let todos = vec![todo.clone(), todo];

    assert_eq!(scanoutput_to_todocards(scan), todos)
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso teste falha e agora nos permite modificar a função <code>scanoutput_to_todocards</code> para retornar um vetor com todos os <code>TodoCard</code>s contidos em <code>ScanOutput</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scanoutput_to_todocards(scan: ScanOutput) -&gt; Vec&lt;TodoCard&gt; {
    scan.items.unwrap()
        .into_iter()
        .map(|item| TodoCard {
            id: Some(uuid::Uuid::parse_str(&amp;item.get(&quot;id&quot;).unwrap().s.clone().unwrap()).unwrap()),
            owner: uuid::Uuid::parse_str(&amp;item.get(&quot;owner&quot;).unwrap().s.clone().unwrap()).unwrap(),
            title: item.get(&quot;title&quot;).unwrap().s.clone().unwrap(),
            description: item.get(&quot;description&quot;).unwrap().s.clone().unwrap(),
            state: State::from(item.get(&quot;state&quot;).unwrap().s.clone().unwrap()),
            tasks: item.get(&quot;tasks&quot;).unwrap().l.clone().unwrap()
                .iter()
                .map(|t| Task {
                    title: t.clone().m.unwrap().get(&quot;title&quot;)
                        .unwrap().s.clone().unwrap(),
                    is_done: t.clone().m.unwrap().get(&quot;is_done&quot;)
                        .unwrap().bool.clone().unwrap(),
                })
                .collect::&lt;Vec&lt;Task&gt;&gt;(),
        })
        .collect::&lt;Vec&lt;TodoCard&gt;&gt;()
}
<span class="boring">}
</span></code></pre></pre>
<p>A mudança que fizemos é bastante simples. Ela simplesmente consiste em transformar a variável <code>item</code> em um argumento da closure de <code>map</code>. Dessa forma, scan vira um iterável com <code>scan.items.unwrap().into_iter()</code> e, depois do <code>map</code>, colecionamos todos os valores com <code>.collect::&lt;Vec&lt;TodoCard&gt;&gt;()</code>. Pronto, <code>adapter</code> feito. Agora podemos utilizar esse <code>adapter</code> na função <code>get_todos</code>. Para testar a mudança, podemos executar a aplicação novamente e testar:</p>
<p><img src="part-1/imagens/get_todos.png" alt="Obtendo todos nossos TodoCards." /></p>
<p>No próximo capítulo, vamos parar um pouco com a criação de endpoints e entender melhor como tornar nosso serviço mais viável para produção</p>
<p><a href="part-1/02-create.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/04-serving.html">Próximo</a></p>
<p><a href="part-1/03-get.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/05-auth.html">Próximo</a></p>
<h1 id="tornam-nosso-serviço-mais-realístico"><a class="header" href="#tornam-nosso-serviço-mais-realístico">Tornam nosso serviço mais realístico</a></h1>
<p>Agora vamos aplicar uma série de mudanças em nosso servidor para deixá-lo mais robusto. Algumas dessas mudanças incluem sistemas de logs, conteinerizar a aplicação, tornar ela fault tolerante, headers padrões e mais. Para isso, vamos começar com o mais simples e indispensável, o sistema de logs.</p>
<h2 id="aplicando-logs"><a class="header" href="#aplicando-logs">Aplicando logs</a></h2>
<p>O primeiro passo para começarmos a entender logs em Rust é darmos uma olhada na crate responsável por isso. A crate que vamos utilizar é a <code>log = &quot;0.4.8&quot;</code>, que implementa sua lógica de logs de acordo com a ideia de que um log consiste em um <code>alvo</code>, um <code>nível</code> e um <code>corpo</code>. O alvo é uma string que define o caminho do módulo no qual o requerimento do log é necessário. O nível é a severidade do log, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code> e <code>trace</code>, e o corpo é o conteúdo que o log apresenta. </p>
<p>A crate que vamos utilizar nos disponibiliza cinco macros para isso: <code> error!, warn!, info!, debug!, trace!</code>, dentre as quais <code>error</code> é a mais severa e <code>trace</code> a menos severa. As macros funcionam de forma muito similar ao <code>println!</code>, assim a forma de utilizá-las é bastante intuitiva. Outra questão importante é que o sistema de logs deve ser inicializado apenas uma vez por outra crate, a mais comum delas é a <code>env_logger = &quot;0.7.1&quot;</code>. Um exemplo rápido de como ficaria a combinação dessas duas é:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate log;

fn main() {
    env_logger::init();

    info!(&quot;starting up&quot;);

    // ...
}
</code></pre></pre>
<h3 id="inicializando-o-sistema-de-logs"><a class="header" href="#inicializando-o-sistema-de-logs">Inicializando o sistema de Logs</a></h3>
<p>Para inicializar nosso sistema de logs, precisamos adicionar a crate <code>env_logger</code> ao nosso <code>[dependencies]</code> do <code>Cargo.toml</code>, o <code>env_logger = &quot;0.7.1&quot;</code>. Com a crate disponível, podemos importar o <code>env_logger</code> para o contexto do arquivo <code>main.rs</code> com <code>use env_logger;</code> e inicializá-lo com <code>env_logger::init()</code> conforme o código a seguir:</p>
<pre><pre class="playground"><code class="language-rust">// ...
use env_logger;

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    env_logger::init();
    // ...
}
</code></pre></pre>
<p>Com isso o c;odigo parece compilar, mas não conseguimos ver logs no console quando executamos um <code>curl</code>. Isso se deve ao fato de que precisamos informar ao <code>actix_web</code> que queremos que logs de algum nível sejam disponibilizados. Para isso, devemos incluir a linha <code>std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);</code> antes de <code>env_logger::init();</code> na função <code>main</code> para habilitar logs de <code>error</code> a <code>info</code>. Além disso, precisamos disponibilizar o middleware <code>Logger</code> com a forma como queremos o log, note que o middleware pertence à crate <code>actix_web</code>em <code>use actix_web::middleware::Logger;</code>:</p>
<pre><pre class="playground"><code class="language-rust">// ...
use actix_web::middleware::Logger;
use env_logger;
// ...

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);
    env_logger::init();
    create_table();
    
    HttpServer::new(|| {
        App::new()
        .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;))
        .configure(app_routes)
    })
    .workers(num_cpus::get() + 2)
    .bind(&quot;127.0.0.1:4000&quot;)
    .unwrap()
    .run()
    .await
}

</code></pre></pre>
<p>Se fizermos um <code>POST curl</code> agora no endpoint <code>/api/create</code> vamos receber o seguinte log:</p>
<pre><code>[2020-02-08T01:41:32Z INFO  actix_web::middleware::logger] IP:127.0.0.1:54089 DATETIME:2020-02-07T22:41:32-03:00 REQUEST:&quot;POST /api/create HTTP/1.1&quot; STATUS: 201 DURATION:33.976000
</code></pre>
<p>Note que o formato após os colchetes <code>[...]</code> é igual ao que definimos no middleware de <code>Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;)</code>, assim podemos entender alguns dos parâmetros que estamos passando:</p>
<ul>
<li><code>%a</code> é o IP do request.</li>
<li><code>%t</code> é o DateTime do request.</li>
<li><code>%r</code> é o método (<code>POST</code> no caso) seguido do endpoint (<code>/api/create</code>) e o protocolo usado.</li>
<li><code>%s</code> é o status de retorno do request.</li>
<li><code>%D</code> é a duração total do request, em milisegundos.</li>
</ul>
<p>Algumas outras variáveis disponíveis nesse middleware são:</p>
<ul>
<li><code>%t</code> horário no qual o request começou a ser processado.</li>
<li><code>%P</code> o ID do processo filho que serviu o request.</li>
<li><code>%b</code> tamanho da resposta em bytes (inclui os headers).</li>
<li><code>%T</code> duração do request em segundos com fração float de <code>.06f</code>.</li>
<li><code>%{FOO}i</code> headers[‘FOO’] do request.</li>
<li><code>%{FOO}o</code> headers[‘FOO’] da response.</li>
<li><code>%{FOO}e</code> valor da variável de ambiente <code>FOO</code>, <code>os.environ[&quot;FOO&quot;]</code>.
Algumas outras variávels disponíveis neste middleware são:</li>
</ul>
<h3 id="adicionando-logs"><a class="header" href="#adicionando-logs">Adicionando logs</a></h3>
<p>Para adicionar os logs ao nosso código, vamos utilizar duas macros <code>error!</code> e <code>debug!</code>. Para isso, precisamos adicionar <code>log = &quot;0.4&quot;</code> ao nosso <code>[dependencies]</code> no <code>Cargo.toml</code>. A função de <code>debug</code> deverá nos apoiar com resultados no ambiente de desenvolvimento, enquanto a função de <code>error!</code> será exibir os erros no console. Para isso, usaremos o código <code>use log::{error, debug};</code>. Um bom local para inicializar é no <code>create_table</code>, a primeira função que nosso código executa. Para modo debug, utilize a env <code>std::env::set_var(&quot;RUST_LOG&quot;, &quot;debug&quot;);</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::{debug, error};
// ...

pub fn create_table() {
    let client = client();
    let list_tables_input: ListTablesInput = Default::default();

    match client.list_tables(list_tables_input).sync() {
        Ok(list) =&gt; {
            match list.table_names {
                Some(table_vec) =&gt; {
                    if table_vec.len() &gt; 0 {
                        error!(&quot;Table already exists and has more then one item&quot;);
                    } else {
                        create_table_input()
                    }
                }
                None =&gt; create_table_input(),
            };
        }
        Err(_) =&gt; {
            create_table_input();
        }
    }
}

fn create_table_input() {
    // ...

    match client.create_table(create_table_input).sync() {
        Ok(output) =&gt; {
            debug!(&quot;Table created {:?}&quot;, output);
        }
        Err(error) =&gt; {
            error!(&quot;Could not create table due to error: {:?}&quot;, error);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Outro lugar em que podemos aplicar logs é no arquivo <code>src/todo_api/db/todo.rs</code>, pois as funções de <code>put</code> e <code>get</code> são bastante suscetíveis a erros. Assim podemos modificar o arquivo para:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use log::{debug, error};

#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn put_todo(todo_card: TodoCardDb) -&gt; Option&lt;Uuid&gt; {
    // ...

    match client.put_item(put_item).sync() {
        Ok(_) =&gt; {
            debug!(&quot;item created with id {:?}&quot;, todo_card.id);
            Some(todo_card.id)
        },
        Err(e) =&gt; {
            error!(&quot;error when creating item {:?}&quot;, e);
            None
        }
    }
}

#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn get_todos() -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    // ...

    match client.scan(scan_item).sync() {
        Ok(resp) =&gt; {
            let todocards = adapter::scanoutput_to_todocards(resp);
            debug!(&quot;Scanned {:?} todo cards&quot;, todocards);
            Some(todocards)
        },
        Err(e) =&gt; {
            error!(&quot;Could not scan todocards due to error {:?}&quot;, e);
            None
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que nos casos de <code>Err</code> agora estamos logando o motivo com <code>e</code>. O úmtimo passo para este momento é adicionar logs aos controllers em <code>src/todo_api_web/controllers/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::{error};
// ...

pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = adapter::todo_json_to_db(info, uuid::Uuid::new_v4());

    match put_todo(todo_card) {
        None =&gt; {
            error!(&quot;Failed to create todo card&quot;);
            HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;)
        },
        Some(id) =&gt; HttpResponse::Created()
            .content_type(&quot;application/json&quot;)
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(&quot;Failed to serialize todo card&quot;))
    }
}

pub async fn show_all_todo() -&gt; impl Responder {
    match get_todos() {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::InternalServerError().body(&quot;Failed to read todo cards&quot;)
        },
        Some(todos) =&gt; HttpResponse::Ok()
            .content_type(&quot;application/json&quot;)
            .body(serde_json::to_string(&amp;TodoCardsResponse{cards: todos}).expect(&quot;Failed to serialize todo cards&quot;)),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que adicionamos somente a opção de <code>error</code> já que o <code>None =&gt; {...}</code> é a única resposta que pode conter diversas razões, pelo fato do <code>Some</code> já estar mapeado em <code>put_todo</code> e <code>get_todos</code>.</p>
<h2 id="tornando-nosso-sistema-tolerância-a-falha"><a class="header" href="#tornando-nosso-sistema-tolerância-a-falha">Tornando nosso sistema tolerância a falha</a></h2>
<p>Erlang possui um sistema de tolerância a falhas inspirado em sistemas de atores bastante poderosos e versáteis. Assim a comunidade Rust desenvolveu uma crate que ajuda esse sistema. A crate é chamada de <code>bastion</code> e depende de outra crate chamada <code>fort</code>, que disponibiliza o runtime, para que <code>bastion</code> funcione. <strong>Lembre-se de que adicionar runtimes implica em um aumento de consumo de memória e tamanho de executável</strong>, mas vamos seguir com essa abordagem. Assim adicionamos as duas crates ao nosso <code>[dependencies]</code> do <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
# ...
fort = &quot;0.3&quot;
bastion = &quot;0.3&quot;
</code></pre>
<p>Para utilizarmos a crate <code>fort</code>, precisamos habilitar o runtime de <code>bastion</code> com a macro <code>#[fort::root]</code> e modificar a chamada da <code>main</code>. Fazemos isso modificando a antiga função <code>main</code> para se chamar <code>web_main</code> ou <code>actix_main</code>, e chamamos ela da instância <code>main</code> na qual o <code>bastion</code> está disponível:</p>
<pre><pre class="playground"><code class="language-rust">// ...
use bastion::prelude::*;


#[actix_rt::main]
async fn web_main() -&gt; Result&lt;(), std::io::Error&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);
    env_logger::init();
    create_table();
    
    HttpServer::new(|| {
        App::new()
        .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;))
        .configure(app_routes)
    })
    .workers(num_cpus::get() + 2)
    .bind(&quot;127.0.0.1:4000&quot;)
    .unwrap()
    .run()
    .await
}

#[fort::root]
async fn main(_: BastionContext) -&gt; Result&lt;(), ()&gt; {
    let _ = web_main();
    Ok(())
}
</code></pre></pre>
<p>Note que a função <code>main</code> também é declarada como <code>async</code>, isso é um requerimento de <code>fort::root</code>. Assim, ao executarmos <code>cargo run</code> o sistema vai se reiniciar mesmo que utilizemos <code>crtl+c</code>. Inclusive outro teste que podemos fazer é adicionar um <code>panic!</code> antes do <code>Ok(())</code>, que interromperá a thread a cada ciclo:</p>
<pre><pre class="playground"><code class="language-rust">#[fort::root]
async fn main(_: BastionContext) -&gt; Result&lt;(), ()&gt; {
    let _ = web_main();
    panic!(&quot;Holy shit&quot;);
    Ok(())
}
</code></pre></pre>
<p>Note que neste caso, ao tentarmos utilizar um extra <code>ctrl+c</code> recebemos o seguinte erro:</p>
<pre><code>Panic in Arbiter thread.
thread 'bastion-async-thread' panicked at 'env_logger::init should not be called after logger initialized: SetLoggerError(())', src/libcore/result.rs:1165:5
</code></pre>
<p>Com isso, podemos concluir que as funções <code>std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;)</code>, <code>env_logger::init()</code> e <code>create_table()</code> não precisam estar dentro da função <code>web_main()</code>:</p>
<pre><pre class="playground"><code class="language-rust">#[actix_rt::main]
async fn web_main() -&gt; Result&lt;(), std::io::Error&gt; {    
    HttpServer::new(|| {
        App::new()
        .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;))
        .configure(app_routes)
    })
    .workers(num_cpus::get() + 2)
    .bind(&quot;127.0.0.1:4000&quot;)
    .unwrap()
    .run()
    .await
}

#[fort::root]
async fn main(_: BastionContext) -&gt; Result&lt;(), ()&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);
    env_logger::init();
    create_table();
    
    let _ = web_main();

    Ok(())
}
</code></pre></pre>
<p>Na macro <code>fort::root</code>, existe um atributo a mais que podemos passar, o <code>redundancy</code>. Este atributo espera um valor do tipo inteiro positivo e, para utilizá-lo, basta adicionar <code>#[fort::root(redundancy = 2)]</code>. O atributo <code>redundancy</code> corresponde ao número de elementos que este grupo vai ter, no nosso caso a quantidade de <code>web_main()</code> que vamos iniciar, valor padrão de <code>redundancy</code> é <code>1</code>.</p>
<p>No momento, precisamos ter cuidado, pois já estabelecemos uma quantidade de <code>workers</code> igual a <code>num_cpus::get() + 2</code> e isso faz com que não sobrem muitos cores para iniciarmos processos. Uma possível solução para o <code>redundancy</code> seria iniciá-lo em diferentes máquinas distribuídas, mas essa crate de <code>bastion</code> ainda não está estável. Outra possível forma de limitar o tamanho dos <code>workers</code> para poder tirar proveito do <code>redundancy</code> é definir no <code>HttpServer</code> a quantidade máxima de conexões que cada <code>worker</code> pode estabelecer com a função <code>maxconn</code>, seu valor padrão é <code>25k</code>. Um exemplo fictício seria:</p>
<pre><pre class="playground"><code class="language-rust">#[actix_rt::main]
async fn web_main() -&gt; Result&lt;(), std::io::Error&gt; {    
    HttpServer::new(|| {
        App::new()
        .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;))
        .configure(app_routes)
    })
    .workers(num_cpus::get() - 2)
    .maxconn(30000)
    .bind(&quot;127.0.0.1:4000&quot;)
    .unwrap()
    .run()
    .await
}

#[fort::root(redundancy = 10)]
async fn main(_: BastionContext) -&gt; Result&lt;(), ()&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_web=info&quot;);
    env_logger::init();
    create_table();
    
    let _ = web_main();

    Ok(())
}
</code></pre></pre>
<blockquote>
<p>A crate que, no momento em que escrevi este livro, estava sendo desenvolvida para instâncias remotas do <code>bastion</code> pode ser encontrada no link https://github.com/bastion-rs/artillery.</p>
</blockquote>
<p>Agora podemos evoluir nosso código para facilitar nossa vida quando executamos um processo que se recusa a terminar, faremos isso com containers docker.</p>
<h2 id="incluindo-docker"><a class="header" href="#incluindo-docker">Incluindo Docker</a></h2>
<p>Como o foco deste livro não é docker e ele não é um requisito para entender o livro, vou mostrar o código e explicar um pouco o que está acontecendo. Assim vamos começar por um <code>Dockerfile</code> extremamente simples.</p>
<pre><code class="language-Dockerfile">FROM rustlang/rust:nightly

RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app

COPY . /usr/src/app

CMD [&quot;cargo&quot;, &quot;build&quot;, &quot;-q&quot;]
</code></pre>
<p>A primeira diretiva, a <code>FROM</code>, tem como objetivo definir a imagem base para nosso contêiner. Nesse caso, estamos utilizando uma versão <code>nightly</code> do Rust, pois a versão stable não era compatível com a versão da minha máquina quando escrevi este livro. Depois disso, temos a diretiva <code>RUN</code>, que executa algum comando, no nosso caso a criação da pasta <code>/usr/src/app</code>, e já definimos essa pasta como o diretório que vamos utilizar com <code>WORKDIR</code>. Depois disso, copiamos todo nosso código para nosso diretório com <code>COPY</code> e executamos um comando do cargo, o <code>build</code>, para construir nossa aplicação, <code>cargo build -q</code> com <code>CMD</code>. Outra opção de <code>Dockerfile</code> com otimização para builds repetidos é:</p>
<pre><code class="language-Dockerfile">FROM rust:latest

RUN mkdir -p /usr/src/
WORKDIR /usr/src/
RUN USER=root cargo new --bin app
WORKDIR /app

COPY ./Cargo.lock ./Cargo.lock
COPY ./Cargo.toml ./Cargo.toml
COPY ./tests ./tests

RUN cargo build --release
RUN rm src/*.rs

COPY ./src ./src

CMD [&quot;cargo&quot;, &quot;build&quot;, &quot;--release&quot;]
</code></pre>
<p>O objetivo desse segundo <code>Dockerfile</code> é diminuir o tempo de execução do contêiner ao cachear as dependências do app e somente atualizar o cache a partir do <code>COPY ./src ./src</code>.</p>
<p>Com este container pronto, podemos começar a pensar em como utilizar os dois containers (DynamoDB e <code>todo_server</code>) em conjunto. Faremos isso com <code>docker-compose.yml</code>:</p>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    command: cargo run
    ports:
      - &quot;4000:4000&quot;
    cap_drop:
      - all
    cap_add:
      - NET_BIND_SERVICE
    environment:
      - AWS_ACCESS_KEY_ID=foo
      - AWS_SECRET_ACCESS_KEY=bar
      - AWS_REGION=julia-home
      - AWS_DYNAMODB_ENDPOINT=http://dynamodb:8000
    depends_on:
      - dynamodb
    links:
      - dynamodb
    networks:
      internal_net:
        ipv4_address: 172.21.1.2

  dynamodb:
    container_name: &quot;dynamodb&quot;
    image: amazon/dynamodb-local
    ports:
      - &quot;8000:8000&quot;
    networks:
      internal_net:
        ipv4_address: 172.21.1.1
    environment:
      - ./Djava.library.path=./DynamoDBLocal_lib
    volumes:
      - dynamodata:/home/dynamodblocal/
    working_dir: /home/dynamodblocal/
    command: &quot;-jar DynamoDBLocal.jar -sharedDb -dbPath .&quot;

networks:
  internal_net:
    ipam:
      driver: default
      config:
        - subnet: 172.21.0.0/16

volumes:
  dynamodata:
</code></pre>
<p>Nosso <code>docker-compose</code> precisa de quatro chaves principais: <code>version</code>, que corresponde à versão do compose, <code>services</code>, que corresponde aos contêineres que vamos rodar, <code>networks</code> é a configuração de rede que vamos utilizar, e <code>volumes</code> são os volumes compartilhados com os contêineres. A configuração de <code>networks</code> simplesmente define uma rede interna com <code>internal_net</code> e uma range de subnets em <code>subnet: 172.21.0.0/16</code>. Em <code>services</code>, precisamos declarar dois contêineres <code>web</code>, os quais conterão nossa aplicação e o contêiner <code>dynamodb</code>, que conterá a imagem do <strong>DynamoDB</strong>. O contêiner <code>dynamodb</code> possui as seguintes chaves:</p>
<ul>
<li><code>container_name</code>: é o nome do contêiner, no nosso caso <code>dynamodb</code>.</li>
<li><code>image</code>: a fonte da imagem que estamos utilizando, no caso do DynamoDB é <code>amazon/dynamodb-local</code>.</li>
<li><code>ports</code>: o mapeamento de portas de dentro do contêiner para fora, <code>8000:8000</code>.</li>
<li><code>networks</code>: a definição do IP que vamos utilizar, <code>ipv4_address: 172.21.1.1</code>.</li>
<li><code>environment</code>: configurações de ambiente, <code>./Djava.library.path=./DynamoDBLocal_lib</code>, relevante para o dynamo.</li>
<li><code>volumes</code>: volumes disponíveis para o dynamo utilizar, <code>dynamodata:/home/dynamodblocal/</code>.</li>
<li><code>working_dir</code>: diretório no qual o dynamo executará, <code>/home/dynamodblocal/</code>.</li>
<li><code>command</code>: para inicializar o dynamo <code>&quot;-jar DynamoDBLocal.jar -sharedDb -dbPath .&quot;</code>.</li>
</ul>
<p>Depois disso temos o <code>web</code>, que não vou repetir algumas chaves:</p>
<ul>
<li><code>build</code>: o contexto de criação da imagem, <code>context: .</code>. No caso, estamos passando um dockerfile chamado <code>Dockerfile</code> <code>dockerfile: Dockerfile</code>.</li>
<li><code>command</code>: executamos o comando <code>cargo run</code> para essa aplicação.</li>
<li><code>cap_drop</code> e <code>cap_add</code>: correspondem a capacidade de um container de remover ou de adicionar capacidades.</li>
<li><code>environment</code>: para executar o DynamoDB dessa forma precisamos adicionar algumas variáveis de ambiente para que o <code>client</code> configure suas credenciais.
<ul>
<li><code>AWS_ACCESS_KEY_ID=foo</code></li>
<li><code>AWS_SECRET_ACCESS_KEY=bar</code></li>
<li><code>AWS_REGION=julia-home</code></li>
<li><code>AWS_DYNAMODB_ENDPOINT=http://dynamodb:8000</code></li>
</ul>
</li>
<li><code>depends_on</code>: define a ordem na qual os serviços devem ser inicializados, assim <code>dynamodb</code> é inicializado antes de <code>web</code></li>
<li><code>links</code>: forma legada de fazer com que dois serviços estejam conectados, atualmente bastaria o <code>networks</code>, mas coloquei como exemplo. No caso de <code>links</code> e <code>networks</code> estarem definidos, é preciso que ambos estejam na mesma rede.</li>
</ul>
<p>Se executarmos <code>docker-compose up</code>, veremos que nossos serviços são inicializados, porém, quando fazemos um request, ocorre uma falha de comunicação. Para resolver essa falha, precisamos alterar nosso cliente para que ele se conecte às configurações da rede do <code>docker-compose</code>. Para isso, podemos criar um novo cliente e fazer com que o antigo execute somente com a feature <code>dynamo</code> ativada:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/db/helpers.rs
// ...
#[cfg(feature = &quot;dynamo&quot;)]
pub fn client() -&gt; DynamoDbClient {
    DynamoDbClient::new(Region::Custom {
        name: String::from(&quot;us-east-1&quot;),
        endpoint: String::from(&quot;http://localhost:8000&quot;),
    })
}

#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn client() -&gt; DynamoDbClient {
    DynamoDbClient::new(Region::Custom {
        name: String::from(&quot;julia-home&quot;),
        endpoint: String::from(&quot;http://dynamodb:8000&quot;),
    })
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, precisamos alterar o <code>bind</code> de nosso servidor para expor o serviço para fora do container:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

#[actix_rt::main]
async fn web_main() -&gt; Result&lt;(), std::io::Error&gt; {    
    HttpServer::new(|| {
        App::new()
        .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;))
        .configure(app_routes)
    })
    .workers(num_cpus::get() + 2)
    .bind(&quot;0.0.0.0:4000&quot;)
    .unwrap()
    .run()
    .await
}

// ...
<span class="boring">}
</span></code></pre></pre>
<p>Se tivéssemos as configurações de produção, poderíamos criar a feature <code>compose</code> para utilizar com o <code>docker-compose</code>. Se executarmos o código agora com <code>docker-compose up --build</code> e, em seguida, um <code>curl</code>, tudo voltará a funcionar como antes. Outra coisa que podemos fazer agora é atualizar nosso Makefile para incluir o <code>docker-compose</code>:</p>
<pre><code class="language-sh">db:
	docker run -p 8000:8000 amazon/dynamodb-local

test:
	cargo test --features &quot;dynamo&quot;

run-local:
	cargo run --features &quot;dynamo&quot;

run:
	docker-compose up --build

down:
	docker-compose down
</code></pre>
<h2 id="headers-padrões"><a class="header" href="#headers-padrões">Headers padrões</a></h2>
<p>Outro ponto que acredito ser importante é o uso de headers para identificar os requests nos logs. Costumo ver o padrão de um header chamado <code>x-request-id</code> cujo valor é um <code>uuid</code>. Para implementarmos esse padrão com o actix, precisamos utilizar um middleware que felizmente a equipe do actix já disponibilizou para nós, o <code>actix_web::middleware::DefaultHeaders</code>. Para isso, precisamos disponibilizá-lo no escopo com <code>use</code> e depois passar essa informação para um <code>wrap</code>. A forma de utilizar esses headers padrões é <code>DefaultHeaders::new().header(&quot;X-Version&quot;, &quot;0.2&quot;)</code>, isto é, criamos um novo header com <code>DefaultHeaders::new()</code> e depois chamamos a função <code>header</code> para adicionar um header com os argumentos-chave e valor do tipo string:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/main.rs
// ...
HttpServer::new(|| {
    App::new()
    .wrap(DefaultHeaders::new().header(&quot;x-request-id&quot;, Uuid::new_v4().to_string()))
    .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D&quot;))
    .configure(app_routes)
})
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, precisamos definir o header no <code>Logger</code>, para isso usamos a chave <code>X-REQUEST-ID:%{x-request-id}o</code> após a <code>DURATION</code>, pois somente assim o valor de <code>x-request-id</code> será logado:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
HttpServer::new(|| {
    App::new()
    .wrap(DefaultHeaders::new().header(&quot;x-request-id&quot;, Uuid::new_v4().to_string()))
    .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D X-REQUEST-ID:%{x-request-id}o&quot;))
    .configure(app_routes)
})
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Um exemplo de resposta seria:</p>
<pre><code>[2020-02-08T23:10:58Z INFO  actix_web::middleware::logger] IP:172.21.0.1:52686 DATETIME:2020-02-08T23:10:58Z REQUEST:&quot;POST /api/create HTTP/1.1&quot; STATUS: 201 DURATION:166.921700 X-REQUEST-ID=bd15de62-1ba6-4d43-89ca-4f89418
</code></pre>
<h2 id="adicionando-o-cliente-ao-estado-da-api"><a class="header" href="#adicionando-o-cliente-ao-estado-da-api">Adicionando o cliente ao estado da API</a></h2>
<p>Nosso próximo passo vem de uma necessidade de refactor e preparação para o código futuro. Esse refactor consiste em retirar a declaração de <code>let cliente = client();</code> de todos os códigos envolvendo banco de dados e passá-los como argumentos. Uma das vantagens disso é caso decidamos ter mais clientes de algum tipo de serviço como outros bancos de dados ou S3. Para fazermos isso, vamos criar uma nova struct chamada <code>Clients</code> que conterá o campo <code>dynamo</code> e depois a passaremos como argumento para o <code>HttpServer</code> via função <code>data</code>.</p>
<p>Assim, nosso primeiro passo é descrever a o modelo de <code>Clients</code> em <code>src/todo_api_web/model/http.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::db::helpers::client;

#[derive(Clone)]
pub struct Clients {
    pub dynamo: rusoto_dynamodb::DynamoDbClient,
}

impl Clients {
    pub fn new() -&gt; Self {
        Self { dynamo: client() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos utilizar a função <code>data</code> em <code>HttpServer</code> para passar Clients como argumento. Fazemos isso com <code>Clients::new()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use todo_api_web::{
    routes::app_routes,
    model::http::Clients,
};

#[actix_rt::main]
async fn web_main() -&gt; Result&lt;(), std::io::Error&gt; {  
    HttpServer::new(|| {
        App::new()
        .data(Clients::new())
        .wrap(DefaultHeaders::new().header(&quot;x-request-id&quot;, Uuid::new_v4().to_string()))
        .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D X-REQUEST-ID:%{x-request-id}o&quot;))
        .configure(app_routes)
    })
    .workers(num_cpus::get() + 2)
    .bind(&quot;0.0.0.0:4000&quot;)
    .unwrap()
    .run()
    .await
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Com isso temos <code>Clients</code> disponível no nos nossos controllers, para isso adicionamos o estado com <code>state: web::Data&lt;Clients&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use crate::{
    // ...
    todo_api_web::model::{
        http::Clients,
        TodoCard, TodoIdResponse, TodoCardsResponse
    }
};


pub async fn create_todo(state: web::Data&lt;Clients&gt;, info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = adapter::todo_json_to_db(info, uuid::Uuid::new_v4());

    match put_todo(state.dynamo.clone(), todo_card) {
        // ...
    }
}

pub async fn show_all_todo(state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    match get_todos(state.dynamo.clone()) {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos que as funcões <code>put_todo</code> e <code>get_todos</code> tenham como argumentos um <code>client :rusoto_dynamo::DynamoDbClient</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use rusoto_dynamodb::{DynamoDbClient, PutItemInput, ScanInput};

#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn put_todo(client: DynamoDbClient, todo_card: TodoCardDb) -&gt; Option&lt;Uuid&gt; {
    use rusoto_dynamodb::DynamoDb;

    let put_item = PutItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        item: todo_card.clone().into(),
        ..PutItemInput::default()
    };

    match client.put_item(put_item).sync() {
        // ...
    }
}

#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn get_todos(client: DynamoDbClient) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use rusoto_dynamodb::DynamoDb;

    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        ..ScanInput::default()
    };

    match client.scan(scan_item).sync() {
        // ...
    }
}

#[cfg(feature = &quot;dynamo&quot;)]
pub fn get_todos(_: DynamoDbClient) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    // ...
}

#[cfg(feature = &quot;dynamo&quot;)]
pub fn put_todo(_: DynamoDbClient, todo_card: TodoCardDb) -&gt; Option&lt;Uuid&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Feito isso, devemos adicionar <code>.data(Clients::new())</code> a todos os testes de integração, pois esse argumento é esperado nas funções de controller. Um exemplo seria:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
    async fn test_todo_cards_with_value() {
        let mut app = test::init_service(
            App::new()
                .data(Clients::new())
                .configure(app_routes)
        ).await;
    
        // ...
        assert_eq!(todo_cards.cards, mock_get_todos());
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="serializando-o-response"><a class="header" href="#serializando-o-response">Serializando o Response</a></h3>
<p>Até o momento estávamos utilizando o formato de criação de <code>HttpResponse</code> da seguinte maneira <code>HttpResponse::Ok().content_type(&quot;application/json&quot;).body(serde_json::to_string(&amp;struct).expect(&quot;Failed to serialize todo cards&quot;))</code>, mas existe uma forma que pode simplificar nossa vida por nos permitir delegar a chamada de <code>serde_json</code>. Esse formato substitui o <code>.body(...)</code> por <code>.json(...)</code>. A vantagem de se utilizar esse formato é que ele reduz a quantidade de código que nós devemos manter, delegando ao actix essa responsabilidade. Nos capítulos introdutórios do livro, falamos que o actix estava com muita vantagem em relação a outros frameworks nos benchmarks da TechEmpower, porém, no caso de serialização JSON, existem alguns frameworks C/C++ à sua frente, inclusive a crate <code>hyper</code>. O Objetivo de <code>body</code> é principalmente enviar mensagens sem dados estruturados ou estruturados em outros formatos como Edn.</p>
<p>Com esse pequeno refactor, nossos controllers de <code>todo</code> serão modificados para o seguinte formato:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_web_api/controller/todo.rs
// ...
pub async fn create_todo(state: web::Data&lt;Clients&gt;, info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = adapter::todo_json_to_db(info, uuid::Uuid::new_v4());

    match put_todo(state.dynamo.clone(), todo_card) {
        None =&gt; {
            error!(&quot;Failed to create todo card&quot;);
            HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;)
        }
        Some(id) =&gt; HttpResponse::Created()
            .content_type(&quot;application/json&quot;)
            .json(TodoIdResponse::new(id))
    }
}

pub async fn show_all_todo(state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    match get_todos(state.dynamo.clone()) {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::InternalServerError().body(&quot;Failed to read todo cards&quot;)
        }
        Some(todos) =&gt; HttpResponse::Ok().content_type(&quot;application/json&quot;)
            .json(TodoCardsResponse { cards: todos })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com isso, nosso código está pronto para receber novos clientes e nós podemos começar a pensar em autenticação.</p>
<p><a href="part-1/03-get.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/05-auth.html">Próximo</a></p>
<p><a href="part-1/04-serving.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/06-middleware.html">Próximo</a></p>
<h1 id="autenticação"><a class="header" href="#autenticação">Autenticação</a></h1>
<p>Criaremos funções do serviço para registrar e para fazer login no nosso serviço. Além disso, implementaremos um middleware que protege nossos endpoints de usuários não autenticados. Para realizar isso vamos utilizar a crate <code>Diesel</code> para lidar com a base de dados, que será o Postgres. Para isso precisamos seguir alguns passos:</p>
<ol>
<li>Instale a <code>diesel_cli</code>, pois este binário ajuda a gerenciar o projeto. Utilize <code>cargo install diesel_cli</code> para isso. Para compilar o <code>diesel_cli</code> é preciso ter a lib <code>lmysqlclient</code>, no MacOS podemos fazer isso com <code>brew install mysql</code> ou simplesmente utilizar <code>cargo install diesel_cli --no-default-features --features postgres</code> para isntalar somente o conector de <code>postgres</code>.</li>
<li>Ter um container disponível <code>docker run -i --rm --name auth-db -p 5432:5432 -e POSTGRES_USER=auth -e POSTGRES_PASSWORD=secret -d postgres</code></li>
<li>Para utilizar o <code>diesel_cli</code> executamos o comando <code>diesel setup</code>, mas para isso precisamos da url do postgress em um arquivo <code>.env</code> com <code>echo DATABASE_URL=postgres://auth:secret@localhost/auth_db &gt; .env</code>. Agora executamos <code>diesel setup</code> para estabelecer a conexão.</li>
<li>Depois podemos criar nossas migrações com <code>diesel migration generate create_auth</code>, note a pasta <code>migrations</code> com duas subpastas cada uma contendo um <code>up.sql</code> e um <code>down.sql</code>.</li>
<li>Na segunda pasta vamos criar a tabela <code>auth_user</code> em <code>up.sql</code>:</li>
</ol>
<pre><code class="language-sql">-- up.sql
CREATE TABLE auth_user (
    email VARCHAR(100) NOT NULL PRIMARY KEY,
    id UUID NOT NULL,
    password VARCHAR(64) NOT NULL, --bcrypt hash
    expires_at TIMESTAMP NOT NULL
);
</code></pre>
<pre><code class="language-sql">--down.sql
DROP TABLE auth_user;
</code></pre>
<ol start="6">
<li>Agora basta executar as migrations com <code>diesel migration run</code>, caso você queira reverter as migrations basta executar <code>diesel migration redo</code>. Note a criação de um arquivo <code>src/schema.rs</code> em nosso projeto:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table! {
    auth_user (email) {
        email -&gt; Varchar,
        id -&gt; Uuid,
        password -&gt; Varchar,
        expires_at -&gt; Timestamp,
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A macro table! gera código baseado no schema da base de dados que representes todas as tabelas e colunas.</p>
</blockquote>
<ol start="7">
<li>Tipicamente um schema não é criado na mão e sim gerado pelo binário <code>diesel</code>. Quando executamos <code>diesel setup</code>, um arquivo <code>diesel.toml</code> é criado para indicar ao <code>Diesel</code> para manter o arquivo <code>src/schema.rs</code> por nós.</li>
</ol>
<blockquote>
<p>Nota sobre Diesel em Produção</p>
<p>Quando em produção você talvez prefira executar suas migrações na inicialização da aplicação. Assim, a crate Diesel disponibiliza a macro <code>embed_migrations!</code>, permitindo embedar os scripts de migração como parte final do binário. Para usa-la, basta incluir <code>mbedded_migrations::run(&amp;db_conn)</code> no início de suas <code>main</code> e as migrações serão executadas.</p>
</blockquote>
<h2 id="configurando-o-postgress-com-rust"><a class="header" href="#configurando-o-postgress-com-rust">Configurando o Postgress com Rust</a></h2>
<p>Agora podemos começar a evoluir a autenticação do nosso servidor, para isso devemos adicionar algumas crates ao <code>[dependencies]</code> do Cargo.toml:</p>
<pre><code class="language-toml">actix = &quot;0.9.0&quot;
chrono = { version = &quot;0.4.10&quot;, features = [&quot;serde&quot;] }
diesel = { version = &quot;1.4.3&quot;, features = [&quot;postgres&quot;, &quot;uuidv07&quot;, &quot;r2d2&quot;, &quot;chrono&quot;] }
dotenv = &quot;0.15.0&quot;
r2d2 = &quot;0.8.8&quot;
</code></pre>
<p>A abordagem que vamos seguir aqui é diferente da apresentada no guia do diesel, consulte bibliografia para obter o link, pois vamos tentar tirar proveito do sistema de actors do actix (caso você queira, é um bom exercício aplicar a mesma estratégia ao <code>DynamoDbClient</code>). Assim, em nosso módulo <code>src/todo_api/db/helpers.rs</code> vamos criar uma struct <code>DbExecutor</code>, com um tipo de conexão de pool, que vai implementar a trait <code>Actor</code> do actix:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, SyncContext};
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool};

pub struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;);

impl Actor for DbExecutor {
    type Context = SyncContext&lt;Self&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Actors</p>
<p>Actors se comunicam exclusivamente pela troca de mensagens. Assim, o actor que envia a mensagem irá, opcionalmente, esperar pela respostas. Além disso, actors não são referenciados diretamente, mas sim pelos seus endereços. Qualquer tipo no RUst pode se tornar um actor, o único requerimento é que implemente a trait <code>Actor</code>.</p>
</blockquote>
<p>Depois disso precisamos adicionar a struct <code>DbExecutor</code> ao nosso <code>Clients</code>, porém nosso <code>DbExecutor</code> vai precisar precisar ser envelopado em um <code>Addr&lt;T&gt;</code>, que corresponde ao endereço do actor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/model/http.rs
use actix::prelude::Addr;
use crate::todo_api::db::helpers::{client, DbExecutor};

#[derive(Clone)]
pub struct Clients {
    pub dynamo: rusoto_dynamodb::DynamoDbClient,
    pub postgres: Addr&lt;DbExecutor&gt;,
}

impl Clients {
    pub fn new(pg: Addr&lt;DbExecutor&gt;) -&gt; Self {
        Self { 
            dynamo: client(),
            postgres: pg
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos de uma função que crie o <code>Addr&lt;DbExecutor&gt;</code> para podemos enviar como argumento ao <code>new</code>. Essa função se chamara <code>db_executor_address</code> e estará localizada em <code>src/todo_api/db/helpers.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Addr, SyncContext, SyncArbiter};
// ...
use diesel::{
    r2d2::{ConnectionManager, Pool},
    pg::PgConnection
};
use std::env;

// ...

pub struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;);

impl Actor for DbExecutor {
    type Context = SyncContext&lt;Self&gt;;
}

pub fn db_executor_address() -&gt; Addr&lt;DbExecutor&gt; {
    let database_url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);

    let manager = ConnectionManager::&lt;PgConnection&gt;::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect(&quot;Failed to create pool.&quot;);

    SyncArbiter::start(4, move || DbExecutor(pool.clone()))
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos modificar a função <code>Clients::new</code> para que não seja preciso passar <code>Addr&lt;DbExecutor&gt;</code> como argumento:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::db::helpers::{client, DbExecutor, db_executor_address};
use actix::prelude::Addr;

#[derive(Clone)]
pub struct Clients {
    pub dynamo: rusoto_dynamodb::DynamoDbClient,
    pub postgres: Addr&lt;DbExecutor&gt;,
}

impl Clients {
    pub fn new() -&gt; Self {
        Self {
            dynamo: client(),
            postgres: db_executor_address(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ao executar o código obtemos uma falha, pois <code>DATABASE_URL</code> não está setada, agora precisamos utilizar as configurações do postgres para o <code>docker-compose</code>:</p>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
# ...
  postgres:
    container_name: &quot;postgres&quot;
    image: postgres
    ports:
      - &quot;5432:5432&quot;
    networks:
      internal_net:
        ipv4_address: 172.21.1.15
    environment:
      - POSTGRES_USER=auth
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=auth_db
# ...
</code></pre>
<p>Para isso precisamos remover nosso <code>env_logger</code> nosso código e Cargo.toml. Além disso, a definição da variável de ambiente do log passa para o arquivo <code>.env</code>:</p>
<pre><code>DATABASE_URL=postgres://auth:secret@172.21.1.15/auth_db
RUST_LOG=actix_web=info
</code></pre>
<p>Agora precisamos executar as migrações no docker compose, para isso vamos utilizar <code>embed_migrations!</code> migrations como falamos anteriormente. A macro <code>embed_migrations!</code> está disponível na crate <code>diesel_migrations = &quot;1.4.0&quot;</code>, adicione ela a seu <code>[dependencies]</code> do Cargo.toml. No módulo <code>src/schema.rs</code> adicione a linha <code>embed_migrations!();</code> depois da macro <code>table!</code>. E agora precisamos que o código execute a migração. Para isso adicionamos a função <code>run_migrations</code> em <code>create_table</code>, no módulo <code>src/todo_api/db/helpers.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Addr, SyncArbiter, SyncContext};
use diesel::{
    prelude::*,
    r2d2::{ConnectionManager, Pool},
};
use diesel_migrations::run_pending_migrations;
use log::{debug, error};
// ...
use std::env;

// ...

pub fn create_table() {
    let client = client();
    let list_tables_input: ListTablesInput = Default::default();
    run_migrations();

    // ...
}

fn run_migrations() {
    let database_url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);
    let pg_conn = PgConnection::establish(&amp;database_url)
        .expect(&amp;format!(&quot;Error connecting to {}&quot;, database_url));
    match run_pending_migrations(&amp;pg_conn) {
        Ok(_) =&gt; debug!(&quot;auth database created&quot;),
        Err(_) =&gt; error!(&quot;auth database creation failed&quot;),
    };
}
// ...
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Cuidado pois esta configuração do docker-compose pode consumir muita memória. Pode ser interessante executar um <code>docker system prune --volumes</code> caso seu docker falhe. </li>
</ul>
<h2 id="criando-o-endpoint-de-cadastro-de-usuários"><a class="header" href="#criando-o-endpoint-de-cadastro-de-usuários">Criando o endpoint de cadastro de usuários</a></h2>
<p>Nosso próximo passo é modelar o domínio de autenticação em <code>todo_api</code>, chamaremos nossa struct de <code>User</code> e incluiremos no módulo <code>src/todo_api/model/auth.rs</code>. A primeira coisa que devemos fazer é declarar <code>mod schema</code> em <code>main.rs</code> e <code>lib.rs</code>, e por motivos de agilidade utilizar <code>#[macro_use] extern crate diesel_migrations;</code> e <code>#[macro_use] extern crate diesel;</code> para disponibilizar as macros utilizads em <code>schema.rs</code>. Depois disso, podemos criar nossa struct <code>User</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::schema::*;

#[derive(Debug, Serialize, Deserialize, Queryable, Insertable)]
#[table_name = &quot;auth_user&quot;]
pub struct User {
    email: String,
    id: uuid::Uuid,
    password: String,
    expires_at: chrono::NaiveDateTime,
}
<span class="boring">}
</span></code></pre></pre>
<p>Utilizamos a linha <code>use crate::schema::*;</code> para disponibilizar a tabela <code>auth_user</code> neste contexto para que a &quot;anotação&quot; <code>table_name</code> funcione. Além disso, aplicamos as macros <code>Queryable, Insertable</code> para que possamos utilizar nossa struct com o postgres. Agora sabemos que vamos receber 2 argumentos para criar um user, que serão <code>email</code> e <code>password</code>, com isso podemos presupor que vamos precisar implementar uma função que gere um tipo <code>User</code> destes dois argumentos, algo como <code>fn from(email: String, password: String) -&gt; User</code>. Assim, podemos implementar um teste para esta funcão. Para este teste vamos ter que adicionar a crate <code>regex = &quot;1.3.4&quot;</code> ao nosso <code>[dev-dependencies]</code> do Cargo.toml:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;
    use regex::Regex;

    #[test]
    fn user_is_correctly_created() {
        let user = User::from(String::from(&quot;email&quot;), String::from(&quot;password&quot;));
        let rx = Regex::new(&quot;[0-9]{4}-[0-1]{1}[0-9]{1}-[0-3]{1}[0-9]{1} [0-2]{1}[0-9]{1}:[0-6]{1}[0-9]{1}:[0-6]{1}[0-9]{1}&quot;).unwrap();

        assert_eq!(user.email, String::from(&quot;email&quot;));
        assert_eq!(user.password, String::from(&quot;password&quot;));
        assert!(uuid::Uuid::parse_str(&amp;user.id.to_string()).is_ok());
        assert!(rx.is_match(&amp;format!(&quot;{}&quot;, user.expires_at.format(&quot;%Y-%m-%d %H:%M:%S&quot;))));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Neste teste estamos testando se <code>email</code> e <code>password</code> são exatamente como enviamos, se o <code>Uuid</code> é gerado como <code>Uuid</code> e se o formato da data está de acordo coma  regex <code>&quot;[0-9]{4}-[0-1]{1}[0-9]{1}-[0-3]{1}[0-9]{1} [0-2]{1}[0-9]{1}:[0-6]{1}[0-9]{1}:[0-6]{1}[0-9]{1}&quot;</code>. Agora podemos implementar a funcão <code>from</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        use chrono::{DateTime, Duration, Utc};

        let utc: DateTime&lt;Utc&gt; = Utc::now() + Duration::days(1);

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que está funcão começa com <code>use chrono::</code>, isso se deve ao fato de estas structs ainda não serem necessárias em outras partes do código. Depois disso vemos a linha <code>let utc: DateTime&lt;Utc&gt; = Utc::now() + Duration::days(1);</code>, que é depois inserida em <code>expires_at</code>, ela referencia a ideia de que o token vai sobreviver apenas até este período, que é deste instante até mais um dia. Podemos ainda simplificar esta função para extrair o <code>DateTime&lt;Utc&gt;</code> com <code>one_day_from_now()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora <code>one_day_from_now</code> está definida no módulo <code>src/todo_api/db/helpers.rs</code> como:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Duration, Utc};
// ...
pub fn one_day_from_now() -&gt; DateTime&lt;Utc&gt; {
    Utc::now() + Duration::days(1)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="adaptando-o-request-para-um-modelo-de-banco-de-dados"><a class="header" href="#adaptando-o-request-para-um-modelo-de-banco-de-dados">Adaptando o request para um modelo de banco de dados.</a></h3>
<p>Agora precisamos de um modelo que represente o request HTTP de <code>signup</code>, porém nossos modelos de <code>Todo</code> estão todos em <code>src/todo_api_web/model/mod.rs</code>, assim devemos criar um módulo <code>model/todo.rs</code> e corrigir todas as chamadas:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/todo.rs
use crate::{
    // ...
    todo_api_web::model::{
        http::Clients,
        todo::{TodoCard, TodoIdResponse, TodoCardsResponse}
    }
};

// src/todo_api/db/todo.rs
use crate::todo_api_web::model::todo::TodoCard;

// src/todo_api/adapter/mod.rs
use crate::{
    todo_api::model::{StateDb, TaskDb, TodoCardDb},
    todo_api_web::model::todo::{State, Task, TodoCard},
};
// ...
#[cfg(test)]
mod test {
    use super::*;
    use crate::{
        todo_api::model::{StateDb, TaskDb, TodoCardDb},
        todo_api_web::model::todo::{State, Task, TodoCard},
    };
    // ...
}

// tests/helpers.rs
use todo_server::todo_api_web::model::todo::{State, Task, TodoCard};

// tests/todo_api_web/controller.rs
mod create_todo {
    use todo_server::todo_api_web::{
        model::todo::TodoIdResponse,
        routes::app_routes
    };
    // ...
}

mod read_all_todos {
    use todo_server::todo_api_web::{
        model::todo::{TodoCardsResponse},
        routes::app_routes
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Com tudo corrigido, podemos criar o módulo <code>src/todo_api_web/model/auth.rs</code> com a struct <code>SignUp</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct SignUp {
    pub email: String,
    pub password: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ambos campos são <code>pub</code>, isso é porque vamos precisar deles no <code>adapter</code>. Felizmente não podemos guardar o <code>password</code> como texto em nosso banco de dados, para isso vamos utilizar uma crate chamada bcrypt, adicionando <code>bcrypt = &quot;0.6&quot;</code> ao nosso <code>[dependencies]</code> do Cargo.toml (caso você se interesse por criptografia e queira outras opções, sugiro olhar também as crates <code>argonautica</code> e <code>libreauth</code>). Faremos está conversão no módulo <code>src/todo_api/adapter/auth.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::model::auth::User;
use crate::todo_api_web::model::auth::SignUp;
use bcrypt::{hash, DEFAULT_COST};

pub fn signup_to_hash_user(su: SignUp) -&gt; User {
    let hashed_pw = hash(su.password, DEFAULT_COST);
    User::from(su.email, hashed_pw.unwrap())
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora importamos duas coisas ao escopo, a função <code>hash</code> e <code>DEFAULT_COST</code>. <code>bcrypt</code> possui 3 principais funções e um padrão de custo, que é <code>DEFAULT_COST</code> e definido como <code>12u32</code>. As funções são:</p>
<ol>
<li><code>hash</code> recebe um password do tipo genérico <code>P</code>, no nosso caso <code>password</code> do tipo <code>String</code> e um custo, no caso <code>DEFAULT_COST</code>.</li>
<li><code>verify</code> verifica se o <code>password</code> enviado é igual a <code>hash</code>enviada.</li>
<li><code>bcrypt</code> é similar ao <code>hash</code>, porém o segundo argumento é um <code>salt</code> do tipo <code>&amp;[u8]</code></li>
</ol>
<p>Quanto ao custo, quanto maior o valor de custo, mais lento o hashing. Existe um benchmark com diferentes custos que apresenta uma relação de custo por velocidade:</p>
<ul>
<li>Custo = 4: test bench_cost_4       ... bench:   1,197,414 ns/iter (+/- 112,856)</li>
<li>Custo = 10: test bench_cost_10      ... bench:  73,629,975 ns/iter (+/- 4,439,106)</li>
<li>Custo = 12: test bench_cost_default ... bench: 319,749,671 ns/iter (+/- 29,216,326)</li>
<li>Custo = 14: test bench_cost_14      ... bench: 1,185,802,788 ns/iter (+/- 37,571,986)</li>
</ul>
<p>Creio que podemos escrever um teste simples para <code>signup_to_hash_user</code> como:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;
    use crate::todo_api_web::model::auth::SignUp;

    #[test]
    fn asser_signup_becomes_user() {
        let email = &quot;my@email.com&quot;;
        let pass = &quot;this Is a cr4zy p@ssw0rd&quot;;
        let signup = SignUp {
            email: String::from(email), 
            password: String::from(pass)
        };
        let user = signup_to_hash_user(signup);
        user.is_user_valid(email, pass)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este teste que criamos funciona da seguinte maneira, ele cria um <code>SignUp</code> com valores fixos e passa para a função adapter <code>signup_to_hash_user</code>, depois disso validamos que os inputs passados para <code>SignUp</code> formam um <code>User</code> válido com <code>.is_user_valid(email, pass)</code>. Agora a função <code>is_user_valid</code> é um pouco diferente do que já vimos, pois ela é uma função que compila apenas para testes com <code>#[cfg(test)]</code>, e possui <code>asserts</code> internos. Os asserts foram movidos para o arquivo de <code>src/todo_api/model/auth.rs</code> pois os campos de <code>User</code> são privados:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    // ...

    #[cfg(test)]
    pub fn is_user_valid(self, email: &amp;str, password: &amp;str) {
        use bcrypt::verify;

        assert_eq!(self.email, String::from(email));
        assert!(verify(password, &amp;self.password).unwrap());
        assert!(self.id.to_string().len() == 36);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com está função de teste podemos testar os valores internos de 1 User, comparando se o <code>email</code> interno é igual ao <code>email</code> recebido, se a string de <code>password</code> é um caso possível para <code>user.password</code> e se o <code>id</code> tem o tamanho de um <code>Uuid</code> do tipo <code>v4</code>. </p>
<h3 id="comunicando-signup-com-o-banco"><a class="header" href="#comunicando-signup-com-o-banco">Comunicando <code>SignUp</code> com o banco</a></h3>
<p>Agora temos <code>SignUp</code> e podemos converter em <code>User</code> com a função adapter <code>signup_to_hash_user</code>, falta inserir <code>User</code> no banco de dados para podermos criar nosso endpoint de <code>signup</code>. O primeiro passo para isso é criarmos a função <code>insert_new_user</code> em <code>src/todo_api/db/auth.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

pub fn insert_new_user(user: User, conn: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let new_user = diesel::insert_into(auth_user)
        .values(&amp;user)
        .execute(conn);

    match new_user {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::UserNotCreated)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos explicar o que se passa neste módulo. Precisamos de <code>PgConenction</code> para disponibilizar uma conexnao a nosso <code>execute</code>, que é o executor da nossa query. <code>prelude::*</code> serve para disponivilizar funções como <code>execute</code>. Além disso, criamos um módulo para conter todos nossos erros de banco de dados em <code>src/todo_api/db/error.rs</code>, que possui o enum <code>DbError</code> que veremos a seguir. Depois disso, temos <code>use crate::schema::auth_user::dsl::*;</code>, que disponibiliza a table <code>auth_user</code> para utilizar em <code>insert_into(auth_user)</code>. Temos, também, <code>diesel::insert_into(auth_user).values(&amp;user).execute(conn)</code> que insere na tabale <code>auth_user</code> com <code>insert_into</code>, define seus valores de inserção com <code>values</code>, recebendo a struct <code>User</code>, e executa a query com <code>execute</code>, ou com <code>get_result</code> caso você queria algum dos valores existente no banco após a inserção. Por último aplicamos um <code>match</code> ao tipo <code>Result</code> de <code>new_user</code>, caso o tipo seja <code>Ok</code> retornamos um sucesso, caso o tipo seja <code>Err</code>, retornamos o erro <code>DbError::UserNotCreated</code>. Agora vamos para a implementação da trait <code>Error</code> em <code>DbError</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
pub enum DbError {
    UserNotCreated
}

impl std::fmt::Display for DbError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            DbError::UserNotCreated =&gt; write!(f, &quot;User could not be created&quot;)
        }        
    }
}

impl Error for DbError {
    fn description(&amp;self) -&gt; &amp;str {
        match self {
            DbError::UserNotCreated =&gt; &quot;User could not be created, check for possible conflits&quot;
        } 
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; {
        Some(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Por enquanto temos somente um item em <code>DbError</code>, <code>UserNotCreated</code>. E agora precisamos implementar a trait <code>std::error::Error</code> para que nosso enum possa ser utilizado como um tipo erro em nosso projeto. A trait <code>Error</code> exige duas funções <code>description</code> e <code>cause</code>. <code>cause</code> é importante caso nosso erro receba algum argumento, pois nos permite retornar coisas específica com <code>&amp;dyn</code>, já description é o texto que veremos quando, por exemplo, logarmos o erro. Além disso, notamos que a trait <code>Error</code> exige a implementação de <code>std::fmt::Display</code>, que corresponde ao <code>to_string()</code>. Agora podemos criar uma versão de teste desta função da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/db/auth.rs
#[cfg(test)]
mod test {
    use diesel::debug_query;
    use diesel::pg::Pg;
    use crate::schema::auth_user::dsl::*;

    #[test]
    fn insert_user_matches_url() {
        use crate::todo_api::model::auth::User;

        let user = User::from(String::from(&quot;email@my.com&quot;), String::from(&quot;pswd&quot;));
        let query = diesel::insert_into(auth_user).values(&amp;user);
        let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
                -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot;, \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;]&quot;;
        assert_eq!(sql, debug_query::&lt;Pg, _&gt;(&amp;query).to_string());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Eu acredito que testes que comparam strings caractere a caractere é uma péssima ideia, mas a comunidade Diesel parece gostar, quando formos testar a nível de integração usaremos outra estratégia. Notamos a presença de <code>debug_query</code> e <code>Pg</code>, ambos são responsáveis por nos permitir debugar a query que que montamos com <code>diesel::insert_into(auth_user).values(&amp;user)</code> sem executá-la. Depois fazemos um assert de nossa query com <code>let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \ -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot; \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;]&quot;;</code> que é uma string com o valor que esperamos para o sql. Note que estamos acessando os campos <code>id</code> e <code>expires_at</code> neste teste, para fazermos isso mudamos a implementação de <code>User</code> um pouco:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
#[derive(Debug, Serialize, Deserialize, Queryable, Insertable)]
#[table_name = &quot;auth_user&quot;]
pub struct User {
    #[cfg(test)] pub email: String,
    #[cfg(not(test))] email: String,
    #[cfg(test)] pub id: uuid::Uuid,
    #[cfg(not(test))] id: uuid::Uuid,
    #[cfg(test)] pub password: String,
    #[cfg(not(test))] password: String,
    #[cfg(test)] pub expires_at: chrono::NaiveDateTime,
    #[cfg(not(test))] expires_at: chrono::NaiveDateTime,
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Fizemos com que os campos sejam públicos para teste e privado para todos os outros ambientes. Agora implementaremos o endpoint em si.</p>
<blockquote>
<p>Formatando <code>expires_at</code> e a crate Chrono</p>
<p>Muitas vezes é complicado acertar diretamente qual o formato que você quer que sua string contendo a data tenha, por isso, aqui está um bom referencial para o tipo <code>UTC</code> do Chrono:</p>
<ul>
<li><code>assert_eq!(dt.format(&quot;%Y-%m-%d %H:%M:%S&quot;).to_string(), &quot;2014-11-28 12:00:09&quot;);</code></li>
<li><code>assert_eq!(dt.format(&quot;%a %b %e %T %Y&quot;).to_string(), &quot;Fri Nov 28 12:00:09 2014&quot;);</code></li>
<li><code>assert_eq!(dt.format(&quot;%a %b %e %T %Y&quot;).to_string(), dt.format(&quot;%c&quot;).to_string());</code></li>
<li><code>assert_eq!(dt.to_string(), &quot;2014-11-28 12:00:09 UTC&quot;);</code></li>
<li><code>assert_eq!(dt.to_rfc2822(), &quot;Fri, 28 Nov 2014 12:00:09 +0000&quot;);</code></li>
<li><code>assert_eq!(dt.to_rfc3339(), &quot;2014-11-28T12:00:09+00:00&quot;);</code></li>
<li><code>assert_eq!(format!(&quot;{:?}&quot;, dt), &quot;2014-11-28T12:00:09Z&quot;);</code></li>
</ul>
</blockquote>
<h3 id="definindo-o-endpoint"><a class="header" href="#definindo-o-endpoint">Definindo o endpoint</a></h3>
<p>Nosso primeiro passo é definir um teste para este endpoint e a partir deste teste podemos implementar a solução:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod  auth {
    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use actix_service::Service;
    use todo_server::todo_api_web::{
        routes::app_routes
    };
    use dotenv::dotenv;
    use crate::helpers::{read_json};
    use todo_server::todo_api_web::model::http::Clients;


    #[actix_rt::test]
    async fn signup_returns_created_status() {
        dotenv().ok();
        let mut app = test::init_service(
            App::new()
                .data(Clients::new())
                .configure(app_routes)
        ).await;
    
        let signup_req = test::TestRequest::post()
            .uri(&quot;/auth/signup&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;signup.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = app.call(signup_req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::CREATED);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso teste define <code>signup_req</code> como o request que vamos enviar para <code>app.call(signup_req)</code>, mas este request possui uma nova <code>URI</code> <code>&quot;/auth/signup&quot;</code> e um novo arquivo Json com o conteúdo de post <code>&quot;signup.json&quot;</code>. Precisamos então definir este arquivo em <code>dev-resources</code> e implementar a rota. Note que o <code>assert</code> neste caso é somente para verificar se o usuário foi criado. O arquivo <code>signup.json</code> possui o seguinte formato:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;,
    &quot;password&quot;: &quot;My cr4azy p@ssw0rd&quot;
}
</code></pre>
<blockquote>
<p>Reconfigurando os testes</p>
<p>Ao executarmos os testes agora termos um retorno de <code>InternalServerError</code>, isso se deve ao fato de que <code>DbExecutor</code> não consegue encontrar a <code>DATABASE_URL</code> que está associada ao banco. Isso se deve pelo fato de estarmos utilizando uma url diferente para o docker compose e outra para testes locais. Além disso, Postgres é mais complicado que DynamoDB no sentido de que o cliente realmente tenta estabelecer uma conexão para iniciar e para isso precisamos de uma base de dados falsa executando. Além disso, essa base deve estar migrada para as queries ocorrerem sem problemas. Assim, nosso <code>make test</code> fica mais complicado:</p>
<pre><code class="language-Makefile">db:
	docker run -i --rm --name auth-db -p 5432:5432 -e POSTGRES_USER=auth -e POSTGRES_PASSWORD=secret -d postgres

test: db
	diesel setup
	diesel migration run
	cargo test --features &quot;dbtest&quot;
	diesel migration redo
 
clear-db:
  docker ps -a | awk '{ print $1,$2 }' | grep postgres | awk '{print $1 }' | xargs -I {} docker stop {}
</code></pre>
<p>Note que a partir da agora para rodar os testes precisamos de um container postgres configurado (<code>setup</code> e <code>migration run</code>) para podermos executar nossos testes sem quebrar o <code>DbExecutor</code>. Pode ser necessário adicionar um <code>sleep 3</code> depois de <code>test: db</code> para dar tempo do container executar. A última linha iniciada em <code>docker ps</code> serve para remover o container que executamos. Além disso, <code>DbExecutor</code> depende de <code>dotenv</code>, assim, devemos incluir <code>dotenv().ok()</code> antes de executar os testes e incorporar o <code>dotenv</code> no escopo com <code>use dotenv::dotenv;</code>. </p>
</blockquote>
<p>Agora que configuramos o teste, precisamos fazer a configuração de rotas, <code>app_routes</code> passa a ser:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user}
};
use actix_web::{web, HttpResponse};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                // ...
            )
            .service(
                web::scope(&quot;auth/&quot;)
                    .route(&quot;signup&quot;, web::post().to(signup_user))
            )
            .route(&quot;ping&quot;, web::get().to(pong))
            .route(&quot;~/ready&quot;, web::get().to(readiness))
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Ainda precisamos implementar o controller <code>signup_user</code> no módulo de controllers <code>auth</code>, porém ao contrário do método que vinhamos utilizando para inserir <code>User</code> no nosso banco de dados, que é o default do Diesel, vamos tirar proveito do sistema de actors do Actix e implementar um handler para permitir a comunição entre nosso serviço e o <code>Diesel</code> por mensagens. Assim, devemos mudar nossa struct <code>SignUp</code> para que ela implemente as traits <code>Handler</code> e <code>Message</code>, que vão nos permitir enviar mensagens para o <code>DbExecutor</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::prelude::*;
use crate::todo_api::{
    db::{
        error::DbError,
        helpers::DbExecutor,
    },
    adapter
};
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct SignUp {
    pub email: String,
    pub password: String,
}

impl Message for SignUp {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;SignUp&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: SignUp, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::schema::auth_user::dsl::*;
        use crate::diesel::RunQueryDsl;

        let user = adapter::auth::signup_to_hash_user(msg);
        let new_user = diesel::insert_into(auth_user)
            .values(&amp;user)
            .execute(&amp;self.0.get().expect(&quot;Failed to open connection&quot;));

        match new_user {
            Ok(_) =&gt; Ok(()),
            Err(_) =&gt; Err(DbError::UserNotCreated)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para a trait <code>Message</code> devemos implementar o tipo de retorna da comunicação, como no nosso caso não vamos retornar nada deixamos o <code>()</code> e caso ocorra um erro, retornamos o que já implementamos, <code>DbError</code>. Depois disso implementamos o <code>Handler</code> para <code>DbExecutor</code> com o tipo de mensagem <code>SignUp</code>, que possui a função <code>handle</code>. O primeiro argumento de <code>handle</code> é o prório <code>DbExecutor</code>, que está implementado como <code>struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;)</code>, o segundo argumento é a mensagem, no nosso caso <code>SignUp</code>, e o terceiro argumento é o contexto do actix. Note que a função <code>handle</code> é praticamente igual a <code>insert_new_user</code>, mas em vez de passarmos um <code>PgConnection</code> passamos um <code>PooledConnection</code>, uma referência ao <code>Pool</code> de cone≈ões que criamos em <code>DbExecutor</code>, e para isso precisamos adicionar <code>use crate::diesel::RunQueryDsl;</code> que altera nosso <code>execute</code> para poder realizar erstá operação. Com isto encaminhado, agora podemos criar o controller. Este controller será um pouco diferente do que usamos usualmente, pois o adapter se encontra dentro do <code>Handler</code> e o controller simplesmente ficará responsável por fazer a comunicação via mensagem entre os actors:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use log::{error};
use crate::{
    todo_api_web::model::{
        http::Clients,
        auth::SignUp,
    }
};

pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    let signup = info.into_inner();

    let resp = state.postgres
        .send(signup)
        .await;

    match resp {
        Ok(_) =&gt; HttpResponse::Created(),
        Err(e) =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::InternalServerError()
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora estamos fazendo a conversão do tipo <code>web::Json&lt;SignUp&gt;</code> na nossa struct <code>SignUp</code> com <code>let signup = info.into_inner();</code> e enviando seu conteúdo para o <code>DbExecutor</code> através de:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp = state.postgres
    .send(signup)
    .await;
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos os testes agora veremos que eles falham, pois nosso teste tenta invocar o banco de dados de verdade, para isso, podemos utilizar a função que criamos anteriormente <code>insert_new_user</code> dentro do <code>Handler</code> para abstrair a lógica com o banco de dados e nos permitir utilizar features. Assim, a primeira mudança passa a ser o <code>handle</code> que utiliza o <code>insert_new_user</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler&lt;SignUp&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: SignUp, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::insert_new_user;

        let user = adapter::auth::signup_to_hash_user(msg);

        insert_new_user(user, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar uma solução de <code>insert_new_user</code>que utilize a feature <code>dynamo</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn insert_new_user(user: User, conn: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let new_user = diesel::insert_into(auth_user)
        .values(&amp;user)
        .execute(conn);

    match new_user {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::UserNotCreated)
    }
}

#[cfg(feature = &quot;dynamo&quot;)]
pub fn insert_new_user(_user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;

    let user = User::from(String::from(&quot;my@email.com&quot;), String::from(&quot;My cr4azy p@ssw0rd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
            -- binds: [\&quot;my@email.com\&quot;, &quot;;
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(sql));
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(&quot;My cr4azy p@ssw0rd&quot;));

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Com o <code>#[cfg(feature = &quot;dynamo&quot;)]</code> fazemos uma query para <code>diesel_query</code> com os valores de <code>user</code> (não usamos <code>_user</code> pois seus campos são privados), como fizemos no módulo de testes e depois fazemos um assert que a query retornada de <code>debug_query::&lt;Pg, _&gt;(&amp;query).to_string()</code> contém a substring <code>sql</code> e que contém a substring de password <code>&quot;My cr4azy p@ssw0rd&quot;</code>. Depois disso retornamos <code>Ok(())</code> para conformar com o esperado do <code>Result</code>.</p>
<h2 id="validando-email-e-password"><a class="header" href="#validando-email-e-password">Validando email e password</a></h2>
<p>Agora vamos fazer algo pequeno, pois nosso objetivo é garantir que o email é no formato válido <code>\w{1,}@\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?</code> (regex significando qualquer conjunto de caracteres com mais de 1 elemento entre letras, números e <code>_</code>, seguido de <code>@</code>, repete o primeiro, seguido de ponto e 2 ou 3 caracteres de letras, seguido pela possível existência de ponto e 2 ou 3 caracteres de letras). Além disso, vamos garantir que o password contém umais de 32 caracteres, com letras maiúsculas e minúsculas, números e alguns caracterés especiais. </p>
<p>No controller <code>signup_user</code> adicionaremos uma validação da string de email com a crate Regex. Para isso definiremos nossa regex com <code>Regex::new</code> e depois compararemos com <code>is_match</code>. Caso a validação falhe, retornaremos <code>HttpResponse::BadRequest()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let signup = info.into_inner();
    if !email_regex.is_match(&amp;signup.email) {
        return HttpResponse::BadRequest();
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora usaremos uma regex que garante que a senha possua pelo menos uma letra maiúscula, pelo menos uma letra minúscula, pelo menos um número e pelo menos algum dos caracteres <code>@!=_#&amp;~[]{}?/</code> com uma tamanho entre 32 e 64 caracteres. Essa regex será <code>[[a-z]+[A-Z]+[0-9]+(\s@!=_#&amp;~\[\]\{\}\?\/)]{32,64}</code>. Cuidado que nosso teste deve falhar a partir de agora, para isso, modifiquei <code>signup.json</code> para:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;,
    &quot;password&quot;: &quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;
}
</code></pre>
<p>E atualizei <code>db/auth</code> para validar este novo password:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dynamo&quot;)]
pub fn insert_new_user(user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;

    let user = User::from(String::from(&quot;my@email.com&quot;), String::from(&quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
            -- binds: [\&quot;my@email.com\&quot;, &quot;;
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(sql));
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(&quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;));

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, podemos implementar a mudança no controller com:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?\\/)]{32,64}&quot;).unwrap();
    
    let signup = info.into_inner();
    if !(email_regex.is_match(&amp;signup.email) &amp;&amp; pswd_regex.is_match(&amp;signup.password)) {
        return HttpResponse::BadRequest();
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Um bom exercício aqui seria criar alguns testes para o controller validar as novas regras do <code>email</code> e do <code>password</code>, lembrando que o teste de cenário válido já acontece a nível de integração. Alguns possíveis <code>emails</code> de teste são <code>&quot;my_email.com.br&quot;</code> ou <code>&quot;my@email.com.br.us&quot;</code>, além disso alguns casos interessantes de teste para <code>passwords</code> são <code>&quot;My Cr4zy p@ssw0rd&quot;</code>, <code>&quot;my cr4zy p@ssw0rd my cr4zy p@ssw0rd&quot;</code> e <code>&quot;My Crazy password My Crazy password&quot;</code>.</p>
<h2 id="implementando-login"><a class="header" href="#implementando-login">Implementando login</a></h2>
<p>O objetivo de nosso endpoint de login será retornar um token <code>jwt</code> com informações garantindo a validade do sistema. Assim, nosso endpoint receberá um <code>email</code> e um <code>password</code>, validará se o password é válido e retornará um token <code>jwt</code>, que passará a ser validado nos outros endpoints. </p>
<p>Podemos agora mudar a feature <code>dynamo</code> que atua sobre o Postgres e o DynamoDB para <code>db-test</code>. Para isso, devemos adicionar a feature a nosso Cargo.toml:</p>
<pre><code class="language-toml">[features]
db-test = []
</code></pre>
<p>E a nosso Makefile:</p>
<pre><code class="language-sh">test: db
	sleep 2
	diesel setup
	diesel migration run
	cargo test --features &quot;dbtest&quot;
	diesel migration redo

run-local:
	cargo run --features &quot;db-test&quot;
# ...
</code></pre>
<p>Por último, devemos modificar o arquivo <code>src/todo_api/db/auth.rs</code> para utilizar a nova feature:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

#[cfg(not(feature = &quot;db-test&quot;))]
pub fn insert_new_user(user: User, conn: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    // ...
}

#[cfg(feature = &quot;db-test&quot;)]
pub fn insert_new_user(user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    // ...

    Ok(())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Repita isso para os outros cenários.</p>
<h3 id="criando-o-endpoint-de-login"><a class="header" href="#criando-o-endpoint-de-login">Criando o endpoint de login</a></h3>
<p>A partir deste momento vou mudar a forma como apresento os testes, pois creio que já temos uma boa ideia de como eles funcionam. Assim, vou apresentar o teste que escrevi para cada endpoint, mas não resolverei eles mais de forma a relacionar o código sendo escrito ao teste que queremos resolver. Isso se deve ao fato de que eles são praticamente iguais. Assim, o teste deste endpoint seria apenas validar que o status é <code>200</code>, mas vamos mudar um pouco e esperar que a resposta venha com uma chave Json <code>token</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod  auth {
    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use todo_server::todo_api_web::{
        routes::app_routes
    };
    use crate::helpers::{read_json};
    use dotenv::dotenv;

    // ...
    #[actix_rt::test]
    async fn login_returns_token() {
        let mut app = test::init_service(
            App::new()
                .data(Clients::new())
                .configure(app_routes)
        ).await;

        let login_req = test::TestRequest::post()
            .uri(&quot;/auth/login&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;signup.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp_body = test::read_response(&amp;mut app, login_req).await;

        let jwt: String = String::from_utf8(resp_body.to_vec()).unwrap();
        
        assert!(jwt.contains(&quot;token&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso próximo passo será definir o endpoint <code>/auth/login</code> que receberá um <code>POST</code> com um Json representado pela struct <code>Login</code>, que contém os mesmos campos de <code>SignUp</code>. Faremos uma nova struct para podermos tirar mais proveito do sistema de actors do Actix.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user, login}
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            // ...
            .service(
                web::scope(&quot;auth/&quot;)
                    .route(&quot;signup&quot;, web::post().to(signup_user))
                    .route(&quot;login&quot;, web::post().to(login))
            )
            // ...
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    );
}

<span class="boring">}
</span></code></pre></pre>
<p>Aqui adicionamo uma rota <code>login</code> que envia o request para o controller <code>login</code>. Agora vamos ao controller <code>login</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?)]{32,64}&quot;).unwrap();
    
    let login_user = info.clone();
    if !(email_regex.is_match(&amp;login_user.email) &amp;&amp; pswd_regex.is_match(&amp;login_user.password)) {
        return HttpResponse::BadRequest().finish();
    }

    let resp = state.postgres
        .send(login_user)
        .await;

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(r_users) =&gt; {
            match r_users {
                Err(e) =&gt; {
                    error!(&quot;{:?}&quot;,e);
                    HttpResponse::NoContent().finish()
                },
                Ok(users) =&gt; {
                    let user = users.first().unwrap();
                    match user.verify(info.clone().password) {
                        Ok(true) =&gt; generate_jwt(user, state).await,
                        Ok(false) =&gt; HttpResponse::NoContent().finish(),
                        Err(_) =&gt; HttpResponse::NoContent().finish()

                    }
                }
            }
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que podemos notar no controller de <code>login</code> é o <code>is_match</code> das regex, lembrando que usar regex pode sempre ser algo perigoso e devemos ter muito cuidado. Isso é algo que claramente podemos extrair. Em seguida repetimos o processo de outros outros controllers e enviamos uma mensagem com <code>Login</code> em <code>state.postgres.send(login_user).await</code>, nesta chamada recebemos um vetor de <code>User</code> que passam nosso filtro, porém como estamos filtrando pela chave primária <code>email</code> não pode haver conflitos. creio que a estração das verificações de email e de senha por regex fica com a seguinte cara:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    let signup = info.into_inner();
    if !is_email_pswd_valids(&amp;signup.email, &amp;signup.password) {
        return HttpResponse::BadRequest();
    }

    // ...
}

pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    let login_user = info.clone();
    if !is_email_pswd_valids(&amp;login_user.email, &amp;login_user.password) {
        return HttpResponse::BadRequest().finish();
    }

    // ...
}

pub fn is_email_pswd_valids(email: &amp;str, pswd: &amp;str) -&gt; bool {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?)]{32,64}&quot;).unwrap();
    
    email_regex.is_match(email) &amp;&amp; pswd_regex.is_match(pswd)
}
<span class="boring">}
</span></code></pre></pre>
<p>A vantagem deste formato, é que executar os testes fica ainda mais fácil, pois passam a ser validações unitárias, e o motivo pelo qual deixei anteriormente como exercícios. Assim, os testes podem ser como a seguir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod valid_email_pswd {
    use super::is_email_pswd_valids;

    #[test]
    fn valid_email_and_pswd() {
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
    }

    #[test]
    fn invalid_emails() {
        assert!(!is_email_pswd_valids(&quot;my_email.com&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
        assert!(!is_email_pswd_valids(&quot;my@email.com.br.us&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
    }

    #[test]
    fn invalid_passwords() {
        assert!(!is_email_pswd_valids(&quot;my@email.com.br&quot;, &quot;My cr4zy P@ssw0rd&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;my cr4zy p@ssw0rd my cr4zy p@ssw0rd&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My crazy P@ssword My crazy P@ssword&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My cr4zy Passw0rd My cr4zy Passw0rd&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Também podemos observar que no controller <code>login</code> há uma série de <code>HttpResponse::NoContent().finish()</code> para qualquer caso de erro. Duas coisas para observarmos aqui, a primeira é a presença de <code>finish</code> que se deve ao método <code>generate_jwt</code> que retorna um <code>HttpResponse</code>, a segunda é que presumo que quando alguém tenta logar em um serviço e ocorro qualquer problema, o serviço deve responder um <code>2XX</code> sem nenhuma informação, por isso do <code>NoContent</code>.</p>
<p>Agora podemos seguir para o caso que todas as extrações de <code>resp</code> via pattern matching e chegar em <code>user.verify(info.clone().password)</code>. O objetivo de função é validar que o <code>password</code> de <code>info: web:Json&lt;Login&gt;</code> é um password possível para a hash de <code>user.password</code>. Como está função é somente uma camada em volta da função original, já testada, não é imprescindível implementar testes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
impl User {
    use bcrypt::{verify, BcryptResult};
    // ...

    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        verify(pswd,&amp;self.password)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que a resposta de <code>verify</code> é do tipo <code>BcryptResult</code>, ou seja, temos 3 cenários:</p>
<ol>
<li><code>Ok(true)</code> -&gt; Caso na qual o <code>password</code> enviado é uma hash válida. </li>
<li><code>Ok(false)</code> -&gt; Caso na qual o <code>password</code> não é válido.</li>
<li><code>Err</code> -&gt; Ocorreu algum erro de validação.</li>
</ol>
<p>O único dos casos que é importante para nós é o caso <code>1</code>, por isso é o caso que aplicamos a função <code>generate_jwt</code>, cujo objetivo será gerar um token <code>jwt</code>. Além disso, está função não funcionará para o teste que criamos pois não estamos utilizando uma hash real, assim uma solução para isso é simplesmente responder um tipo <code>BcryptResult&lt;bool&gt;</code> com conteúdo <code>true</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    // ...

    #[cfg(not(feature = &quot;dbtest&quot;))]
    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        verify(pswd,&amp;self.password)
    }

    #[cfg(feature = &quot;dbtest&quot;)]
    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        BcryptResult::Ok(true)
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Antes de continuar com <code>generate_jwt</code> precisamos explorar a implementacnao de <code>Login</code>, pois é o <code>Login</code> que é afetado pela função <code>state.postgres.send(login_user).await</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Login {
    pub email: String,
    pub password: String,
}

impl Message for Login {
    type Result = Result&lt;Vec&lt;User&gt;, DbError&gt;;
}

impl Handler&lt;Login&gt; for DbExecutor {
    type Result = Result&lt;Vec&lt;User&gt;, DbError&gt;;

    fn handle(&amp;mut self, msg: Login, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Login recebe um <code>email</code> e um <code>password</code> para depois procurar no banco de dados com <code>scan_user</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scan_user(user_email: String, conn: &amp;PgConnection) -&gt; Result&lt;Vec&lt;User&gt;,DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let items = auth_user
            .filter(email.eq(&amp;user_email))
            .load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users),
        Err(_) =&gt; Err(DbError::CannotFindUser)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>É bastante simples o que acontece aqui, filtramos na tabela <code>auth_user</code> por um <code>user_email</code> que seja igual ao que enviamos. Caso essa lista seja maior que 1, houve um problema no banco de dados, pois como <code>email</code> é uma chave primária não podem haver 2, ou mais, repetidos. Qualquer outro <code>Err</code> é um <code>DbError</code> de não encontrar o usuário ou problemas de conexão. Temos um <code>Ok</code> extra que valida se a lista é zero, e retorna o erro <code>CannotFindUser</code> como a cláusula <code>Err</code>. E o <code>Ok</code> restante é o caso que procuramos. Note que ainda temos um refactor a fazer aqui, este refactor é modificar o tipo de retorno <code>Result&lt;Vec&lt;User&gt;,DbError&gt;</code> para <code>Result&lt;User,DbError&gt;</code> utilizando um <code>.first().unwrap()</code>, já que temos certeza que esse <code>first</code> existe. Além disso, precisamos adaptar este código para o teste, já que a ação <code>user.filter(email.eq(&amp;user_email)).load::&lt;User&gt;(conn)</code> não deve existir. Fazemos essa adaptação retornando um <code>Ok</code> com um <code>User</code> contendo o email que enviamos. Na função <code>scan_user</code> com a feature <code>dbtest</code> ainda fazemos um assert na query que será gerada por <code>auth_user.filter(email.eq(&amp;user_email))</code> e validamos com o <code>debug_query</code>. Caso você prefira substituir o <code>password</code> por uma hash válida para a senha sendo enviada no teste, não seria mais necessário utilizar a <code>cfg feature</code> para <code>verify</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn scan_user(user_email: String, conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let items = auth_user
            .filter(email.eq(&amp;user_email))
            .load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users.first().unwrap().clone().to_owned()),
        Err(_) =&gt; Err(DbError::CannotFindUser)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn scan_user(user_email: String, _conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;
    let query = auth_user.filter(email.eq(&amp;user_email));
    let expected = &quot;SELECT \&quot;auth_user\&quot;.\&quot;email\&quot;, \&quot;auth_user\&quot;.\&quot;id\&quot;, \&quot;auth_user\&quot;.\&quot;password\&quot;, \&quot;auth_user\&quot;.\&quot;expires_at\&quot;, \&quot;auth_user\&quot;.\&quot;is_active\&quot; FROM \&quot;auth_user\&quot; WHERE \&quot;auth_user\&quot;.\&quot;email\&quot; = $1 -- binds: [\&quot;my@email.com\&quot;]&quot;.to_string();

    assert_eq!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string(), expected);
    Ok(User::from(user_email, &quot;this is a hash&quot;.to_string()))
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora nossa <code>resp</code> de <code>state.postgres.send(login_user).await</code> pode ser resolvida em uma <code>match</code>, na qual a cláusula de <code>Err</code> vai simplesmente retornar um <code>NoContent</code> a cláusula <code>Ok</code> vai aplicar um novo <code>match</code> em <code>verify</code>. De acordo com a resposta de verify, criamos o token. O caso <code>Err</code> é simplesmente um <code>NoContent</code> porque houve um problema na criação da hash, já o caso <code>Ok(false)</code> corresponde a senha incorreta. No caso <code>Ok(true)</code>, criamos o token em <code>generate_jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/auth.rs
pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    // ...

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(user) =&gt; {
            let usr = user.unwrap();
            match usr.verify(info.clone().password) {
                Ok(true) =&gt; generate_jwt(usr, state).await,
                Ok(false) =&gt; HttpResponse::NoContent().finish(),
                Err(_) =&gt; HttpResponse::NoContent().finish()
            }
        }
    }
}

// src/todo_api_web/model/auth.rs
impl Message for Login {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Login&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Login, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora falta implementarmos o <code>generate_jwt</code> para completarmos esse fluxo.</p>
<h3 id="gerando-um-token-jwt"><a class="header" href="#gerando-um-token-jwt">Gerando um token <code>JWT</code></a></h3>
<p>O objetivo de criarmos um token <code>JWT</code> é permitir que o usuário faça requisições para páginas que exigem autentição, e até autorização (é possível passar tokens de autorização), com um token de autenticação no header do request. Essa autenticação vai conter algumas informações cruciais que vão nos permitir validar este token no nosso banco de dados. As informação que vamos adicionar ao token neste momento são as contidas na struct <code>User</code> exceto <code>password</code>. </p>
<ul>
<li>É importante lembrar que o tópico de segurança é bastante complicado e não é o foco do livro, assim, a solução que vamos apresentar é útil, mas longe de ser uma solução aplicável em produção. </li>
</ul>
<p>Infelizmente, a função <code>generate_jwt</code> é cheio de efeitos colaterais e muito dificil de testar unitariamente, assim, vamos pular os testes dele por hora. Vamos manter essa função em um módulo <code>core</code>, a ideia desse módulo é conter a lógica associada à <code>src/todo_api</code>, mesmo que a função <code>generate_jwt</code> possua muitos efeitos colaterais e estará localizada em <code>src/todo_api/core/mod.rs</code>. O primeiro Efeito colaterial dele é criar uma nova data de expiração para daqui um dia com <code>crate::todo_api::db::helpers::one_day_from_now().naive_utc()</code>. Essa data será usada para criar uma struct que fará a atualização da data em <code>User</code>. Essa struct é chamada <code>UpdateDate</code> e contém dois campos <code>email</code> e <code>expires_at</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>JWT</strong></p>
<p>JWT, ou Json Web Token, é um padrão aberto baseado na <strong>RFC 7519</strong> que define uma forma compacta e auto contida de transmitir de forma segura entre duas partes em um formato Json. Este token pode ser assinado com uma chave secreta via <code>HMAC</code> ou chaves publicas/privadas via <code> RSA</code> ou <code>ECDSA.</code> Estes tokens podem ser encriptados ou não e os dois principais casos de uso são autorização e troca de informações. A estrutura de um JWT é <code>header</code>, <code>payload</code> e <code>assinatura</code>, assim o formato acaba sendo algo como <code>hhhhh.pppppp.aaaaa</code>. Usualmente o <code>header</code> possui duas partes o tipo, usualmente <code>&quot;typ&quot;: &quot;jwt&quot;</code> e o algoritmo que pode ser <code>HMAC SHA256 ou RSA</code>, algo como <code>&quot;alg&quot;: &quot;HS256&quot;</code>. <code>payload</code> é onde as informações que queremos trocar estão armazenadas. E assinatura, ou <code>signature</code>, é uma informação de como entender esses dados. Com o algoritmo <code>HMAC SHA256</code> a criação de um JWT o seguinte formato <code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code>, note que <code>payload</code> e <code>header</code> estão em um formato <code>base64</code>.</p>
</blockquote>
<p>Agora precisamos implementar a struct <code>UpdateDate</code>. Essa struct está estritamente associada a ao módulo <code>core</code> atuando somente como um complemento a lógica, por isso adicionel ela em <code>src/todo_api/core/model.rs</code>, mas se você achar mais adequado é correto também deixar <code>generate_jwt</code> em <code>src/todo_api/controller/core.rs</code> e <code>UpdateDate</code> em <code>src/todo_api/model/core.rs</code>. Agora, nossa struct também precisa poder se comunicar por mensagem com nosso postgres e para isso vamos implementar as traits <code>Message</code> e <code>Handle</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::prelude::*;
use crate::todo_api::{
    db::{
        error::DbError,
        helpers::DbExecutor,
    },
};

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct UpdateDate {
    pub email: String,
    pub expires_at: chrono::NaiveDateTime,
}

impl Message for UpdateDate {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;UpdateDate&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: UpdateDate, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::update_user_jwt_date;

        update_user_jwt_date(msg, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que o tipo <code>Result</code> da nossa <code>Message</code> é apenas um <code>Reuslt</code> com um <code>Ok</code> vazio e um erro do tipo <code>DbError</code>, <code>Result&lt;(), DbError&gt;</code>. Neste caso precisamos somente saber se o update da data foi bem sucedido ou falho, com qual erro. Assim, a função <code>handle</code>simplesmente atualiza a <code>expires_at</code> no banco conforme a chave <code>email</code>. É importante também garantir que <code>expires_at</code> seja do tipo <code>chrono::NaiveDateTime</code> para não termos problemas com o tipo da tabela <code>auth_user</code>. Vamos agora olhar a função <code>update_user_jwt_date</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target).set(expires_at.eq(update_date.expires_at)).execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para <code>update_user_jwt_date</code> precisamos disponibilizar a <code>dsl</code> de <code>auth_user</code> para fazermos operações na tabela e fazemos isso com <code>use crate::schema::auth_user::dsl::*;</code>. A primeira linha de código é encontrar o <code>User</code> alvo através de um <code>filter</code> que procura a igualdade entre os campos <code>email</code> com <code>auth_user.filter(email.eq(update_date.email))</code> sendo definido em um <code>let target</code>. Depois disso fazemos um <code>update</code> nesse <code>target</code> com <code>diesel::update(target)</code> e com isso podemos fazer um <code>set</code> do campo <code>expires_at</code> com o valor de <code>expires_at</code> de <code>update_date</code> com <code>set(expires_at.eq(update_date.expires_at))</code>. O resultado disso será um tipo <code>Result&lt;(), DbError&gt;</code>, que podemos utilizar em um <code>match</code> para fazer pattern matching e retornar se o update foi bem sucedido. Para realizar o teste pulamos a parte do <code>target</code>e do <code>match</code>, retornando apenas um <code>Ok(())</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target)
        .set((expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active)))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn update_user_jwt_date(_update_date: UpdateDate, _conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>De volta a <code>generate_jwt</code> fazemos este update de forma a utilizar os recursos de <code>Actor</code> enviando uma mensagem para <code>UpdateDate</code> com <code>let resp = state.postgres.send(update_date);</code>. Note que esta função é <code>async</code> e não estamos esperando ela com o <code>await</code>, isso se deve ao fato de que as duas próximas tarefas não precisam que <code>resp</code> esteja concluída. Enquanto esperamos o momento oportuno para concretizar <code>resp</code> com <code>await</code> iniciamos a criação efeitva do token e sua preparação para o tipo de resposta <code>Jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
    };

    let resp = state.postgres
        .send(update_date.clone());

    let token_jwt = create_token(user, update_date);
    let jwt = crate::todo_api::core::model::Jwt::new(token_jwt);    

    match resp.await {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E o tipo <code>Jwt</code> localizado em <code>src/todo_api/core/model.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub struct Jwt{
    token: String
}

impl Jwt {
    pub fn new(jwt: String) -&gt; Self {
        Self {
            token: jwt
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Antes de concretizarmos <code>resp</code> com um <code>await</code> criamos o token com <code>create_token</code> e passamos este valor para a struct <code>Jwt</code> com <code>let jwt = crate::todo_api::core::model::Jwt::new(token_jwt);</code>. <code>create_token</code> é a função responsável por montar o token com os campos necessários.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_token(user: User, update_date: UpdateDate) -&gt; String {
    use serde_json::json;
    use jsonwebtokens::{Algorithm, AlgorithmID, encode};
    use chrono::Utc;

    let alg = Algorithm::new_hmac(AlgorithmID::HS256, &quot;secret&quot;).unwrap();
    let header = json!({ &quot;alg&quot;: alg.name(), &quot;typ&quot;: &quot;jwt&quot;, &quot;date&quot;:  Utc::now().to_string()});
    let payload = json!({ &quot;id&quot;: user.clone().get_id(), &quot;email&quot;: user.email, &quot;expires_at&quot;: update_date.expires_at });
    encode(&amp;header, &amp;payload, &amp;alg).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que fazemos em <code>create_token</code> é gerar o algoritmo com a struct <code>Algorithm</code>.  Como vamos utilizar um algoritmo <code>HMAC SHA256</code> chamamos a função <code>new_hmac</code> e passamos como argumento o id que tipo que vamos utilizar com <code>AlgorithmID::HS256</code> e o segredo que vai ser passado. Uma boa alternativa para não ter o segredo exposto assim é ler ele de uma variável de ambiente. Depois disso, definimos o <code>header</code> com o algoritmo, o tipo e a data de criação em <code>json!({ &quot;alg&quot;: alg.name(), &quot;typ&quot;: &quot;jwt&quot;, &quot;date&quot;:  Utc::now().to_string()});</code>, note o uso da macro <code>json!</code> vinda de <code>serde_json</code>. Da mesma forma que com header, criamos o <code>payload</code> com os campos que nos interessam, <code>id, email, expires_at</code>. Por último geramos o token passando todas estas informações como argumento para função <code>encode</code> em <code>encode(&amp;header, &amp;payload, &amp;alg).unwrap()</code>.</p>
<p>Para finalizar precisamos que <code>generate_jwt</code> responda um status com o conteúdo do token. Para isso fazemos um match em <code>resp</code> e retornamos <code>HttpResponse::InternalServerError().finish()</code> para o caso de <code>Err</code> e para o caso de <code>Ok</code> retornamos um <code>HttpResponse::Ok()</code> com um Json contendo a struct <code>Jst</code> serializada:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    // ...
    let resp = state.postgres.send(update_date.clone());
    let token_jwt = create_token(user, update_date);
    let jwt = crate::todo_api::model::core::Jwt::new(token_jwt);

    match resp.await {
        Ok(_) =&gt; {
            HttpResponse::Ok()
                .content_type(&quot;application/json&quot;)
                .json(jwt)
        }
        Err(e) =&gt; {
            error!(&quot;{:?}&quot;, e);
            HttpResponse::InternalServerError().finish()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Login pronto. Agora precisamos implementar o logout.</p>
<h2 id="implementando-o-logout"><a class="header" href="#implementando-o-logout">Implementando o logout</a></h2>
<p>Um login é útil, mas pode ser necessário apagarmos a sessão que temos com o serviço e para fazer isso é necessário realizar um <code>logout</code>, que atende pelo método <code>DELETE</code>. Nosso logout vai modificar nosso user de modo que tenhamos um campo booleano <code>is_active</code>. Este campo tem como responsabilidade dizer se o <code>user</code> enviado no token ainda está autenticado. Assim, vamos adicionar o campo <code>is_active</code> ao struct <code>User</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
// ...
#[derive(Debug, Serialize, Deserialize, Clone, Queryable, Insertable)]
#[table_name = &quot;auth_user&quot;]
pub struct User {
    pub email: String,
    pub id: uuid::Uuid,
    #[cfg(test)] pub password: String,
    #[cfg(not(test))] password: String,
    #[cfg(test)] pub expires_at: chrono::NaiveDateTime,
    #[cfg(not(test))] expires_at: chrono::NaiveDateTime,
    pub is_active: bool
}

impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
            is_active: false
        }
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Se observarmos o <code>rls</code> do editor vamos perceber o aviso de que <code>Insertable</code> está com problemas, este problema é que <code>is_active</code> não está mapeado. Para isso devemos criar uma migração com este campo, chamaremos ela de <code>valid_auth</code> e executaremos <code>diesel migration generate valid_auth</code> que criará uma nova pasta dentro de migrations, algo como <code>2020-02-22-011512_valid_auth</code>. Depois disso adicionaremos um <code>up.sql</code> e um <code>down.sql</code>:</p>
<pre><code class="language-sql">&lt;-- UP.sql --&gt;
ALTER TABLE auth_user
  ADD is_active BOOLEAN NOT NULL DEFAULT 'f';

&lt;-- DOWN.sql --&gt;
ALTER TABLE auth_user
  DROP is_active;
</code></pre>
<p>Esse script consiste em alterar a tabela <code>auth_user</code> para conter ou não o campo <code>is_active</code>. Com isso pronto executaremos <code>make db</code> e em seguida <code>diesel setup</code> para modificar o <code>schema.rs</code> que ficará assim:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table! {
    auth_user (email) {
        email -&gt; Varchar,
        id -&gt; Uuid,
        password -&gt; Varchar,
        expires_at -&gt; Timestamp,
        is_active -&gt; Bool,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Lembre de adicionar <code>embed_migrations!();</code> depois de <code>table!(...)</code>. Antes de continuarmos com <code>logout</code> precisamos que o <code>login</code> ative a o campo <code>is_active</code> e para isso a struct <code>UpdateDate</code> precisa receber um novo campo booleano <code>is_active</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/core/model.rs
// ...
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct UpdateDate {
    pub email: String,
    pub expires_at: chrono::NaiveDateTime,
    pub is_active: bool
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Se rodarmos os testes agora veremos que o teste <code>insert_user_matches_url</code> de <code>src/todo_api/db/auth</code> falha pois não espera o campo <code>is_active</code>:</p>
<pre><code>esperado: &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) -- binds: [\&quot;email@my.com\&quot;, 0f3d625b-c85c-490c-b979-f20cbbd6a71d, \&quot;pswd\&quot;, 2020-02-23T19:31:34.896595]&quot;`,
encontrado: &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;, \&quot;is_active\&quot;) VALUES ($1, $2, $3, $4, $5) -- binds: [\&quot;email@my.com\&quot;, 0f3d625b-c85c-490c-b979-f20cbbd6a71d, \&quot;pswd\&quot;, 2020-02-23T19:31:34.896595, false]&quot;`
</code></pre>
<p>Assim, devemos editar o teste para conter o campo <code>is_active</code> com valor default <code>false</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insert_user_matches_url() {
    use crate::todo_api::model::auth::User;

    let user = User::from(String::from(&quot;email@my.com&quot;), String::from(&quot;pswd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;, \&quot;is_active\&quot;) VALUES ($1, $2, $3, $4, $5) \
            -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot;, \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;, false]&quot;;
    assert_eq!(&amp;sql, &amp;debug_query::&lt;Pg, _&gt;(&amp;query).to_string());
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos modificar também <code>core/mod.rs</code> para setar o campo <code>is_active</code> como true na função <code>generate_jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
        is_active: true,
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim como a função de <code>db/auth</code> <code>update_user_jwt_date</code>, que agora precisa setar o campo <code>is_active</code> como <code>true</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target)
        .set((expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active)))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora <code>diesel::update(target)</code> precisa atualizar 2 campos, e para isso é precisa enviar como parâmetro uma tupla contendo os dois campos a serem atualizados <code>(expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active))</code>. Com isso, podemos agora continuar com o <code>logout</code>.</p>
<p>Para nosso <code>logout</code> precisamos começar criando o endpoint <code>/auth/logout</code> com o método delete:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user, login, logout}
};
use actix_web::{web, HttpResponse};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            // ...
            .service(
                web::scope(&quot;auth/&quot;)
                    .route(&quot;signup&quot;, web::post().to(signup_user))
                    .route(&quot;login&quot;, web::post().to(login))
                    .route(&quot;logout&quot;, web::delete().to(logout)),
            )
            // ...
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>O teste para este cenário será:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn logout_accepted() {
    dotenv().ok();
    let mut app = test::init_service(
        App::new()
            .data(Clients::new())
            .configure(app_routes)
    ).await;

    let logout_req = test::TestRequest::delete()
        .uri(&quot;/auth/logout&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .header(&quot;x-auth&quot;, &quot;token&quot;)
        .set_payload(read_json(&quot;logout.json&quot;).as_bytes().to_owned())
        .to_request();

    let resp = test::call_service(&amp;mut app,logout_req).await;
    assert_eq!(resp.status(), StatusCode::ACCEPTED);
}
<span class="boring">}
</span></code></pre></pre>
<p>E <code>logout.json</code> será:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;
}
</code></pre>
<p>Agora com o teste pronto podemos passar para entender o controller de <code>logout</code>. Em <code>logout</code> vamos receber o email como parâmetro e um token válido, conforme o teste. Com o email vamos buscar a entidade a ser atualizada e no token vamos verificar a validade do token e se pertence ao usuário correto. Uma vez que as validações estiverem corretas, inativamos seu token com <code>is_active: false</code>. Não é tão crítico garantir o <code>logout</code> por não se tratar de um código em produção e por ser pouco sensível invalidar um token, caso você queira levar este código a produção, garanta a melhor estratégia com sua equipe de segurança. No nosso controller a primeira coisa que precisamos fazer é verificar se o conteúdo de <code>Logout</code> é um email de verdade, para evitar superficialmente <code>SQL Injection</code>. Fazemos isso com:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Logout&gt;) -&gt; impl Responder {
    use regex::Regex;

    let logout_user = info.clone();
    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    
    if !email_regex.is_match(&amp;logout_user.email) {
        return HttpResponse::BadRequest().finish();
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Perceba que caso o campo email não coincida com a regex, nos retornamos <code>BadRequest</code>. Além disso, ainda falta implementarmos a struct <code>Logout</code> que nos permitirá trocar mensagens com o actor de <code>DbExecutor</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_web_api/model/auth.rs
// ...
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Logout {
    pub email: String,
}

impl Message for Logout {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Logout&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Logout, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Vale salientar que a função <code>scan_user</code> já possui implementação para a <code>feature</code> <code>db-test</code>. Além disso, é importante ressaltar que a struct <code>Logout</code> faz exatamente a mesma coisa que a struct <code>Login</code>, exceto pelo fato de que <code>Login</code> possui o campo <code>password</code>, por isso podemos simplificar a nosso <code>model</code> contendo apenas um tipo de <code>Login/Logout</code> com o campo <code>password</code> opcional. Assim <code>Login</code> pode se transformar em <code>Auth</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Auth {
    pub email: String,
    pub password: Option&lt;String&gt;,
}

impl Message for Auth {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Auth&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Auth, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, precisamos atualizar nosso <code>controller/auth</code> para utilizar <code>Auth</code> em vez de <code>Login</code> e <code>Logout</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    let login_user = info.clone();
    if !is_email_pswd_valids(&amp;login_user.email, &amp;login_user.password.clone().unwrap()) {
        return HttpResponse::BadRequest().finish();
    }

    let resp = state.postgres
        .send(login_user)
        .await;

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(user) =&gt; {
            let usr = user.unwrap();
            match usr.verify(info.clone().password.unwrap()) {
                Ok(true) =&gt; generate_jwt(usr, state).await,
                Ok(false) =&gt; HttpResponse::NoContent().finish(),
                Err(_) =&gt; HttpResponse::NoContent().finish()
            }
        }
    }
}

pub async fn logout(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Para continuarmos com <code>logout</code> precisamos receber o conteúdo do header em um request, fazemos isso adicionando o request aos argumentos de <code>logout</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {...}
<span class="boring">}
</span></code></pre></pre>
<p>Para acessarmos o conteúdo que enviamos agora vamos utilizar de uma função chamada <code>headers</code>, que retorna um mapa com todos os headers disponíveis. Nosso header de autorizaçnao terá uma cara um pouco diferente, pois se chamará <code>x-auth</code> e para obtermos ele basta chamarmos a função <code>get</code> que nos retornará um <code>Option</code> de <code>HeaderValue</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    use regex::Regex;

    let jwt = req.headers().get(&quot;x-auth&quot;);
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos fazer uma pequena mudança para tornar mais claro e organizado o controller. A função <code>is_email_pswd_valids</code> não pertence a este domínio, assim moveremos ela, e seus testes, para o módulo de core em <code>src/todo_api/core/mod.rs</code>, lembre-se de utilizar o <code>use crate::todo_api::core</code> no controller.</p>
<p>Em <code>logout</code> paramos no match do <code>email</code>, mas agora com a informação de email queremos receber informações de <code>User</code> para podermos fazer validações para o logout. Fazemos isso utilizando <code>let resp = state.postgres.send(logout_user.clone())</code> que se comporta de forma identica ao caso de <code>login</code>, e como não temos necessidade desta informação agora, podemos não utilizar o <code>await</code> imediatamente. O próximo passo é entender o estado associado ao valor <code>jwt</code>, fazemos isso em um <code>match</code>, na qual a cláusula <code>None</code> é uma resposta de <code>BadRequest</code> e a resposta <code>Some</code> vai agir sobre <code>jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...
    let resp = state.postgres
        .send(logout_user.clone());

    match jwt {
        None =&gt; return HttpResponse::BadRequest().finish(),
        Some(jwt) =&gt; {
            let jwt_value : JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap())).expect(&quot;failed to parse JWT Value&quot;);
            match validate_jwt_date(jwt_value.expires_at) {
                false =&gt; 
                    HttpResponse::Unauthorized().finish(),
                true =&gt; {
                    validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;))
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que devemos fazer em <code>Some</code> é decodificar o <code>jwt</code> com a função <code>decode_jwt</code>, que recebe como argumento um tipo <code>&amp;str</code> (<code>jwt.to_str().unwrap(</code>). Nosso uso de <code>decode_jwt</code> é bem simples, pois queremos apenas saber se o token ainda é válido, fazemos isso da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/core/mod.rs
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    use jsonwebtokens::raw::{TokenSlices, split_token, decode_json_token_slice};

    let TokenSlices {claims, .. } = split_token(jwt).unwrap();
    let claims = decode_json_token_slice(claims).expect(&quot;Failed to decode token&quot;);
    claims
}
<span class="boring">}
</span></code></pre></pre>
<p>A função <code>decode_jwt</code> consiste em separar os tokents do argumento <code>jwt</code> em partes como <code>claims</code> e <code>headers</code> e depois aplicar a função <code>decode_json_token_slice</code> para extrair o tipo <code>serde_json::value::Value</code> de <code>claims</code> e retornar <code>Value</code>. Essa implementação falharia nosso teste, assim precisamos retornar algum valor aleatório de <code>Value</code>, fazemos isso utilizando <code>serde_json::from_str</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;db-test&quot;)]
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    serde_json::from_str(&quot;{\&quot;expires_at\&quot;: \&quot;2020-11-02T00:00:00\&quot;, \&quot;id\&quot;: \&quot;bc45a88e-8bb9-4308-a206-6cc6eec9e6a1\&quot;, \&quot;email\&quot;: \&quot;my@email.com\&quot;}&quot;).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>Essa função não necessita grandes testes, já que ela não vai ser alterada com o tempo, mas é sempre bom testar que os valores batem. Assim, o módulo a seguire testa um token Jwt criado no site jwt.io e os valores de seu <code>claim</code> sendo transformado em Json pela macro <code>json!</code>. Depois disso, testamos a igualdade das partes. Com o teste a seguir vamos quebrar nossa pipeline de testes, pois este teste não utilzia a feature <code>dbtest</code> e é executado junto com todos os oturos testes. A solução mais simples para isso é separar testes unitários de testes de integração. Assim, criaremos um target <code>unit</code> no Makefile que executará <code>cargo test --lib</code>, e os testes de integração serão executados com <code>cargo test --test lib --features &quot;dbtest&quot;</code> que executará toda <code>lib</code> de <code>tests/lib</code>. Note os argumentos <code>--locked</code>, <code>--no-fail-fast</code> e <code>-- --test-threads 3</code>, que representam validar o <code>Cargo.lock</code>, não terminar o processo quando algum testes falha e executar os testes em 3 threads, repectivamente. Além disso, os testes <code>all_args_are_equal_is_accepted</code> e <code>all_args_are_not_equal_is_unauth</code> deverão ser movidos para a pasta de testes de integração <code>tests</code>, pois necessitam da feature <code>db-test</code>, coloquei eles em um módulo <code>todo_api_web/validation</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod decode_jwt {
    use super::decode_jwt;
    use serde_json::json;

    #[test]
    fn decodes_random_jwt() {
        let jwt = decode_jwt(&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6InRlc3QiLCJpYXQiOjE1MTYyMzkwMjJ9.tRF6jrkFnCfv6ksyU-JwVq0xsW3SR3y5cNueSTdHdAg&quot;);
        let expected = json!({&quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;test&quot;, &quot;iat&quot;: 1516239022 });

        assert_eq!(jwt, expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-sh">int: db
	sleep 2
	diesel setup
	diesel migration run
	cargo test --test lib --no-fail-fast --features &quot;dbtest&quot; -- --test-threads 3
	diesel migration redo


unit:
	cargo test --locked --no-fail-fast --lib -- --test-threads 3

test: unit int
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// todo_api_web/validation.rs
use todo_server::todo_api::core::{validate_jwt_info};
use todo_server::todo_api::model::auth::User;
use todo_server::todo_api_web::model::http::Clients;
use actix_web::http::StatusCode;

#[actix_rt::test]
async fn all_args_are_equal_is_accepted() {
    use dotenv::dotenv;
    dotenv().ok();

    let exec = Clients::new();
    let state = actix_web::web::Data::new(exec);

    let user = User::from(&quot;my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
    let email = &quot;my@email.com&quot;.to_string();

    let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
    assert_eq!(resp.status(), StatusCode::ACCEPTED);
}

#[actix_rt::test]
async fn all_args_are_not_equal_is_unauth() {
    use dotenv::dotenv;
    dotenv().ok();

    let exec = Clients::new();
    let state = actix_web::web::Data::new(exec);

    let user = User::from(&quot;not_my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
    let email = &quot;my@email.com&quot;.to_string();

    let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois de aplicarmos <code>decode_jwt</code> ao valor <code>jwt</code> transformamos este dado em algo manipulável coma struct que representa seu formato <code>JwtValue</code>, <code>let jwt_value :JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap()))</code>.  Com <code>jwt_value</code> em mãos podemos checar se a data está correta coma função <code>validate_jwt_date</code>, que verificar se a data do momento é inferior ou igual a <code>expires_at</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn validate_jwt_date(jwt_expires: chrono::NaiveDateTime) -&gt; bool {
    chrono::Utc::now().naive_utc() &lt;= jwt_expires
}
<span class="boring">}
</span></code></pre></pre>
<p>Com este teste implementado a função <code>#[cfg(feature = &quot;db-test&quot;)] decode_jwt</code> deve começar a falhar a partir do dia 2 de Novembro, assim, precisamos modificar ela para algo mais próximo de infinito, como mil anos deste momento:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;db-test&quot;)]
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    serde_json::from_str(&quot;{\&quot;expires_at\&quot;: \&quot;3020-11-02T00:00:00\&quot;, \&quot;id\&quot;: \&quot;bc45a88e-8bb9-4308-a206-6cc6eec9e6a1\&quot;, \&quot;email\&quot;: \&quot;my@email.com\&quot;}&quot;).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>Voltando a <code>validate_jwt_date</code>, seu tipo de retorno é um booleano, que podemos fazer <code>match</code> para validar as respostas. Caso a resposta seja false, respondemos com <code>HttpResponse::Unauthorized().finish()</code> e caso seja verdadeiro chamamos um outra função que validará as informações internas, <code>validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;))</code>. Essa validação consiste em validar a coerência entre todos os <code>email</code>s, do Jwt, do Json enviado pelo <code>DELETE</code> e o salvo no banco. Note que o <code>email</code> salvo no banco é chamado através da concretização da future <code>resp</code> com <code>await</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn validate_jwt_info(jwt_email: String, req_email: String, user: Result&lt;User, DbError&gt;) -&gt; HttpResponse {
    match user {
        Err(_) =&gt; HttpResponse::Unauthorized().finish(),
        Ok(u) =&gt; {
            if u.email == jwt_email &amp;&amp; jwt_email == req_email {
                HttpResponse::Accepted().finish()
            } else {
                HttpResponse::Unauthorized().finish()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que fazemos em <code>validate_jwt_info</code> é um <code>match</code> de seu <code>Result</code>. Se ocorrer algum erro, o mais fácil é simplesmente responder que a pessoa não tem autorização. Caso não ocorram erros, velrificamos a igualdade entre os emails com <code>if u.email == jwt_email &amp;&amp; jwt_email == req_email </code>, retornando <code>HttpResponse::Accepted().finish()</code> em caso de sucesso e <code>HttpResponse::Unauthorized().finish()</code> em caso de falha. Outro ponto importante aqui é que <code>is_active</code> deve se tornar falso. E para isso precisamos criar uma nova struct <code>Inactivate</code> que comunicará com <code>DbExecutor</code> para inativar o email associado:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Inactivate {
    pub email: String,
    pub is_active: bool
}
<span class="boring">}
</span></code></pre></pre>
<p>Que pode ter uma função <code>new</code> que recebe o <code>email</code> é já cria a struct com <code>is_active = false</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Inactivate {
    pub fn new(email: String) -&gt; Self {
        Self {
            email: email,
            is_active: false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois disso precisamos implementar as traits <code>Message</code> e <code>Handle</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Message for Inactivate {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;Inactivate&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: Inactivate, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::inactivate_user;

        inactivate_user(msg, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Quando a <code>inactivate_user</code>, seu corpo é muito parecido com <code>update_user_jwt_date</code>, pois encontramos o <code>target</code> da mesma forma, mas fazemos update apenas no campo <code>is_active</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn inactivate_user(msg: Inactivate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(msg.email));
    match diesel::update(target)
        .set(is_active.eq(msg.is_active))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, a função de teste é exatamente igual a <code>update_user_jwt_date</code>, pois retorna somente um <code>Ok(())</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn inactivate_user(msg: Inactivate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(msg.email));
    match diesel::update(target)
        .set(is_active.eq(msg.is_active))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn inactivate_user(_msg: Inactivate, _conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Para finalizar a atualização devemos enviar a struct como mensagem com <code>state.postgres.send</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn validate_jwt_info(jwt_email: String, req_email: String, user: Result&lt;User, DbError&gt;, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    match user {
        Err(_) =&gt; HttpResponse::Unauthorized().finish(),
        Ok(u) =&gt; {
            if u.email == jwt_email &amp;&amp; jwt_email == req_email {
                let inactivate = Inactivate::new(req_email);
                let is_inactive = state.postgres.send(inactivate).await;

                match is_inactive {
                    Ok(_) =&gt; HttpResponse::Accepted().finish(),
                    Err(_) =&gt; HttpResponse::Unauthorized().finish()
                }
            } else {
                HttpResponse::Unauthorized().finish()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Algumas coisas mudaram. Agora precisamos passar <code>state</code> como argumento <code>state: web::Data&lt;Clients&gt;</code> e ao utilizarmos <code>state.postgres.send(inactivate)</code>, precisamos de um <code>await</code>, que exige que nossa função passe a ser <code>async</code> com <code>pub async fn validate_jwt_info</code>. Além disso, chamamos a função <code>new</code> da struct <code>Inactivate</code> com algum dos emails que temos e depois enviamos ela para <code>DbExecutor</code> com <code>let is_inactive = state.postgres.send(inactivate).await;</code>. Um pattern matching simples em <code>is_inactive</code> nos permite responder <code>Accepted</code> para o único caso que ocorreu tudo bem. Lembre de incorporar <code>crate::todo_api::core::model::Inactivate</code> em seu escopo e de modificar o controller de <code>logout</code> para enviar o <code>state</code> e utilizar <code>await</code> em <code>validate_jwt_info</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...

    match jwt {
        None =&gt; return HttpResponse::BadRequest().finish(),
        Some(jwt) =&gt; {
            let jwt_value : JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap())).expect(&quot;failed to parse JWT Value&quot;);
            match validate_jwt_date(jwt_value.expires_at) {
                false =&gt; 
                    HttpResponse::Unauthorized().finish(),
                true =&gt; {
                    validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;), state).await
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, os testes <code>all_args_are_equal_is_accepted</code> e <code>all_args_are_not_equal_is_unauth</code> em <code>core/mod.rs</code> passam a falhar por não receberem o state correto. Como a função <code>validate_jwt_info</code> passou a ser <code>async</code> sua testabilidade diminuiu, junto com isso vamos utilizar <code>CLients::new</code> que depende de <code>dotenv</code> estar executando. Para isso, devemos criar um <code>web::Data&lt;CLients&gt;</code> que será passado como argumento e disponibilizar um runtime para <code>async</code> com <code>#[actix_rt::test]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
    async fn all_args_are_equal_is_accepted() {
        use dotenv::dotenv;
        dotenv().ok();

        let exec = Clients::new();
        let state = actix_web::web::Data::new(exec);

        let user = User::from(&quot;my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
        let email = &quot;my@email.com&quot;.to_string();
        
        let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
        assert_eq!(resp.status(), StatusCode::ACCEPTED);
    }

    #[actix_rt::test]
    async fn all_args_are_not_equal_is_unauth() {
        use dotenv::dotenv;
        dotenv().ok();

        let exec = Clients::new();
        let state = actix_web::web::Data::new(exec);

        let user = User::from(&quot;not_my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
        let email = &quot;my@email.com&quot;.to_string();

        let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
        assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Por último, precisamos dar uma organizada no nosso código.</p>
<h2 id="refatorando-1"><a class="header" href="#refatorando-1">Refatorando</a></h2>
<p>Existem três coisas que eu gostaria de refatorar no momento. A primeira é o módulo de erros <code>db/error.rs</code>, que está totalmente deslocado. A segunda é mover o <code>core/model.rs</code> para <code>model/core.rs</code>, pois creio que agora já cresceu bastante. E a terceira é encontrar um nome melhor para <code>UpdateDate</code>,  como <code>UpdateUserStatus</code>. Começando pela terceira, selecionei para que meu editor de texto encontrasse todos os casos de <code>UpdateDate</code> e substituisse eles por <code>UpdateUserStatus</code> sem grandes conflitos. Depois disso, vamos mover o módulo de erros. Para iniciarmos o processo, precisamos mover a definição do módulo de <code>db/mod.rs</code> para <code>model/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//db/mod.rs
pub mod helpers;
pub mod todo;
pub mod auth;

// model/mod.rs
use rusoto_dynamodb::AttributeValue;
use std::collections::HashMap;
use uuid::Uuid;

pub mod auth;
pub mod error;
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Movemos todo o arquivo e precisamores modificar o caminho do <code>use</code> deste arquivo nos seguintes arquivos:</p>
<ul>
<li><code>src/todo_api/core</code> em <code>mod.rs</code> e <code>model.rs</code>.</li>
<li><code>src/todo_api/db/auth.rs</code></li>
<li><code>src/todo_api_web/model/auth.rs</code></li>
</ul>
<p>São mudanças bastante simples, basta substituir o <code>db</code> pelo <code>model</code> nos caminhos dos <code>use</code>. E para a segunda mudança, vamos criar o módulo <code>core</code> em <code>model/mod.rs</code>  com <code>pub mod core</code> e mover o arquivo <code>core/model.rs</code> para <code>model/core.rs</code>. Vamos modificar os mesmos arquivos que modificamos em <code>db/error</code>, a única diferença é que a função <code>generate_jwt</code> incorporava <code>Jwt</code> em seu escopo de forma individual. Executando nossos testes com <code>make test</code> está tudo ok e podemos continuar para implementar o requerimento de jwt nas chamadas dos endpoints que já temos.</p>
<p><a href="part-1/04-serving.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/06-middleware.html">Próximo</a></p>
<p><a href="part-1/05-auth.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/07-ci.html">Próximo</a></p>
<h1 id="exigindo-autenticação"><a class="header" href="#exigindo-autenticação">Exigindo Autenticação</a></h1>
<p>Agora que implementamos a lógica de login, precisamos aplicar ela ao nosso serviço. Atualmente nosso serviço possui 4 conjuntos de rotas, <code>/auth/</code>, <code>/api/</code>, <code>/ping</code>,  <code>/~/ready</code>. Dessas rotas somente uma precisa de autenticação (<code>api</code>) enquanto as outras servem para fazer a autenticação (<code>auth</code>), ver a saúde do serviço (<code>ping</code>) e ver a disponibildiade de receber chamadas do serviço (<code>ready</code>). Assim, precisamos implementar &quot;algo&quot; que vai aplicar o sistema de login somente a rota <code>/api</code>. Esse algo será um middleware que nós vamos construir, ao contrário dos outros que já utilizamos, e lidará com a lógica de autenticação.</p>
<blockquote>
<p><strong>Middleware</strong></p>
<p>Já utilizamos Middlewares anterioemente, mas como foram utilizações superficiais não foi preciso entender mais a fundo o que eram. Agora creio que seja um momento interessante de defini-los. Middlewares não são um conceito exclusivo de aplicações web, podendo ser utilizados tanto em sistemas operacionais como em programas do dia a dia. Os middlewares proveem um conjunto de serviços e capacidades comuns a uma aplicação que sua base não prove. Esses serviços e capacidades podem ser gerenciamento de dados, tratamento de mensagens, autenticação e logs. Assim, middlewares atual como um tecido conectivo de vários serviços da aplicação.</p>
<p>No caso de middlewares de aplicações web, geralmente sua funcionalidade é adicionar comportamentos aos processamento de request e de response. Eles consegue se conectar a um request, ou a um response, que chegou ao servidor e alterar este request, inclusive respondendo antes do esperado, ou alterando o response. Utilizamos o middleware de <code>Logger</code> para incluir logs ao processamento do nosso request e o middleware de <code>DefaultHeaders</code> para incluir um header em nosso response.</p>
</blockquote>
<p>As alterações a seguir nos exigiram modificar o Cargo.toml para conter a crate <code>futures</code> e mover a crate <code>actix-server</code> para <code>dependencies</code>:</p>
<pre><code class="language-toml">[dependencies]
actix = &quot;0.9.0&quot;
#...
jsonwebtokens = &quot;1.0.0-alpha.12&quot;
actix-service = &quot;1.0.5&quot;
futures = &quot;0.3.4&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
</code></pre>
<h2 id="estrutura-de-um-middleware-com-actix"><a class="header" href="#estrutura-de-um-middleware-com-actix">Estrutura de um middleware com Actix</a></h2>
<p>Um middleware pode ser registrado em cada <code>App</code>, <code>scope</code> ou <code>Resource</code> do servidor e é executado em ordem oposta a seu registro. De modo geral, middlewares em Actix são um tipo, preferenciamente uma struct, que implementa as traits <code>Service</code> e <code>Transform</code>, da crate <code>actix_service</code>. Assim, cada um dos métodos da trait tem a capacidade de responder algo imediatamente ou através de uma future. O exemplo mais básico de Middleware seria um <code>hello world</code> no request (<code>Hello from Request</code>) e outro na response (<code>Hello from Response</code>), conforme o código a seguir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

use actix_service::{Service, Transform};
use actix_web::{dev::ServiceRequest, dev::ServiceResponse, Error};
use futures::future::{ok, Ready};
use futures::Future;

pub struct SayHi;

impl&lt;S, B&gt; Transform&lt;S&gt; for SayHi
where
    S: Service&lt;Request = ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,
    S::Future: 'static,
    B: 'static,
{
    type Request = ServiceRequest;
    type Response = ServiceResponse&lt;B&gt;;
    type Error = Error;
    type InitError = ();
    type Transform = SayHiMiddleware&lt;S&gt;;
    type Future = Ready&lt;Result&lt;Self::Transform, Self::InitError&gt;&gt;;

    fn new_transform(&amp;self, service: S) -&gt; Self::Future {
        ok(SayHiMiddleware { service })
    }
}

pub struct SayHiMiddleware&lt;S&gt; {
    service: S,
}

impl&lt;S, B&gt; Service for SayHiMiddleware&lt;S&gt;
where
    S: Service&lt;Request = ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,
    S::Future: 'static,
    B: 'static,
{
    type Request = ServiceRequest;
    type Response = ServiceResponse&lt;B&gt;;
    type Error = Error;
    type Future = Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;;

    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        self.service.poll_ready(cx)
    }

    fn call(&amp;mut self, req: ServiceRequest) -&gt; Self::Future {
        println!(&quot;Hello from Request. You requested: {}&quot;, req.path());

        let fut = self.service.call(req);

        Box::pin(async move {
            let res = fut.await?;

            println!(&quot;Hello from Response&quot;);
            Ok(res)
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Existem 2 passos no processamento de um middleware. O primeiro é sua inicialização, na qual o <code>middleware factory</code> é chamado com o próximo serviço encadeado. Isso corresponde a função <code>new_transform</code> da trait <code>Transform</code> com o tipo <code>S</code> definido como <code>Service&lt;_,_,_&gt;</code> sendo o campo<code>service</code> que <code>SayHiMiddleware&lt;S&gt;</code> implementa. Depois disso o método <code>call</code> é chamado com o request. <code>poll_ready</code> nos indica quando a future está pronta.</p>
<p>O parâmetro <code>req: ServiceRequest</code> pode ser passado de forma mutável e adaptar o request, por exemplo um request do tipo <code>application/edn</code> poderia ser convertido para <code>application/json</code>/ Depois disso, temos a future contendo a response em <code>let fut = self.service.call(req);</code>, que só é concretizada dentro de uma <code>Box</code> não movível contendo um bloco <code>async</code>. a função <code>Pin</code> torna a <code>Box</code> um ponteiro fixo em memória, não movível. Depois disso, basta responde a <code>future</code> com a respostas <code>res</code>.</p>
<h2 id="definindo-o-middleware-de-autenticação"><a class="header" href="#definindo-o-middleware-de-autenticação">Definindo o Middleware de autenticação</a></h2>
<p>A primeira coisa que devemos fazer aqui é criar o módulo middleware em nosso código. Esse módulo estará contido em <code>src/todo_api_web/middleware/mod.rs</code>. Com o módulo criado podemos definir a struct de autenticação, <code>Authentication</code>, que corresponde a struct <code>SayHi</code>. É essa struct que vamos passar como argumento para o <code>wrap</code> de <code>App</code>, <code>App:new().wrap(crate::todo_api_web::middleware::Authentication)</code>. <code>Authentication</code> criará o <code>middleware factory</code> para passarmos o serviço a um middleware de fato, <code>AuthenticationMiddleware</code>,  que nos permitirá alterar o request. Este bloco de código fica assim:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_service::{Service, Transform};
use actix_web::{
    dev::{ServiceRequest, ServiceResponse},
    Error, HttpResponse,
};
use futures::{
    future::{ok, Ready},
    Future,
};
use std::{
    pin::Pin,
    task::{Context, Poll},
};

use crate::{
    todo_api_web::model::http::Clients,
    todo_api::{
        core::decode_jwt,
        model::core::JwtValue,
    }
};

pub struct Authentication;

impl&lt;S: 'static, B&gt; Transform&lt;S&gt; for Authentication
where
    S: Service&lt;Request = ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,
    S::Future: 'static,
    B: 'static,
{
    type Request = ServiceRequest;
    type Response = ServiceResponse&lt;B&gt;;
    type Error = Error;
    type InitError = ();
    type Transform = AuthenticationMiddleware&lt;S&gt;;
    type Future = Ready&lt;Result&lt;Self::Transform, Self::InitError&gt;&gt;;

    fn new_transform(&amp;self, service: S) -&gt; Self::Future {
        ok(AuthenticationMiddleware { service })
    }
}
pub struct AuthenticationMiddleware&lt;S&gt; {
    service: S,
}

impl&lt;S: 'static, B&gt; Service for AuthenticationMiddleware&lt;S&gt;
where
    S: Service&lt;Request = ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,
    S::Future: 'static,
    B: 'static,
{
    type Request = ServiceRequest;
    type Response = ServiceResponse&lt;B&gt;;
    type Error = Error;
    type Future = Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;;

    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        self.service.poll_ready(cx)
    }

    fn call(&amp;mut self, req: ServiceRequest) -&gt; Self::Future {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Não há muito o que alterar aqui além do nome das structs, pois este é um modelo padrão para se gerar um middleware, porém poderiámos retornar informações ainda no nível de <code>new_transform</code> e de <code>poll_ready</code>. Já a função <code>call</code> é o centro de nossa atenção, sendo ela responsável pela manipulação de dados que queremos fazer. O primeiro caso que vamos ver é o fato de querermos que este middleware atue somente nas rotas <code>/api/</code>, assim temos duas soluções para isso. A primeira seria adicionar este middleware diretamente em <code>web::scope(&quot;api/&quot;)</code> do arquivo de rotas:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                    .wrap(crate::todo_api_web::middleware::Authentication)
                    .route(&quot;create&quot;, web::post().to(create_todo))
                    .route(&quot;index&quot;, web::get().to(show_all_todo)),
            )
            .service(
                web::scope(&quot;auth/&quot;)
                    .route(&quot;signup&quot;, web::post().to(signup_user))
                    .route(&quot;login&quot;, web::post().to(login))
                    .route(&quot;logout&quot;, web::delete().to(logout)),
            )
            .route(&quot;ping&quot;, web::get().to(pong))
            .route(&quot;~/ready&quot;, web::get().to(readiness))
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Nnao gosto muito desta alternativa pois ela impacta a testabilidade. Portanto, prefiro a segunda alternativa que é criar uma condicional que verifica se a rota do request começa com os <code>scope</code>  que queremos. Caso a condicional for verdadeira, aplicamos nossa lógica, senão, simplesmente damos sequência ao request:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call(&amp;mut self, req: ServiceRequest) -&gt; Self::Future {
        if req.path().starts_with(&quot;/api/&quot;) {
         // ...
        } else {
            let fut = self.service.call(req);
            Box::pin(async move {
                let res = fut.await?;
                Ok(res)
            })
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>O <code>if</code> que definimos extrai o <code>path</code>, rota, de <code>ServiceRequest</code>, e aplica a função <code>starts_with</code> com o início da rota que queremos, <code>/api/</code>. Com isso, toda as rotas do serviço que começarem com <code>/api/</code> serão alteradas por este middleware. O próximo passo é extrairmos o header <code>x-auth</code> dos headers do request:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call(&amp;mut self, req: ServiceRequest) -&gt; Self::Future {
        if req.path().starts_with(&quot;/api/&quot;) {
            // ...
            let jwt = req.headers().get(&quot;x-auth&quot;);

            match jwt {
                None =&gt; Box::pin(async move {
                    Ok::&lt;_,actix_http::error::Error&gt;(req.into_response(
                        HttpResponse::BadRequest()
                        .json(&quot;{\&quot;error\&quot;: \&quot;x-auth is required\&quot;}&quot;)
                        .into_body()
                    ))
                }),
                Some(token) =&gt; {
                    // ...
                }
            }
        }
        // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Exatraimos o header <code>x-auth</code> aplicando a função <code>headers</code> a request, que obtém todos os headers, e posteriormente escolhendo um header específico com <code>get</code>. O retorno desta função é um <code>Option&lt;String&gt;</code> contendo a String de Jwt. Como este campo é obrigatório, fazemos um <code>match</code> em <code>jwt</code> e no caso <code>None</code> retornamos um <code>BadRequest</code> com a informação que <code>x-auth</code> é requerido, <code>x-auth is required</code>. Depois disso precisamos de duas coisas, decodificar o token Jwt e enviar a resposta decodificada para validar ela no banco de dados, assim precisaremos da função <code>decode_jwt</code> para decodificar o <code>jwt</code> e de <code>Clients</code> armazenado em <code>data</code> para comunicar com o banco de dados: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call(&amp;mut self, req: ServiceRequest) -&gt; Self::Future {
        if req.path().starts_with(&quot;/api/&quot;) {
            let data = req.app_data::&lt;Clients&gt;().expect(&quot;Failed to parse app_data&quot;);
            let jwt = req.headers().get(&quot;x-auth&quot;);

            match jwt {
                None =&gt; // ...
                Some(token) =&gt; {
                    let decoded_jwt: JwtValue = serde_json::from_value(decode_jwt(token.to_str().unwrap())).expect(&quot;Failed to parse Jwt&quot;);
                    let valid_jwt = data.postgres.send(decoded_jwt);

                    let fut = self.service.call(req);
                    Box::pin(async move {
                        match valid_jwt.await {
                            Ok(true) =&gt; {
                                let res = fut.await?;
                                Ok(res)
                            },
                            _ =&gt; {
                                Err(Error::from(()))
                            }
                        }
                    })
                }
            }
        } 
        // ...
    }
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Para recordar <code>decode_jwt</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
   use jsonwebtokens::raw::{decode_json_token_slice, split_token, TokenSlices};

   let TokenSlices { claims, .. } = split_token(jwt).unwrap();
   let claims = decode_json_token_slice(claims).expect(&quot;Failed to decode token&quot;);
   claims
}
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>Nossa função <code>call</code> transforma o token em uma struct <code>JwtValue</code>, que corresponde aos campos presentes no token, através da função <code>serde_json::from_value</code>. O valor de <code>JwtValue</code> é enviado para o banco de dados através de <code>data.postgres.send(decoded_jwt)</code>. Com o resultado da troca de mensagens com <code>DbExecutor</code> via <code>data.postgres.send</code> recebemos um tipo <code>Result&lt;bool, MailBoxError&gt;</code> e fazemos <code>match</code>. O único caso que nos interessa é o <code>Ok(true)</code>, para todos os outros lançamos uma erro. Este erro retornará <code>InternalServerError</code>, pois não podemos reutilizar o conteúdo de <code>req</code> já que foi utilizado em <code>let fut = self.service.call(req);</code> para conretizar o request. Caso o resultado do <code>match</code> seja <code>Ok(true)</code>, deixamos o request prosseguir. Agora, vamos a implementação de <code>JwtValue</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub struct JwtValue {
    pub id: String,
    pub email: String,
    pub expires_at: chrono::NaiveDateTime,
}

impl Message for JwtValue {
    type Result = bool;
}

impl Handler&lt;JwtValue&gt; for DbExecutor {
    type Result = bool;

    fn handle(&amp;mut self, msg: JwtValue, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::token_is_valid;

        let user = token_is_valid(&amp;msg, &amp;self.0.get().expect(&quot;Failed to open connection&quot;));
        match user {
            Err(_) =&gt; false,
            Ok(user) =&gt; {
                match (user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id) {
                    (true, true, true) =&gt; true,
                    _ =&gt; false
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso token Jwt possui 3 campos em seu <code>claim</code> <code>id, email, expires_at</code>, assim a implementação de <code>JwtValue</code> possui estes 3 campos, definidos como <code>String, String, chrono::NaiveDateTime</code>, respectivamente. Depois definimos a trait <code>Message</code>, com o tipo <code>type Result = bool;</code>. Para <code>Handler</code>, procuramos o <code>User</code> com <code>token_is_valid(&amp;msg, &amp;self.0.get().expect(&quot;Failed to open connection&quot;))</code> e depois aplicamos <code>match</code> a sua resposta. Em caso de <code>Err</code>, retornamos <code>false</code>, e em caso de <code>Ok</code>, verificamos todas as condições que queremos em outro <code>match</code> (poderia ser um <code>if/else</code>, mas creio que o match ficou mais elegante devido ao uso da tupla). Caso todos os itens da tupla, <code>(user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id)</code> sejam verdadeiros, retornamos <code>true</code>, senão <code>false</code>. Os itens da tupla são:</p>
<ol>
<li>Usuário está ativo com <code>user.is_active</code>.</li>
<li>Data atual é inferior a data <code>expires_at</code> do token com <code>validate_jwt_date(user.expires_at)</code>.</li>
<li>O id do token é o mesmo do usuário cadastrado com <code>user.id.to_string() == msg.id</code>.</li>
</ol>
<p>Quanto a nossa função <code>token_is_valid</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn token_is_valid(token: &amp;JwtValue, conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt; {
    use crate::schema::auth_user::dsl::*;

    let items = auth_user.filter(email.eq(&amp;token.email)).load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users.first().unwrap().clone().to_owned()),
        Err(_) =&gt; Err(DbError::CannotFindUser),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ela é praticamente igual a função <code>scan_user</code>. Assim, podemos substituir ela por scan user, obtendo o campo <code>email</code> de <code>JwtValue</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler&lt;JwtValue&gt; for DbExecutor {
    type Result = bool;

    fn handle(&amp;mut self, msg: JwtValue, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        let user = scan_user(String::from(&amp;msg.email), &amp;self.0.get().expect(&quot;Failed to open connection&quot;));
        match user {
            Err(_) =&gt; false,
            Ok(user) =&gt; {
                match (user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id) {
                    (true, true, true) =&gt; true,
                    _ =&gt; false
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com tudo isso pronto, basta adicionar o middleware em <code>App::new()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::main]
async fn web_main() -&gt; Result&lt;(), std::io::Error&gt; {
    HttpServer::new(|| {
        App::new()
        .data(Clients::new())
        .wrap(DefaultHeaders::new().header(&quot;x-request-id&quot;, Uuid::new_v4().to_string()))
        .wrap(Logger::new(&quot;IP:%a DATETIME:%t REQUEST:\&quot;%r\&quot; STATUS: %s DURATION:%D X-REQUEST-ID:%{x-request-id}o&quot;))
        .wrap(crate::todo_api_web::middleware::Authentication)
        .configure(app_routes)
    })
    .workers(num_cpus::get() + 2)
    .bind(&quot;0.0.0.0:4000&quot;)
    .unwrap()
    .run()
    .await
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="testando-o-middleware"><a class="header" href="#testando-o-middleware">Testando o middleware</a></h3>
<p>Nosso middleware funciona bem, e basta executar o comando <code>make run</code> para se divertir com ele, porém não temos nenhum teste que garante o comportamento do middleware. Assim, podemos criar pelo menos dois testes. O primeiro teste é não enviar um header <code>x-auth</code> para uma rota <code>/api/</code> e o segundo teste é enviar um token aleatório. Como <code>decode_token</code> possui uma versão para feature <code>db-test</code>, o resultado será sempre um user válido. Assim, vamos ao primeiro teste:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod middleware {
    use actix_web::{test, App, http::StatusCode};
    use dotenv::dotenv;
    use todo_server::todo_api_web::model::http::Clients;
    use todo_server::todo_api_web::routes::app_routes;

    use crate::helpers::read_json;

    #[actix_rt::test]
    async fn bad_request_todo_post() {
        dotenv().ok();
        let mut app =
            test::init_service(
                App::new()
                .data(Clients::new())
                .wrap(todo_server::todo_api_web::middleware::Authentication)
                .configure(app_routes)
            ).await;

        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        assert_eq!(resp.status(), StatusCode::BAD_REQUEST);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este teste é práticamente igual ao teste que criamos uma <code>todo_card</code>, porém possui a função <code>.wrap(todo_server::todo_api_web::middleware::Authentication)</code> associada a <code>App</code> e em vez de validar a resposta valida o status como <code>BAD_REQUEST</code>. Depois disso, podemos criar um teste que adiciona um header <code>x-auth</code> com um Jwt contendo valores aleatórios para nossos campos:</p>
<pre><code>{
  &quot;id&quot;: &quot;7562bf53-6156-433b-a201-90bbc74b0127&quot;,
  &quot;email&quot;: &quot;my@email.com&quot;,
  &quot;expires_at&quot;: &quot;2014-11-28T12:00:09&quot;
}

Algoritmo HS256 com chave `your-256-bit-==secret`

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Ijc1NjJiZjUzLTYxNTYtNDMzYi1hMjAxLTkwYmJjNzRiMDEyNyIsImVtYWlsIjoibXlAZW1haWwuY29tIiwiZXhwaXJlc19hdCI6IjMwMjAtMTEtMjhUMTI6MDA6MDkifQ.hom6KvmmLIuu3dLCSUrOK9KBWyUb0fvdX4hIay52UIY
</code></pre>
<p>O teste para estes valores é:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn good_token_todo_post() {
    dotenv().ok();
    let mut app =
        test::init_service(
            App::new()
            .data(Clients::new())
            .wrap(todo_server::todo_api_web::middleware::Authentication)
            .configure(app_routes)
        ).await;

    let req = test::TestRequest::post()
        .uri(&quot;/api/create&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .header(&quot;x-auth&quot;, &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Ijc1NjJiZjUzLTYxNTYtNDMzYi1hMjAxLTkwYmJjNzRiMDEyNyIsImVtYWlsIjoibXlAZW1haWwuY29tIiwiZXhwaXJlc19hdCI6IjMwMjAtMTEtMjhUMTI6MDA6MDkifQ.hom6KvmmLIuu3dLCSUrOK9KBWyUb0fvdX4hIay52UIY&quot;)
        .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
        .to_request();

    let resp = test::call_service(&amp;mut app, req).await;
    println!(&quot;{:?}&quot;, resp);
    assert_eq!(resp.status(), StatusCode::CREATED);
}
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos este teste vamos receber como resposta um <code>panic!</code>, pois o middleware vai conter um <code>is_active</code> false que vai se encadear para um <code>Err</code>. Assim, precisaremos fazer algumas modificações em <code>scan_user</code>, <code>User.from</code> e <code>handle</code> de JwtValue. Com isso, as modificações serão em ordem de encadeamento:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/core.rs
impl Handler&lt;JwtValue&gt; for DbExecutor {
    type Result = bool;

    #[cfg(not(feature = &quot;dbtest&quot;))]
    fn handle(&amp;mut self, msg: JwtValue, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        let user = scan_user(String::from(&amp;msg.email), &amp;self.0.get().expect(&quot;Failed to open connection&quot;));
        match user {
            Err(_) =&gt; false,
            Ok(user) =&gt; {
                match (user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id) {
                    (true, true, true) =&gt; true,
                    _ =&gt; false
                }
            }
        }
    }

    #[cfg(feature = &quot;dbtest&quot;)]
    fn handle(&amp;mut self, msg: JwtValue, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::test_scan_user;

        let user = test_scan_user(String::from(&amp;msg.email), String::from(&amp;msg.id), &amp;self.0.get().expect(&quot;Failed to open connection&quot;));
        match user {
            Err(_) =&gt; false,
            Ok(user) =&gt; {
                match (user.is_active, validate_jwt_date(user.expires_at), user.id.to_string() == msg.id) {
                    (true, true, true) =&gt; true,
                    _ =&gt; false
                }
            }
        }
    }
}

// src/todo_api/db/auth.rs
#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn scan_user(user_email: String, conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt; {
    use crate::schema::auth_user::dsl::*;

    let items = auth_user.filter(email.eq(&amp;user_email)).load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users.first().unwrap().clone().to_owned()),
        Err(_) =&gt; Err(DbError::CannotFindUser),
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn scan_user(user_email: String, _conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt; {
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;
    let query = auth_user.filter(email.eq(&amp;user_email));
    let expected = &quot;SELECT \&quot;auth_user\&quot;.\&quot;email\&quot;, \&quot;auth_user\&quot;.\&quot;id\&quot;, \&quot;auth_user\&quot;.\&quot;password\&quot;, \&quot;auth_user\&quot;.\&quot;expires_at\&quot;, \&quot;auth_user\&quot;.\&quot;is_active\&quot; FROM \&quot;auth_user\&quot; WHERE \&quot;auth_user\&quot;.\&quot;email\&quot; = $1 -- binds: [\&quot;my@email.com\&quot;]&quot;.to_string();

    assert_eq!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string(), expected);
    Ok(User::from(user_email, &quot;this is a hash&quot;.to_string()))
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn test_scan_user(user_email: String, auth_id: String, _conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt; {
    Ok(User::test_from(user_email, &quot;this is a hash&quot;.to_string(), auth_id))
}

// src/todo_api/model/auth.rs
impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
            is_active: false,
        }
    }

    #[cfg(feature = &quot;dbtest&quot;)]
    pub fn test_from(email: String, password: String, id: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::parse_str(&amp;id).unwrap(),
            password: password,
            expires_at: utc.naive_utc(),
            is_active: true,
        }
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Precisamos modificar <code>handle</code> pois precisamos enviar <code>id</code> como argumento para validar seu valor posteriormente. Como enviamos id, precisamos modificar <code>scan_user</code> para criar um <code>test_scan_user</code> que receba o <code>id</code> como argumento e passe para um <code>User::from</code> que também suporte configurar <code>id</code> e definir <code>is_active</code> como <code>true</code>. Com isso, todos nossos testes passam e podemos prosseguir para os últimos passos, criar um CI, obter um <code>todo</code> pelo seu <code>id</code> e fazer update de um <code>todo</code>.</p>
<p><a href="part-1/05-auth.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/07-ci.html">Próximo</a></p>
<p><a href="part-1/06-middleware.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/08-conclusao.html">Próximo</a></p>
<h1 id="configurando-um-ci"><a class="header" href="#configurando-um-ci">Configurando um CI</a></h1>
<p>Como já temos a estrutura central de nosso projeto pronta (autenticação com postgres, gerenciamento de dados com DynamoDB e middlewares) podemos começar a pensar em um CI. Para isso, devemos considerar as restrições que temos no nosso <code>make test</code>, que executamos contra um container docker do psotgres:</p>
<pre><code class="language-sh">db:
	docker run -i --rm --name auth-db -p 5432:5432 -e POSTGRES_USER=auth -e POSTGRES_PASSWORD=secret -d postgres

int: db
	sleep 2
	diesel setup
	diesel migration run
	cargo test --test lib --no-fail-fast --features &quot;dbtest&quot; -- --test-threads 3
	diesel migration redo


unit:
	cargo test --locked  --no-fail-fast --lib -- --test-threads 3

test: unit int
</code></pre>
<p>Nosso Makefile para testes consistem em 3 alvos <code>int</code> para testes de integração, <code>unit</code> para testes unitários e <code>test</code> para executar os dois. Algo que podemos ficar em dúvida é o porquê deles estarem separados em <code>int</code> e <code>unit</code>, o motivo é simplesmente que é mais fácil executar os testes unitários e eles são executados mais rapidamente que os de integração. Bom, vamos aos nossos alvos de teste. o alvo <code>unit</code> possui as flags <code>--lib</code> que executa somente os testes encontrados nos módulos de <code>lib.rs</code> e a flag <code>--no-fail-fast</code> que executa todos os testes mesmo que algum deles falhe. Para um CI é bastante útil esta flag de <code>--no-fail-fast</code>, pois queremos saber tudo que precisamos corrigir e, assim, não precisarmos ficar corrigindo a cada commit para a branch. Já o teste de integração possui diversos passos:</p>
<ol>
<li>executa o target <code>db</code>, que sobe um container docker com postgres.</li>
<li><code>sleep 2</code> pausa o processo por 2 segundos até que o container se estabilize.</li>
<li><code>diesel setup</code>, falamos anteriormente, mas ajuda o diesel a configurar o banco recém gerado (pode não ser necessário).</li>
<li><code>disel migration run</code>, executa as migrações para o banco.</li>
<li><code>cargo test</code>, os testes em si.</li>
<li><code>diesel migration redo</code>, não precisa estar presente no CI, pois o contaienr com postgres será destruido depois da execução, não necessitando fazer <code>rollback</code> das migrações.</li>
</ol>
<p>Agora vamos entender o item <code>5</code>. Executamos o <code>cargo test</code> com a flag  <code>--test</code> que indica que vamos executar os testes de integração apenas do arquivo <code>lib.rs</code>, que contém nossos módulos. Depois ativamos a feature <code>dbtest</code> com <code>--features &quot;dbtest&quot;</code>. Agora que sabemos os passos que precisamos executar no CI podemos começar a pensar em sua criação.</p>
<h2 id="travis-ci"><a class="header" href="#travis-ci">Travis-CI</a></h2>
<p>O modelo de CI que escolhi para este projeto é o Travis-CI, pois acredito que seja bem simples e executa tudo que precisamos fazer, build e testes. Para executar o travis-ci é necessário entrar no site deles, https://travis-ci.org/, se registrar e dar permissão para o seu github, existe um botão que já faz a autorização e o registro <code>Sign in with github</code>. Caso seus repositórios não apareçam, sugiro clicar em <code>profile</code>, imagem no canto superior direito, e na página de <code>profile</code> clicar em <code>sync account</code>. Agora basta você dar permissão para os repositórios específicos clicando nas chaves ao lado do nome dos repositórios.</p>
<p>Uma vez que esse processo de registro estiver pronto, você vai precisar adicionar um arquivo <code>.travis.yml</code> ao seu repositório. Este arquivo é uma sequencia de comandos que o CI precisará executar. No nosso caso, este arquivo terá o seguinte formato:</p>
<pre><code class="language-yaml">language: rust
rust:
  - nightly
  - 1.40.0
  - stable
cache: cargo
services:
- postgresql
before_script:
- psql -c 'create database auth_db;' -U postgres
- echo &quot;DATABASE_URL=postgres://postgres@localhost/auth_db&quot; &gt; .env
- cargo install diesel_cli --no-default-features --features=postgres
- diesel migration run
script:
- cargo build --verbose --all
- cargo test --locked  --no-fail-fast --lib
- cargo test --test lib --no-fail-fast --features &quot;dbtest&quot;
</code></pre>
<p>O primeiro passo é declarar qual linguagem que estamos utilizando, no nosso caso <code>rust</code>, <code>language: rust</code>. Depois disso, definimos quais targets de rust vamos executar nosso código. Como a versão de rust que eu estou suando é a <code>1.40</code>, espero que o código tenha que passar pelo menos nesta versão, além disso, gostaria de testar em <code>nightly</code> e na última <code>stable</code> sob a chave <code>rust:</code>. Precisamos do <code>cargo</code> também, para isso salvamos seu conteúdo em cache com  <code>cache: cargo</code>. O serviço que vamos utilizar como banco de dados é o postgres, assim é necessário declará-lo em <code>services: - postgresql</code>. O próximo passo corresponde aos scripts q devemos executar antes dos nossos cenários de teste, para isso utilizamos a chave <code>before_script</code> com os seguintes ítens:</p>
<ul>
<li><code>psql -c 'create database auth_db;' -U postgres</code>, corresponde ao <code>diesel setup</code> e nos permite criar a base de dados <code>auth_db</code> no postgres.</li>
<li><code>echo &quot;DATABASE_URL=postgres://postgres@localhost/auth_db&quot; &gt; .env</code> é preciso ter o campo <code>DATABASE_URL</code> configurado em seu <code>.env</code> para executar o <code>DbExecutor</code>, assim utilizamos o <code>echo &lt;campo exportado&gt; &gt; .env</code> para enviar o campo exportado para <code>.env</code>.</li>
<li><code>cargo install diesel_cli --no-default-features --features=postgres</code> instalamos o <code>diesel_cli</code> para poder executar as migrações.</li>
<li><code>diesel migration run</code>, executamos as migrações.</li>
</ul>
<p>Por último, definimos os scripts que vamos executar com a chave <code>script:</code>:</p>
<ul>
<li><code>cargo build --verbose --all</code>, testar se o build funciona.</li>
<li><code>cargo test --locked  --no-fail-fast --lib</code> executar os testes unitários.</li>
<li><code>cargo test --test lib --no-fail-fast --features &quot;dbtest&quot;</code>, executar os testes de integração.</li>
</ul>
<p>Quando comitarmos isso e habilitarmos o travis ler este repositório, teremos um resultado como este:</p>
<p><img src="part-1/imagens/travis.png" alt="Resultado do Travis CI para o Todo Server" /></p>
<p>Agora podemos terminar nosso todo sever implementando um <code>get by id</code>.</p>
<p><a href="part-1/06-middleware.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/08-conclusao.html">Próximo</a></p>
<p><a href="part-1/07-ci.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/part-2/00-capa.html">Próximo</a></p>
<h1 id="concluindo-o-serviço"><a class="header" href="#concluindo-o-serviço">Concluindo o serviço</a></h1>
<p>Falta pouco para termos nosso serviço pronto, pois precisamos implementar um <code>get</code> por id e um <code>update</code>. O <code>get</code> por id não é muito diferente da rota <code>index</code>, a única diferença é que vamos passar um parâmetro <code>id</code> e chamaremos a rota de <code>show</code> e será um método <code>GET</code> também. Já o <code>update</code> é um pouco diferente pois vamos enviar um corpo Json com as informações para atualizar em uma rota <code>update</code> com o método <code>PUT</code>. Assim, os endpoints que vamos implementar são:</p>
<ol>
<li>HTTP autenticado em <code>show/{id}</code> com o método <code>GET</code>.</li>
<li>HTTP autenticado em <code>update/{id}</code> com o método <code>PUT</code> e um body do tipo Json.</li>
</ol>
<h2 id="show-por-id"><a class="header" href="#show-por-id">Show por ID</a></h2>
<p>Como já falamos anteriormente, nosso objetivo agora é recuperar um <code>TodoCard</code> com base em seu <code>id</code> de inserção no banco de dados. Faremos isso utilizando a mesma função que utilizamos na rota <code>index</code>, <code>scan</code>. Para isso, sabemos que vamos precisar da rota <code>show/{id}</code>, como já mencionamos, e vamos precisar retornar um <code>TodoCard</code>. Assim, imagino que um bom teste para este cenário seria o seguinte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(test)]
mod show_by_id {
    use actix_web::{test, App};
    use dotenv::dotenv;
    use todo_server::todo_api_web::model::{
        http::Clients,
        todo::TodoCard,
    };
    use todo_server::todo_api_web::routes::app_routes;
    use serde_json::from_str;
    use crate::helpers::{mock_get_todos};

    #[actix_rt::test]
    async fn test_todo_card_by_id() {
        dotenv().ok();
        let mut app =
            test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

        let req = test::TestRequest::with_uri(&quot;/api/show/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;).to_request();
        let resp = test::read_response(&amp;mut app, req).await;

        let todo_card: TodoCard =
            from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
        assert_eq!(&amp;todo_card, mock_get_todos().get(0usize).unwrap());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este teste consiste em definir um request com um uuid, neste caso aleatório, para a rota <code>show</code> com <code>test::TestRequest::with_uri(&quot;/api/show/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;).to_request()</code>. Com o request em mão, chamamos o serviço para obter uma respose com <code>test::read_response(&amp;mut app, req).await</code> e convertemos esta response em um <code>TodoCard</code>, <code>let todo_card: TodoCard = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap()</code>. Como vamos mockar a resposta de <code>TodoCard</code> com o primeiro valor de <code>mock_get_todos</code>, basta comparar os dois com <code>assert_eq!(&amp;todo_card, mock_get_todos().get(0usize).unwrap())</code>.</p>
<p>O primeiro passo para resolver este teste é adicionar a rota a função <code>app_routes</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/routes.rs
// ...
pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                    .route(&quot;create&quot;, web::post().to(create_todo))
                    .route(&quot;index&quot;, web::get().to(show_all_todo))
                    .route(&quot;show/{id}&quot;, web::get().to(show_by_id)),
            )
            .service(
                web::scope(&quot;auth/&quot;)
                    .route(&quot;signup&quot;, web::post().to(signup_user))
                    .route(&quot;login&quot;, web::post().to(login))
                    .route(&quot;logout&quot;, web::delete().to(logout)),
            )
            .route(&quot;ping&quot;, web::get().to(pong))
            .route(&quot;~/ready&quot;, web::get().to(readiness))
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Para recebermos o ID como argumento de rota precisamos definir-lo como <code>{id}</code>, depois disso fazemos um <code>GET</code> redirecionando o request para o controller <code>show_by_id</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/todo.rs
// ...
pub async fn show_by_id(id: web::Path&lt;String&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    match get_todo_by_id(uuid, state.dynamo.clone()) {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::NotFound().finish()
        }
        Some(todo_id) =&gt; HttpResponse::Ok().content_type(&quot;application/json&quot;)
            .json(todo_id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Na função <code>show_by_id</code> vemos um ítem novo logo de cara, <code>web::Path&lt;String&gt;</code>, a função deste ítem é extrair o conteúdo dos argumentos presentes na url do request, ou seja, todas as chaves encontradas entres os símbolos <code>{</code> e <code>}</code>, no nosso caso <code>{id}</code>. Para o caso de um único argumento a estrutura de <code>web::Path</code> é como estamos utilizando, mas para o caso de mais argumentos se utiliza tuplas para definir a sequencia de argumentos, por exemplo <code>/api/show/{id}/task/{title}</code>, uma rota para obter o status de uma <code>task</code> de um <code>TodoCard</code> de <code>id</code> específico, obteriamos os valores com <code>web::Path&lt;(String,String)&gt;</code>. Valores diferentes de string podem ser passados desde que sejam serializáveis pelo serviço, por exemplo o código que escrevemos poderia substituir <code>String</code> por <code>Uuid</code>, caso fossemos utiliza-la:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_by_id(id: web::Path&lt;uuid::Uuid&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.into_inner().to_string();
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Não vamos utilizar o <code>web::Path</code> com <code>Uuid</code> pois, no futuro, vamos querer enviar um response <code>BadRequest</code> caso o campo <code>id</code> não seja um <code>Uuid</code>. Se deixassemos assim o response seria <code>InternalServerError</code>, que não é um status muito indicativo. Mantendo o <code>web::Path</code> como <code>String</code> passamos ao próximo ítem, uma funcnao de <code>todo_api/db/todo.rs</code> que recupera um <code>TodoCard</code> com base em seu <code>id</code>, <code>get_todo_by_id</code>. Os argumentos passados a <code>get_todo_by_id</code> são uma <code>String</code> contendo o <code>id</code> e o cliente para <code>dynamo</code>. Essa função retorna o tipo <code>Option&lt;TodoCard&gt;</code>, que para o padrão <code>None</code> vai retornar um status <code>NotFound</code>, indicando que este elemento não foi encontrado e para o caso <code>Some</code> vai retornar um <code>Ok</code> com um corpo contendo um Json com o valor do <code>TodoCard</code> encontrado.</p>
<p>A função <code>get_todo_by_id</code> é semelhante a função <code>get_todos</code>, mas com uma pequerna diferença, a struct <code>ScanInput</code> utilizanda para fazer a busca no banco possui dois campos extras <code>filter_expression</code> e <code>expression_attribute_values</code>. <code>filter_expression</code> é responsável por definir qual vai ser o filtro aplicado a este <code>scan</code>, por exemplo <code>=, &gt;=, &lt;</code>. No nosso caso, nossa <code>filter_expression</code> será <code>Some(&quot;id = :id&quot;.into())</code>, ou seja, vamos procurar um <code>id</code> que seja igual ao argumento <code>:id</code>. Poderiamos ter mais filtros em <code>filter_expression</code>, mas usaremos somente esse. Agora precisamos definir o argumento <code>:id</code> para aplicar em <code>filter_expression</code>. Este argumento é adicionado a query através de <code>expression_attribute_values</code>, que recebe um <code>HashMap</code> contendo o nome das chaves, <code>:id</code> no nosso caso, e um <code>AttributeValue</code> com a informação de <code>id</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use rusoto_dynamodb::{AttributeValue, DynamoDb};


let mut _map = HashMap::new();
let mut attr = AttributeValue::default();
attr.s = Some(id);
_map.insert(String::from(&quot;:id&quot;), attr);

let scan_item = ScanInput {
    // ...
    filter_expression: Some(&quot;id = :id&quot;.into()),
    expression_attribute_values: Some(_map),
    ..ScanInput::default()
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Filter Expression</strong></p>
<p>A lista de possíveis operadores para <code>filter_expression</code> é a seguinte:</p>
<ul>
<li>Funções: <code>attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size</code>, todas sensitivas a letras maísculas.</li>
<li>Operadores de comparação: <code>= | &lt;&gt; | &lt; | &gt; | &lt;= | &gt;= | BETWEEN | IN</code></li>
<li>Operadores lógicos: <code>AND | OR | NOT</code></li>
</ul>
</blockquote>
<p>Com a Struct <code>ScanInput</code> definida podemos executar a query em si com <code>client.scan(scan_item).sync()</code> e aplicar um <code>match</code> a resposta de <code>scan</code>. Existem dois padrões possíveis <code>Ok</code> e <code>Err</code>, como nosso controller espera um <code>Option&lt;TodoCard&gt;</code> retornamos um <code>None</code> no caso de <code>Err</code>. E no caso de <code>Ok</code> ainda temos que cuidar o caso de a resposta de <code>Ok</code> vir vazia:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.scan(scan_item).sync() {
    Ok(resp) =&gt; {
        let todo_id = adapter::scanoutput_to_todocards(resp);
        if todo_id.first().is_some() {
            debug!(&quot;Scanned {:?} todo cards&quot;, todo_id);
            Some(todo_id.first().unwrap().to_owned())
        } else {
            error!(&quot;Could find todocard with ID.&quot;);
            None
        }
    }
    Err(e) =&gt; {
        error!(&quot;Could not scan todocard due to error {:?}&quot;, e);
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Como a estrutura de <code>resp</code> é um <code>ScanOutput</code>, como em <code>get_todos</code>, podemos aplicar o mesmo adapter <code>adapter::scanoutput_to_todocards</code> a <code>resp</code>, porém a resposta deste adapter será um vetor de <code>TodoCard</code>. Como queremos somente um único elemento na resposta dessa query, aplicamos a função <code>first</code> e validamos o caso de ela não retornar <code>Some</code>, indicando com uma respostas <code>None</code>. Para o caso de retornar sim, retornamos um <code>Option</code> com o primeiro <code>TodoCard</code> com <code>Some(todo_id.first().unwrap().to_owned())</code>. A função completa ficou como a seguir, funcnao de teste esta logo depois retornando apenas <code>Some(TodoCard{...})</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn get_todo_by_id(id: String, client: DynamoDbClient) -&gt; Option&lt;TodoCard&gt; {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;:id&quot;), attr);

    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        filter_expression: Some(&quot;id = :id&quot;.into()),
        expression_attribute_values: Some(_map),
        ..ScanInput::default()
    };

    match client.scan(scan_item).sync() {
        Ok(resp) =&gt; {
            let todo_id = adapter::scanoutput_to_todocards(resp);
            if todo_id.first().is_some() {
                debug!(&quot;Scanned {:?} todo cards&quot;, todo_id);
                Some(todo_id.first().unwrap().to_owned())
            } else {
                error!(&quot;Could find todocard with ID.&quot;);
                None
            }
        }
        Err(e) =&gt; {
            error!(&quot;Could not scan todocard due to error {:?}&quot;, e);
            None
        }
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn get_todo_by_id(id: String, client: DynamoDbClient) -&gt; Option&lt;TodoCard&gt; {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;
    use crate::todo_api_web::model::todo::{State, Task};

    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;:id&quot;), attr);

    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        filter_expression: Some(&quot;id = :id&quot;.into()),
        expression_attribute_values: Some(_map),
        ..ScanInput::default()
    };

    Some(
        TodoCard {
            id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
            title: String::from(&quot;This is a card&quot;),
            description: String::from(&quot;This is the description of the card&quot;),
            owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
            tasks: vec![
                Task {
                    title: String::from(&quot;title 1&quot;),
                    is_done: true,
                },
                Task {
                    title: String::from(&quot;title 2&quot;),
                    is_done: true,
                },
                Task {
                    title: String::from(&quot;title 3&quot;),
                    is_done: false,
                },
            ],
            state: State::Doing,
        }
    )
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="validando-o-uuid"><a class="header" href="#validando-o-uuid">Validando o Uuid</a></h3>
<p>Nosso próximo passo é validar que o formato enviado é um <code>Uuid</code>. Para isso criaremos um teste que faz um request com um formato aleatório de dado e retorna <code>BadRequest</code> com a mesagem que &quot;id deve ser um Uuid&quot;.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_todo_card_without_uuid() {
    dotenv().ok();
    let mut app =
        test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

    let req = test::TestRequest::with_uri(&quot;/api/show/fake-uuid&quot;).to_request();
    let resp = test::read_response(&amp;mut app, req).await;

    let message = String::from_utf8(resp.to_vec()).unwrap();
    assert_eq!(&amp;message, &quot;Id must be a Uuid::V4&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver este teste a implementação de código é bastante simples, basta adicioanrmos um <code>if</code> que verifica se o <code>parse_str</code> é do tipo <code>Err</code> e em caso de <code>true</code> retornar <code>HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;)</code>. Assim, nossa função ficou da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_by_id(id: web::Path&lt;String&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    if uuid::Uuid::parse_str(&amp;uuid).is_err() {
        return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
    }

    match get_todo_by_id(uuid, state.dynamo.clone()) {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::NotFound().finish()
        }
        Some(todo_id) =&gt; HttpResponse::Ok().content_type(&quot;application/json&quot;)
            .json(todo_id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="atualizando-todocards"><a class="header" href="#atualizando-todocards">Atualizando TodoCards</a></h2>
<p>Agora vamos aprender como atualizar as informações de uma <code>TodoCard</code> no DynamoDB. Vamos focar em atualizar somente dois atributos <code>description</code> e <code>state</code>, depois discutiremos estratégias para implementar updates em <code>tasks</code>, pois os outros argumentos são essencialmente iguais a <code>description</code> e <code>state</code>. Agora precisamos definir como será nosso endpoint de atualização, para isso podemos definir sua rota como <code>/api/update/{id}</code> e responderá via método <code>PUT</code>. Assim, nosso body conterá os campos <code>state</code> e/ou <code>description</code>, como no exemplo de <code>put_todo.json</code>:</p>
<pre><code class="language-json">{
	&quot;state&quot;: &quot;Doing&quot;,
	&quot;description&quot;: &quot;dfwgferf&quot;
}
</code></pre>
<p>Um teste para esse cenário seria o seguinte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/test_api_web/controller.rs
// ...
#[cfg(test)]
mod update {
    use actix_web::{test, App, http::StatusCode};
    use dotenv::dotenv;
    use todo_server::todo_api_web::model::{
        http::Clients,
    };
    use todo_server::todo_api_web::routes::app_routes;
    use crate::helpers::{read_json};


    #[actix_rt::test]
    async fn test_todo_card_by_id() {
        dotenv().ok();
        let mut app =
            test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

        let req = test::TestRequest::put()
            .uri(&quot;/api/update/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;put_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        assert_eq!(resp.status(), StatusCode::OK);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="criando-a-rota"><a class="header" href="#criando-a-rota">Criando a Rota</a></h3>
<p>Temos nosso teste, mas agora precisamos criar a rota em <code>src/todo_api_web/routes.rs</code> seguindo o padrão <code>PUT</code> na rota <code>/api/update/{id}</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    todo::{create_todo, show_all_todo, show_by_id, update_todo},
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                    .route(&quot;create&quot;, web::post().to(create_todo))
                    .route(&quot;index&quot;, web::get().to(show_all_todo))
                    .route(&quot;show/{id}&quot;, web::get().to(show_by_id))
                    .route(&quot;update/{id}&quot;, web::put().to(update_todo)),
            )
            // ...
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, precisamos implementar o controller <code>update_todo</code> em <code>src/todo_api_web/controller/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn update_todo(
    id: web::Path&lt;String&gt;,
    info: web::Json&lt;TodoCardUpdate&gt;, 
    state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    if uuid::Uuid::parse_str(&amp;uuid).is_err() {
        return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
    }

    match update_todo_info(uuid, info.into_inner(), state.dynamo.clone()) {
        true =&gt; HttpResponse::Ok().finish(),
        false =&gt; HttpResponse::NotFound().finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Os argumentos para a função <code>update_todo</code> são <code>id</code> que vem da rota da url <code>{id}</code> com <code>web::Path&lt;String&gt;</code>, <code>info</code> que corresponde ao corpo do <code>PUT</code> do tipo <code>web::Json&lt;TodoCardUpdate&gt;</code> e o <code>state</code> que vem do estao da aplicação com <code>web::Data&lt;Clients&gt;</code>. Primeiro passo é converter o campo <code>id</code> em <code>String</code> com <code>to_string</code> para validar se essa string é um <code>Uuid</code> com <code>uuid::Uuid::parse_str(&amp;uuid)</code> e retornar um <code>HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;)</code> caso o resultado de <code>parse_str</code> seja do tipo <code>Err</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uuid = id.to_string();

if uuid::Uuid::parse_str(&amp;uuid).is_err() {
    return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois disso, chamamos a função <code>update_todo_info</code> que retorna um booleano para aplicarmos pattern matching em <code>true</code>, retornando <code>HttpResponse::Ok().finish()</code>, ou em <code>false</code>, retornando <code>HttpResponse::NotFound().finish()</code>. A função <code>update_todo_info</code> está localizada em <code>src/todo_api/db/todo.rs</code> e é bastante extensa:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn update_todo_info(id: String, info: TodoCardUpdate, client: DynamoDbClient) -&gt; bool {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let expression = adapter::update_expression(&amp;info);
    let attribute_values = adapter::expression_attribute_values(&amp;info);
    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;id&quot;), attr);

    let update = UpdateItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        key: _map,
        update_expression: expression,
        expression_attribute_values: attribute_values,
        ..UpdateItemInput::default()
    };

    match client.update_item(update).sync() {
        Ok(_) =&gt; true,
        Err(e) =&gt; {
            error!(&quot;failed due to {:?}&quot;, e);
            false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que precisamos ressaltar neste código é o <code>UpdateItemInput</code>, que é a struct responsável por executar a atualização da <code>todo</code> com o <code>id</code> enviado na rota. Os campos necessários são <code>table_name</code>, que é o nome da tabela, <code>key</code> que é um <code>AttributeValue</code> com todos os valores de <code>key</code>, no nosso caso é somente <code>id</code>, <code>update_expression</code> que define quais argumentos serão atualizados através do adapter <code>adapter::update_expression</code>, <code>expression_attribute_values</code> que contém os argumentos para atualizar as informações através do <code>adapter::expression_attribute_values</code> que transforma os valores de <code>TodoCardUpdate</code> em um <code>HashMap&lt;String, AttributeValue&gt;</code>. Assim, para transformar o <code>id</code> em um <code>HashMap&lt;String, AttributeValue&gt;</code> podemos utilizar a seguinte lógica:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut _map = HashMap::new();
let mut attr = AttributeValue::default();
attr.s = Some(id);
_map.insert(String::from(&quot;id&quot;), attr);
<span class="boring">}
</span></code></pre></pre>
<p>A função para executar a atualização no Dynamo é <code>update_item</code>, lembre-se que após o <code>sync</code> o resultado é do tipo <code>Result</code>, por isso do <code>match</code>. Já os adapter são os seguintes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
// ...
pub fn update_expression(info: &amp;TodoCardUpdate) -&gt; Option&lt;String&gt; {
    let data = info.clone();
    match (data.description, data.state) {
        (Some(_), Some(_)) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s&quot;)),
        (_, Some(_)) =&gt; Some(String::from(&quot;SET  state_db = :s&quot;)),
        (Some(_), _) =&gt; Some(String::from(&quot;SET description = :d&quot;)),
        _ =&gt; None
    }
}

pub fn expression_attribute_values(info: &amp;TodoCardUpdate) -&gt; Option&lt;HashMap&lt;String, AttributeValue&gt;&gt; {
    let data = info.clone();
    match (data.description, data.state) {
        (Some(desc), Some(state)) =&gt; {
            let mut _map = HashMap::new();
            let mut attr_d = AttributeValue::default();
            attr_d.s = Some(String::from(desc));
            let mut attr_s = AttributeValue::default();
            attr_s.s = Some(String::from(state.to_string()));
            _map.insert(String::from(&quot;:d&quot;), attr_d);
            _map.insert(String::from(&quot;:s&quot;), attr_s);
            Some(_map)
        },
        (_, Some(state)) =&gt; {
            let mut _map = HashMap::new();
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(state.to_string()));
            _map.insert(String::from(&quot;:s&quot;), attr);
            Some(_map)
        },
        (Some(desc), _) =&gt; {
            let mut _map = HashMap::new();
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(desc));
            _map.insert(String::from(&quot;:d&quot;), attr);
            Some(_map)
        },
        _ =&gt; None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>update_expression</code> é responsável pro criar a expressão que vai determinar o que será atualizado. Como recebemos 2 campos <code>Optional</code>, <code>description</code> e <code>state</code>, temos 4 possibilidades:</p>
<ol>
<li>Ambos existem retorna <code>&quot;SET description = :d, state_db = :s&quot;)</code>.</li>
<li>Somente <code>state</code> existe retorna <code>&quot;SET state_db = :s&quot;</code>.</li>
<li>Somente <code>description</code> existe retorna <code>&quot;SET description = :d&quot;</code>.</li>
<li>Nenhum retorna um <code>None</code>.</li>
</ol>
<p>Os testes para <code>update_expression</code> são os seguintes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod update_expression_test {
    use super::update_expression;
    use crate::todo_api_web::model::todo::{State, TodoCardUpdate};

    #[test]
    fn description_and_state() {
        let todo_update = TodoCardUpdate {description: Some(&quot;haiushdusd&quot;.to_string()), state: Some(State::Doing)};
        let expected = Some(String::from(&quot;SET description = :d, state_db = :s&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn description() {
        let todo_update = TodoCardUpdate {description: Some(&quot;haiushdusd&quot;.to_string()), state: None};
        let expected = Some(String::from(&quot;SET description = :d&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn state() {
        let todo_update = TodoCardUpdate {description: None, state: Some(State::Doing)};
        let expected = Some(String::from(&quot;SET state_db = :s&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn none() {
        let todo_update = TodoCardUpdate {description: None, state: None};
        let expected = None;

        assert_eq!(expected, update_expression(&amp;todo_update));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Já <code>expression_attribute_values</code> é um pouco mais complicada pois deve retornar um <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code>, mas as regras de pattern matching são as mesmas. Assim vamos entender o caso que existe tanto <code>description</code> quanto <code>state</code>. Para <code>update_expression</code> não nos interessava o conteúdo da expression, assim utilizavamos <code>Some(_)</code> para fazer pattern matching, porém em <code>expression_attribute_values</code> eles interessam já que será inseridos dentro do <code>HashMap</code>. A primeira cosia que devemos fazer é criar um <code>HashMap</code> com <code>let mut _map = HashMap::new();</code> e determinar os <code>AttributeValue</code> para <code>state</code> e para <code>description</code>, <code>let mut attr_s = AttributeValue::default();</code> e <code>let mut attr_d = AttributeValue::default();</code> respectivamente. Depois disso, inserimos o conteúdo de <code>state</code> e de <code>description</code> no campo <code>s</code>, de String, através de <code>attr_d.s</code>, <code>attr_s.s = Some(String::from(state.to_string()));</code> e <code>attr_d.s = Some(String::from(desc));</code>. Inserimos estes valores no mapa com <code>_map.insert(String::from(&quot;:d&quot;), attr_d); _map.insert(String::from(&quot;:s&quot;), attr_s);</code> e retornamos seu valor em <code>Some(_map)</code>. A função para teste é a seguinte: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dbtest&quot;)]
pub fn update_todo_info(id: String, info: TodoCardUpdate, client: DynamoDbClient) -&gt; bool {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let expression = adapter::update_expression(&amp;info);
    let attribute_values = adapter::expression_attribute_values(&amp;info);
    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;id&quot;), attr);

    let update = UpdateItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        key: _map,
        update_expression: expression,
        expression_attribute_values: attribute_values,
        ..UpdateItemInput::default()
    };

    true
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos entender como nosso código mudaria para incluir os outros campos de atualização.</p>
<h2 id="atualizando-outros-campos"><a class="header" href="#atualizando-outros-campos">Atualizando outros campos</a></h2>
<p>Considerando que a struct que temos no banco de dados é a seguinte e que o campo <code>id</code> não será atualizado, podemos discutir como adicionar <code>title</code>, <code>owner</code> e <code>tasks</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TodoCard {
    pub id: Option&lt;Uuid&gt;,
    pub title: String,
    pub description: String,
    pub owner: Uuid,
    pub tasks: Vec&lt;Task&gt;,
    pub state: State,
}
<span class="boring">}
</span></code></pre></pre>
<p>Bom, <code>title</code> e <code>owner</code> são bastante triviais, pois bastaria expandir nossos adapters para lidarem com mais duas strings, modificando nossa struct <code>TodoCardUpdate</code> para:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TodoCardUpdate {
    pub description: Option&lt;String&gt;,
    pub state: Option&lt;State&gt;,
    pub title: Option&lt;String&gt;,
    pub owner: Option&lt;Uuid&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Já o adapter <code>update_expression</code> ficaria semelhante ao seguinte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_expression(info: &amp;TodoCardUpdate) -&gt; Option&lt;String&gt; {
    let data = info.clone();
    match (data.description, data.state, data.title, data.owner) {
        (Some(_), Some(_), Some(_), Some(_)) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s, title = :t, owner = :o&quot;)),
        ...
        (Some(_), Some(_), _, _) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s&quot;)),
        (_, Some(_), Some(_), _) =&gt; Some(String::from(&quot;SET title = :t, state_db = :s&quot;)),
        (_, _, Some(_), Some(_)) =&gt; Some(String::from(&quot;SET title = :t, owner = :o&quot;)),
        (Some(_), _, _, Some(_)) =&gt; Some(String::from(&quot;SET description = :d, owner = :o&quot;)),
        ...
        (_, Some(_), _, _) =&gt; Some(String::from(&quot;SET  state_db = :s&quot;)),
        (Some(_), _, _, _) =&gt; Some(String::from(&quot;SET description = :d&quot;)),
        (_, _, Some(_), _) =&gt; Some(String::from(&quot;SET title = :t&quot;)),
        (_, _, _, Some(_)) =&gt; Some(String::from(&quot;SET owner = :o&quot;)),
        _ =&gt; None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Acredito que esta solução pode ficar um pouco verbosa, assim, uma ideia seria transformar esses 4 campos em um vetor e iterar nele de forma posicional, o que não geraria uma solução muito elegante também, mas seria muito útil para o caso de <code>expression_attribute_values</code>, como o <strong>pseudo código</strong> a seguir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// pseudo código
pub fn expression_attribute_values(info: &amp;TodoCardUpdate) -&gt; Option&lt;HashMap&lt;String, AttributeValue&gt;&gt; {
    let data = info.clone();
    let mut _map = HashMap::new();
    let data_vec = vec![data.description, data.state, data.title, data.owner];

    data_vec.iter()
        .map(|i| if i.is_some() {
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(i));
            attr
        } else {
            None
        })
        .enumerate(|(idx, item)| 
          match idx {
              0 =&gt; (&quot;:d&quot;.to_string(), item),
              1 =&gt; (&quot;:s&quot;.to_string(), item),
              2 =&gt; (&quot;:t&quot;.to_string(), item),
              3 =&gt; (&quot;:o&quot;.to_string(), item),
              _ =&gt; (&quot;&quot;.to_string(), None)
          })
        .fold(_map,|acc, i| 
          if i.is_some() {
              acc.insert(i.0, i.1)
          };
          acc);
        Some(_map)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tasks"><a class="header" href="#tasks">Tasks</a></h3>
<p>Agora precisamos discutir <code>tasks</code>, elas são mais complicadas pois não criamos o conceito de <code>id</code> nelas, assim a solução que eu creio ser mais simples para lidar com elas é criar uma struct que contém três argumentos <code>is_bool</code>, <code>previous_text</code>, <code>new_text</code>. O campo <code>is_bool</code> é equivalente ao da struct <code>Task</code>, já o argumento <code>previous_text</code> é o argumento que identifica qual o texto existente de <code>Task</code> no banco, e <code>new_text</code> é o texto que queremos atualizar. Para entender como ficaria a adição, a atualização e o remoção teremos o seguinte:</p>
<ul>
<li>Adicão: <code>previous_text = None</code>, <code>new_text = Some</code>.</li>
<li>Atualização: <code>previous_text = Some</code>, <code>new_text = Some</code>.</li>
<li>Remoção: <code>previous_text = Some</code>, <code>new_text = None</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskUpdate {
    pub is_bool: bool,
    pub previous_text: Option&lt;String&gt;,
    pub new_text: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Portanto, quando identificarmos que <code>previous_text</code> não existe, criamos uma nova <code>task</code>, e quando identificarmos que <code>new_text</code> não existe, deletamos a <code>task</code> com o texto da <code>previous_text</code>. Já a atualização filtramos todas as tasks que contém o <code>previous_text</code> com <code>new_text</code>, assim se ambos são iguais atualizamos somente <code>is_bool</code> e em caso de não existir uma task com <code>previous_text</code>, simplesmente criamos uma nova <code>new_text</code>. Isso poderia ser feito em endpoint que responde a um <code>POST</code> em <code>/api/update/{id}/tasks</code>. </p>
<p>Fica como um bom desafio fazer estas mudanças que discutimos aqui antes de seguir para a próxima parte, assim como criar um endpoint de <code>DELETE</code>. Nesta parte aprendemos a criar um serviço <code>REST</code> com actix que cria e gerencia tarefas via <code>create</code>, <code>update</code>, <code>show</code> e <code>index</code>, salvando estas informações em um DynamoDB. Além disso, criamos um middleware de autenticação e endpoints de autenticação, via diesel. Outros middlewares que utilizamos foi o <code>Logger</code>, que infelizmente não funciona com <code>dotenv</code>, necessária para o <code>Logger</code>, e um middleware que cria o header <code>x-request-id</code>. Aprendemos a gerenciar o estado da aplicação com <code>.data()</code> e a configurar rotas com <code>.configure()</code>. Por último, aprendemos a tornar nosso sistema tolerante a falhas e a configurar o docker com todas as dependências.</p>
<p>Agora vamos aprender a utilizar graphql com Actix para fazer um sistema de busca de rotas de voos.</p>
<p><a href="part-1/07-ci.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-1/part-2/00-capa.html">Próximo</a></p>
<h1 id="topo"><a class="header" href="#topo">Topo</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
