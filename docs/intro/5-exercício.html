<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Exercício Maior Produto de uma Série - Desenvolvimento Web em Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../0-capa.html">Capa</a></li><li class="chapter-item expanded affix "><a href="../intro/1-about.html">Sobre autora</a></li><li class="chapter-item expanded affix "><a href="../intro/2-Audience.html">Público alvo</a></li><li class="chapter-item expanded affix "><a href="../intro/3-book.html">Como o livro está organizado</a></li><li class="chapter-item expanded affix "><a href="../intro/4-setup.html">Instalando Rust</a></li><li class="chapter-item expanded affix "><a href="../intro/5-exercício.html" class="active">Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded affix "><a href="../part-1/00-capa.html">Parte 1</a></li><li class="chapter-item expanded affix "><a href="../part-1/01-ping-pong.html">Configurando os primeiros endpoints</a></li><li class="chapter-item expanded affix "><a href="../part-1/02-create.html">Criando Tarefas</a></li><li class="chapter-item expanded affix "><a href="../part-1/03-get.html">Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded affix "><a href="../part-1/04-serving.html">Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded affix "><a href="../part-1/05-auth.html">Autenticação</a></li><li class="chapter-item expanded affix "><a href="../part-1/06-middleware.html">Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded affix "><a href="../part-1/07-ci.html">Configurando um CI</a></li><li class="chapter-item expanded affix "><a href="../part-1/08-conclusao.html">Concluindo o serviço</a></li><li class="chapter-item expanded affix "><a href="../part-2/00-capa.html">Parte 2</a></li><li class="chapter-item expanded affix "><a href="../part-2/01-ping-gql.html">Configurando o GraphQL</a></li><li class="chapter-item expanded affix "><a href="../part-2/02-bestprices.html">Query Best Prices</a></li><li class="chapter-item expanded affix "><a href="../part-2/03-recommendations.html">Query Recommendations</a></li><li class="chapter-item expanded affix "><a href="../part-2/04-redis.html">Adicionando Caching com Redis</a></li><li class="chapter-item expanded affix "><a href="../part-3/00-capa.html">Parte 3</a></li><li class="chapter-item expanded affix "><a href="../part-3/01-setup.html">Setup de WebAssembly</a></li><li class="chapter-item expanded affix "><a href="../part-3/02-iniciando.html">Iniciando o projeto</a></li><li class="chapter-item expanded affix "><a href="../part-3/03-best-prices.html">Componente de Best Prices</a></li><li class="chapter-item expanded affix "><a href="../part-3/04-recommendations.html">Componente de Recomendações</a></li><li class="chapter-item expanded affix "><a href="../part-3/05-route.html">Aplicando um Router</a></li><li class="chapter-item expanded affix "><a href="../appendix.html">Appendix</a></li><li class="chapter-item expanded affix "><a href="../bibliografia.html">Bibliografia</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="exercício-maior-produto-de-uma-série"><a class="header" href="#exercício-maior-produto-de-uma-série">Exercício Maior Produto de uma Série</a></h1>
<p>Este exercício é retirado do site exercism.io da track de Rust, e em inglês é chamado de <em>Largest Series Product</em>. Ele consiste no seguinte problema:</p>
<blockquote>
<p>Dada uma string de dígitos, calcular o maior produto contínuo de uma substring de tamanho <code>n</code>. Por exemplo, para a string <code>&quot;1027839564&quot;</code> o maior produto com <code>n = 3</code> seria <code>9 * 5 * 6 = 270</code>, e o maior produto para <code>n = 5</code> seria <code>7 * 8 * 3 * 9 * 5 = 7560</code>.</p>
</blockquote>
<p>Você pode utilizar a ferramenta do exercism.io para realizar as configurações deste exercício. Para isso, pule para o subcapítulo <strong>Resolvendo o primeiro teste</strong>. Bom, a primeira coisa que precisamos fazer é criar uma lib para rodar esses testes. Para isso, executamos em nosso terminal <code>cargo new largest-series-product --lib &amp;&amp; cd largest-series-product</code>. Abra em seu editor favorito e seu projeto deverá ser da seguinte forma:</p>
<p><img src="../imagens/cargoproj.png" alt="Projeto de pacote básico do Cargo" /></p>
<p>Agora, precisamos criar uma pasta para conter todos os testes, a pasta <code>tests</code>. O padrão em Rust é que os testes de integração fiquem na pasta <code>tests</code> enquanto os testes unitários fiquem junto ao arquivo. Como o exercism já nos dispõe um conjunto bom de testes, podemos simplesmente colar eles no caminho <code>tests/largest-series-product.rs</code>. Os testes são:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use largest_series_product::*;

#[test]
fn return_is_a_result() {
    assert!(lsp(&quot;29&quot;, 2).is_ok());
}

#[test]
#[ignore]
fn find_the_largest_product_when_span_equals_length() {
    assert_eq!(Ok(18), lsp(&quot;29&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_two_with_numbers_in_order() {
    assert_eq!(Ok(72), lsp(&quot;0123456789&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_two_with_numbers_not_in_order() {
    assert_eq!(Ok(48), lsp(&quot;576802143&quot;, 2));
}

#[test]
#[ignore]
fn find_the_largest_product_of_three_with_numbers_in_order() {
    assert_eq!(Ok(504), lsp(&quot;0123456789&quot;, 3));
}

#[test]
#[ignore]
fn find_the_largest_product_of_three_with_numbers_not_in_order() {
    assert_eq!(Ok(270), lsp(&quot;1027839564&quot;, 3));
}

#[test]
#[ignore]
fn find_the_largest_product_of_five_with_numbers_in_order() {
    assert_eq!(Ok(15120), lsp(&quot;0123456789&quot;, 5));
}

#[test]
#[ignore]
fn span_of_six_in_a_large_number() {
    assert_eq!(
        Ok(23520),
        lsp(&quot;73167176531330624919225119674426574742355349194934&quot;, 6)
    );
}

#[test]
#[ignore]
fn returns_zero_if_number_is_zeros() {
    assert_eq!(Ok(0), lsp(&quot;0000&quot;, 2));
}

#[test]
#[ignore]
fn returns_zero_if_all_products_are_zero() {
    assert_eq!(Ok(0), lsp(&quot;99099&quot;, 3));
}

#[test]
#[ignore]
fn a_span_is_longer_than_number_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;123&quot;, 4));
}

// There may be some confusion about whether this should be 1 or error.
// The reasoning for it being 1 is this:
// There is one 0-character string contained in the empty string.
// That's the empty string itself.
// The empty product is 1 (the identity for multiplication).
// Therefore LSP('', 0) is 1.
// It's NOT the case that LSP('', 0) takes max of an empty list.
// So there is no error.
// Compare against LSP('123', 4):
// There are zero 4-character strings in '123'.
// So LSP('123', 4) really DOES take the max of an empty list.
// So LSP('123', 4) errors and LSP('', 0) does NOT.
#[test]
#[ignore]
fn an_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;&quot;, 0));
}

#[test]
#[ignore]
fn a_non_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;123&quot;, 0));
}

#[test]
#[ignore]
fn empty_string_and_non_zero_span_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;&quot;, 1));
}

#[test]
#[ignore]
fn a_string_with_non_digits_is_an_error() {
    assert_eq!(Err(Error::InvalidDigit('a')), lsp(&quot;1234a5&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos explicar rapidamente o que estamos vendo aqui. A primeira linha contém <code>use largest_series_product::*;</code>, isso corresponde a uma diretiva de importar todas as funcionalidades (<code>::*</code>) do pacote <code>largest_series_product</code>. Poderíamos importar somente a diretiva <code>lsp</code> com <code>use largest_series_product::lsp;</code> ou mais de uma diretiva com <code>use largest_series_product::{lsp, db::xps}</code>. Note que a diretiva <code>xps</code> vem de um pacote interno chamado <code>db</code>. Nas linhas seguintes, percebemos as anotações <code>#[test]</code> e <code>#[ignore]</code>, consideradas atributos que indicam como essa função deve se comportar. No caso do atributo <code>#[test]</code>, a função descrita a seguir executará somente com a execução de testes no <code>cargo test</code>, enquanto o atributo <code>#[ignore]</code>, pulará esse teste. Depois disso, temos a declaração de uma função com o seguinte formato:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nome_da_funcao_em_snake_case() {
    //corpo da funcnao
    // ...
}
 pub fn nome_da_funcao_em_snake_case(arg1: TArgs1, arg2: TArgs2, // ... argn: TArgsn) -&gt; TResposta {
     //corpo da funcnao
    // ...
 }
<span class="boring">}
</span></code></pre></pre>
<p>Em Rust, a declaração de uma função começa com a palavra-chave <code>fn</code> seguida pelo nome da função em snake_case. Caso existam, os argumentos são separados como <code>argumento: TipoDoArgument</code> e, caso a função retorne algum tipo, se adiciona a linha <code>-&gt; TipoDeRetorno</code>. A última linha da função, caso não tenha <code>;</code> no final é sempre retornada. Agora para o corpo da função de teste vemos <code>assert!(lsp(&quot;29&quot;, 2).is_ok());</code>. <code>assert!</code> e <code>assert_eq!</code> são macros de teste de assertividade, isso quer dizer que <code>assert!</code> retorna verdade caso o argumento dentro de seu corpo seja verdadeiro, como lsp de 29 e duas casas é do tipo <code>Ok</code> (<code>lsp(&quot;29&quot;, 2).is_ok()</code>), e <code>assert_eq!</code> recebe dois argumentos, separados por vírgula e procura igualdade e identidade entre eles.</p>
<h2 id="resolvendo-o-primeiro-teste"><a class="header" href="#resolvendo-o-primeiro-teste">Resolvendo o primeiro teste</a></h2>
<p>Vamos para a primeira função que temos e vamos tentar dissecá-la:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn return_is_a_result() {
   assert!(lsp(&quot;29&quot;, 2).is_ok());
}
<span class="boring">}
</span></code></pre></pre>
<p>Sabemos que é uma função de teste, <code>#[test]</code>, e que existe uma chamada para função <code>lsp</code> que recebe dois argumentos, <code>&quot;29&quot;</code> (um <code>&amp;str</code>) e <code>2</code> (um <code>inteiro</code>). Além disso, sabemos que retorna um tipo <code>Result</code>, pois estamos esperando um resultado do tipo <code>Ok</code>. Para este teste passar precisamos fazer muito pouco, assim a implementação dele passa a ser:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub enum Error {
    SpanTooLong,
    InvalidDigit(char),
}

pub fn lsp(_: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    Ok(0u64)
}
<span class="boring">}
</span></code></pre></pre>
<p>Tanto faz o valor que retornamos para esse teste, pois somente queremos saber se é <code>Ok()</code>. Agora removemos o <code>#[ignore]</code> do teste a seguir e mudamos nosso <code>Ok(0u64)</code> para <code>Ok(18u64)</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_when_span_equals_length() {
    assert_eq!(Ok(18), lsp(&quot;29&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>O próximo teste nos exige um pouco mais:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_two_with_numbers_in_order() {
    assert_eq!(Ok(72), lsp(&quot;0123456789&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para este teste podemos pegar os dois últimos números da string e multiplicá-los.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    let mut digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
    digits.reverse();
    Ok(digits.iter().take(2).fold(1u64, |acc, i| acc * i))
}
<span class="boring">}
</span></code></pre></pre>
<p>Como sabemos que os dois últimos dígitos de ambos os casos são o maior produto, não precisamos nos preocupar muito com o resto. Assim, aplicamos a função <code>split(&quot;&quot;)</code> ao valor de entrada, que gerará um vetor contendo cada um dos elementos, como <code>vec![&quot;2&quot;, &quot;9&quot;]</code>, para o caso do <code>&quot;29&quot;</code>. Depois aplicamos um <code>parse</code> deles para o tipo inferido em <code>let mut digits: Vec&lt;u64&gt; =</code>, filtramos para evitar elementos que resultaram em <code>Err</code> e assim podemos utilizar o <code>unwrap</code> sem problemas. Coletamos tudo com o <code>collect</code> e revertemos a lista para obter somente os dois primeiros elementos, que após o <code>reverse</code> passaram de últimos a primeiros. Depois aplicamos o <code>.fold(1u64, |acc, i| acc * i))</code>, que inicia a multiplicação com um <code>1u64</code>, e depois multiplicamos cada um deles pelo acumulador <code>acc</code>. Tudo isso envolvido em um <code>Ok()</code>. Existem formas mais simples de resolver esse problema em Rust, como o uso de <code>slices</code>, mas acredito que seja uma boa solução para quem precisa revisar a linguagem.</p>
<p>Ao rodarmos o próximo teste, podemos perceber que nossa estratégia falha e que novas implementações são necessárias:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_two_with_numbers_not_in_order() {
    assert_eq!(Ok(48), lsp(&quot;576802143&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Felizmente parte de nossa solução, a variável <code>digits</code>, já é bastante útil, pois converteu a <code>&amp;str</code> em um vetor de <code>u64</code>. Agora precisamos de uma função que atue sobre os vetores e agrupe-os de dois em dois. Para poupar nosso tempo, a implementacão de <code>Vec</code> em Rust já possui uma função assim, ela chama <code>window</code> e recebe como argumento um <code>self</code> e um span do tipo <code>usize</code>, retornando um <code>Window&lt;T&gt;</code>, no qual <code>T</code> representa um genérico correspondente ao tipo do vetor. A struct <code>Window&lt;T&gt;</code> corresponde a um iterável com valores internos do tipo slice com o tamanho de cada slice do valor span <code>usize</code>, se fossemos comparar a um vetor seria um <code>vec![ &amp;[&quot;a&quot;, &quot;b&quot;], &amp;[&quot;b&quot;, &quot;c&quot;], &amp;[&quot;c&quot;, &quot;d&quot;], // ...]</code> para o afaltabeto separado <code>2usize</code>. Agora, precisamos de uma função que nos retorne o valor de cada <code>Window</code> e ordene os valores de forma que o maior seja o primeiro ou o último. Chamei essa função de <code>window_values</code>, e ela recebe como argumento o vetor que criamos anteriormente, <code>digits: Vec&lt;u64&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, _: usize) -&gt; Result&lt;u64, Error&gt; {
    let digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
            
    Ok(window_values(digits)
        .first()
        .unwrap()
        .to_owned())
}

fn window_values(digits: Vec&lt;u64&gt;) -&gt; Vec&lt;u64&gt; {
    let mut window_values = digits
        .windows(2usize)
        .map(|w| w.to_vec())
        .map(|v| v.iter().fold(1,|acc, i| acc * i))
        .collect::&lt;Vec&lt;u64&gt;&gt;();
    window_values.sort();
    window_values.reverse();
    window_values
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que a função <code>lsp</code> não mudou muito, o que mudou nela é que chamamos a função <code>window_values</code> com o <code>digits</code>, que deixou de ser mutável. Na função <code>window_values</code>, estamos criando windows de tamanho <code>2usize</code>, depois aplicando <code>map</code> para converter o tipo <code>&amp;[T;usize]</code> em vetor e, no <code>map</code> seguinte, transformamos esse vetor gerado em um iterável que consome eles em um fold de multiplicação. Depois ordenamos a lista de maior para menor, e depois revertemos para termos o maior produto como primeiro elemento (podíamos deixar sem o reverse e aplicar um <code>last</code> em vez de <code>first</code> à solução da função). A chamada de função <code>to_owned</code> ocorre porque o resultado do first é um <em>borrow</em>, ou seja <code>&amp;u64</code> e precisamos de um <code>u64</code>.</p>
<p>O próximo teste inclui apenas uma diferença: o valor de <code>span</code> deixa de ser <code>2</code> e passa a ser <code>3</code>. Para isso, precisamos passar span como argumento para <code>window_values</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_three_with_numbers_in_order() {
    assert_eq!(Ok(504), lsp(&quot;0123456789&quot;, 3));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora a solução passa a ser (note o valor <code>span</code> adicionado nas funções):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}

fn window_values(digits: Vec&lt;u64&gt;, span: usize) -&gt; Vec&lt;u64&gt; {
    let mut str_chunks = digits
        .windows(span)
        .map(|x| x.to_vec())
        .map(|i| i.iter().fold(1,|acc, x| acc * x))
        .collect::&lt;Vec&lt;u64&gt;&gt;();
    str_chunks.sort();
    str_chunks.reverse();
    str_chunks
}
<span class="boring">}
</span></code></pre></pre>
<p>Com essas mudanças, os próximos três testes passam sem grandes esforços:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn find_the_largest_product_of_three_with_numbers_not_in_order() {
    assert_eq!(Ok(270), lsp(&quot;1027839564&quot;, 3));
}

#[test]
fn find_the_largest_product_of_five_with_numbers_in_order() {
    assert_eq!(Ok(15120), lsp(&quot;0123456789&quot;, 5));
}

#[test]
fn span_of_six_in_a_large_number() {
    assert_eq!(
        Ok(23520),
        lsp(&quot;73167176531330624919225119674426574742355349194934&quot;, 6)
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Os testes seguintes também passam, mas quis separá-los para chamar a atenção em relação aos <code>0</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn returns_zero_if_number_is_zeros() {
    assert_eq!(Ok(0), lsp(&quot;0000&quot;, 2));
}

#[test]
fn returns_zero_if_all_products_are_zero() {
    assert_eq!(Ok(0), lsp(&quot;99099&quot;, 3));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, o próximo teste já falha, pois apesar de termos a implementação do tipo <code>Error</code>, não estamos usando o <code>Error</code>. Note que o teste consiste em retornar um Result<Err> por conta do tamanho da <code>window</code> ser maior que o tamanho total das strings:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn a_span_is_longer_than_number_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;123&quot;, 4));
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos adicionar um <code>if</code> que valida se o tamanho da string é maior que o tamanho da <code>window</code>. <code>span &gt; string_digits.len()</code> e que caso verdadeiro retorne <code>Err(Error::SpanTooLong)</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Error {
    SpanTooLong,
    InvalidDigit(char),
}

pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }

    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Os próximos dois testes se referem à mesma coisa. Se o valor do <code>span</code> for zero, o resultado sempre será <code>Ok(1u64)</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn an_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;&quot;, 0));
}

#[test]
fn a_non_empty_string_and_no_span_returns_one() {
    assert_eq!(Ok(1), lsp(&quot;123&quot;, 0));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver esse teste basta adicionar mais um <code>if</code>, <code>if span == 0 { return Ok(1u64); }</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }

    let digits: Vec&lt;u64&gt; = string_digits
            .split(&quot;&quot;)
            .map(|s| s.parse())
            .filter(|s| match s {
                Ok(_) =&gt; true,
                Err(_) =&gt; false,
            })
            .map(|s| s.unwrap())
            .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, o teste seguinte também passa:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn empty_string_and_non_zero_span_is_an_error() {
    assert_eq!(Err(Error::SpanTooLong), lsp(&quot;&quot;, 1));
}
<span class="boring">}
</span></code></pre></pre>
<p>O próximo e último teste traz um novo conceito: falha por conta de um dígito não válido, como um caractere alfabético. Vamos incluir este caractere como argumento do erro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn a_string_with_non_digits_is_an_error() {
    assert_eq!(Err(Error::InvalidDigit('a')), lsp(&quot;1234a5&quot;, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver esse teste precisamos fazer um <code>match</code> por tipos alfabéticos e retornar o primeiro que falha. O <code>if</code> que garante que existe uma falha é <code>if string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;().len() &gt; 0</code> e assim bastaria adicionar o seguinte código a <code>lsp</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }
    else if string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;().len() &gt; 0 {
        let digit = string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;();
        return Err(Error::InvalidDigit(digit
                .first().unwrap()
                .to_owned()
                .to_string()
                .pop().unwrap()));
    }

    let digits: Vec&lt;u64&gt; = string_digits
        .split(&quot;&quot;)
        .map(|s| s.parse())
        .filter(|s| match s {
            Ok(_) =&gt; true,
            Err(_) =&gt; false,
        })
        .map(|s| s.unwrap())
        .collect();
            
    Ok(window_values(digits, span)
        .first()
        .unwrap()
        .to_owned())
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, com o resultado de <code>string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;()</code> podemos obter o primeiro com <code>first</code>, e depois aplicar o <code>pop</code> para retirar o valor de <code>char</code>. Além disso, podemos perceber que a conta <code>string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;()</code> está sendo executada duas vezes, assim podemos extrair para um valor, <code>v_alphanumeric</code>, antes dos ifs/elses:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn lsp(string_digits: &amp;str, span: usize) -&gt; Result&lt;u64, Error&gt; {
    let v_alphanumeric = string_digits.matches(char::is_alphabetic).collect::&lt;Vec&lt;&amp;str&gt;&gt;();
    if span &gt; string_digits.len() { return Err(Error::SpanTooLong); }
    else if span == 0 { return Ok(1u64); }
    else if v_alphanumeric.len() &gt; 0 {
        return Err(Error::InvalidDigit(v_alphanumeric
                .first().unwrap()
                .to_owned()
                .to_string()
                .pop().unwrap()));
    }
// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora que revisamos Rust podemos iniciar nosso primeiro serviço.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../intro/4-setup.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../part-1/00-capa.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../intro/4-setup.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../part-1/00-capa.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
