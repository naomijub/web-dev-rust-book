<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adicionando Caching com Redis - Desenvolvimento Web em Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro/1-about.html">Sobre autora</a></li><li class="chapter-item expanded affix "><a href="../intro/2-Audience.html">Público alvo</a></li><li class="chapter-item expanded affix "><a href="../intro/3-book.html">Como o livro está organizado</a></li><li class="chapter-item expanded affix "><a href="../intro/4-setup.html">Instalando Rust</a></li><li class="chapter-item expanded affix "><a href="../intro/5-exercício.html">Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded affix "><a href="../part-1/00-capa.html">Parte 1</a></li><li class="chapter-item expanded affix "><a href="../part-1/01-ping-pong.html">Configurando os primeiros endpoints</a></li><li class="chapter-item expanded affix "><a href="../part-1/02-create.html">Criando Tarefas</a></li><li class="chapter-item expanded affix "><a href="../part-1/03-get.html">Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded affix "><a href="../part-1/04-serving.html">Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded affix "><a href="../part-1/05-auth.html">Autenticação</a></li><li class="chapter-item expanded affix "><a href="../part-1/06-middleware.html">Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded affix "><a href="../part-1/07-ci.html">Configurando um CI</a></li><li class="chapter-item expanded affix "><a href="../part-1/08-conclusao.html">Concluindo o serviço</a></li><li class="chapter-item expanded affix "><a href="../part-2/00-capa.html">Parte 2</a></li><li class="chapter-item expanded affix "><a href="../part-2/01-ping-gql.html">Configurando o GraphQL</a></li><li class="chapter-item expanded affix "><a href="../part-2/02-bestprices.html">Query Best Prices</a></li><li class="chapter-item expanded affix "><a href="../part-2/03-recommendations.html">Query Recommendations</a></li><li class="chapter-item expanded affix "><a href="../part-2/04-redis.html" class="active">Adicionando Caching com Redis</a></li><li class="chapter-item expanded affix "><a href="../part-3/00-capa.html">Parte 3</a></li><li class="chapter-item expanded affix "><a href="../part-3/01-setup.html">Setup de WebAssembly</a></li><li class="chapter-item expanded affix "><a href="../part-3/02-iniciando.html">Iniciando o projeto</a></li><li class="chapter-item expanded affix "><a href="../part-3/03-best-prices.html">Componente de Best Prices</a></li><li class="chapter-item expanded affix "><a href="../part-3/04-recommendations.html">Componente de Recomendações</a></li><li class="chapter-item expanded affix "><a href="../part-3/05-route.html">Aplicando um Router</a></li><li class="chapter-item expanded affix "><a href="../appendix.html">Appendix</a></li><li class="chapter-item expanded affix "><a href="../bibliografia.html">Bibliografia</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="adicionando-caching-com-redis"><a class="header" href="#adicionando-caching-com-redis">Adicionando Caching com Redis</a></h1>
<p>Vamos utilizar como plataforma de caching o banco de dados <strong>Redis</strong> e para isso precisamos disponibilizar um container de redis. Podemos fazer isso adicionando o alvo <code>redis</code> em um Makefile. Esse Makefile vai conter um comando para executar o docker com <code>docker run -p 6379:6379 --name some-redis -d redis</code>. Inclusive podemos incluir um alvo para executar <code>cargo run</code>:</p>
<pre><code class="language-Makefile">redis:
	docker run -p 6379:6379 --name some-redis -d redis

run:
	cargo run

</code></pre>
<p>Se executarmos <code>make redis</code> vamos obter o seguinte output no terminal:</p>
<pre><code class="language-sh">docker run -p 6379:6379 --name some-redis -d redis
Unable to find image 'redis:latest' locally
latest: Pulling from library/redis
8559a31e96f4: Pull complete 
85a6a5c53ff0: Pull complete 
b69876b7abed: Pull complete 
a72d84b9df6a: Pull complete 
5ce7b314b19c: Pull complete 
04c4bfb0b023: Pull complete 
Digest: sha256:800f2587bf3376cb01e6307afe599ddce9439deafbd4fb8562829da96085c9c5
Status: Downloaded newer image for redis:latest
0190e745a049650ba4a594b2f379483729fb9b5f01b4b1f7467ef4641772e042
</code></pre>
<h2 id="disponibilizando-o-redis-client-para-as-queries"><a class="header" href="#disponibilizando-o-redis-client-para-as-queries">Disponibilizando o Redis Client para as Queries</a></h2>
<p>A primeira coisa que precisamos fazer é adicionar a crate <img src="https://github.com/mitsuhiko/redis-rs" alt="redis" /> ao seu <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
actix-web = &quot;2.0.0&quot;
actix-rt = &quot;1.0.0&quot;
juniper = &quot;0.14.2&quot;
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
chrono = &quot;0.4.11&quot;
reqwest = { version = &quot;0.10.4&quot;, features = [&quot;blocking&quot;, &quot;json&quot;] }
redis = &quot;0.16.0&quot;
</code></pre>
<p>Com isso podemos começar disponibilizando uma função que retorna o <code>redis::Client</code>. Na documentação vemos que basta executarmos <code>redis::Client::open(&quot;redis://127.0.0.1/&quot;)?</code> para obtermos o <code>Client</code>, mas por moticos de consistência de código criremos um módulo  <code>boundaries/redis.rs</code> que possuirá a função <code>redis_client</code> cujo tipo de retorno será um <code>RedisResult&lt;Client&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use redis::{Client,RedisResult};

pub fn redis_client() -&gt; RedisResult&lt;Client&gt; {
    Ok(redis::Client::open(&quot;redis://127.0.0.1/&quot;)?)
}
<span class="boring">}
</span></code></pre></pre>
<p>Com a função <code>redis_client</code> implementada podemos pensar em como vamos incluir o caching no nosso sistema. O local que eu acredito ser mais apropriado é em <code>resolvers/internal.rs</code>, pois é o estágio anterior a fazermos o request e funciona bem como um controller também. Assim, na função <code>recommendations_info</code> podemos criar a conexão do Redis com <code>let mut con = redis_client()?.get_connection()?</code>.  <code>con</code> é um tipo mutável pois as operações de <code>set</code> e <code>get</code>, adicionar e ler respectivamente, exigem mutabilidade. Além disso, para podermos utilizar <code>get</code> e <code>set</code> precisamos utilizar a diretiva <code>use redis::Commands;</code>. </p>
<p>Outro fato importante é definirmos como vamos querer criar essa estratégia de caching. Sabemos que a função <code>recommendations_info</code> recebe 3 argumentos, <code>departure, origin, destination</code>, então podemos concluir que estes argumentos são chaves para o caching, porém ainda precisamos definir uma estratégia de tempo. Como sei que as passagens não mudam muito de um dia pro outro, vamos utilizar a atual data como principal chave do caching. Podemos fazer isso utilizando a crate <code>chrono</code> e sua função <code>Utc::today().to_string()</code> que retorna uma data como <code>2020-06-18UTC</code>, e vamos salvar essa informação no valor <code>today</code>. Para compormos essas chaves podemos utilizar a seguinte declaração <code>let redis_key = format!(&quot;r{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);</code>, que combinado retorna <code>r2020-06-18UTC:2020-07-21:POA:GRU</code>, o <code>r</code> faz referência a <code>recommendations</code>.</p>
<p>Com <code>con</code> podemos chamar a função <code>get</code> com a <code>redis_key</code> e aplicar um <code>match</code> em seu resultado. Este <code>get</code> vai nos retornar um Result que caso seja <code>Ok</code> vai retornar o retorno o body do request <code>http</code> e caso seja <code>Err</code> precisaremos aplicar a função <code>set</code> com <code>set(&amp;redis_key, &amp;recommendations_text)</code>. Algo como:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match con.get(&amp;redis_key) {
    Ok(response) =&gt; response,
    Err(_) =&gt; {
        let _recommendations = recommendations(departure, origin, destination)?.text()?;
        let _: () = con.set(&amp;redis_key, &amp;_recommendations)?;
        _recommendations
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Assim, o resultado deste <code>match</code> agora pode ser utilizado em um <code>let recommendations_text = match ...</code> que será passado para a função <code>let recommendations: Recommendations = serde_json::from_str(&amp;recommendations_text)?</code> e retornar um <code>Ok(recommendations)</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::boundaries::{
    http_out::{best_prices, recommendations},
    redis::redis_client};
use crate::schema::{errors::GenericError, model::web::{best_prices::BestPrices, recommendations::Recommendations}};
use redis::Commands;
use chrono::Utc;

// ...

pub fn recommendations_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;Recommendations, GenericError&gt; {
    let mut con = redis_client()?.get_connection()?;
    let today = Utc::today().to_string();
    let redis_key = format!(&quot;r{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);

    let recommendations_text = match con.get(&amp;redis_key) {
        Ok(response) =&gt; response,
        Err(_) =&gt; {
            let _recommendations = recommendations(departure, origin, destination)?.text()?;
            let _: () = con.set(&amp;redis_key, &amp;_recommendations)?;
            _recommendations
        }
    };
    
    let recommendations: Recommendations = serde_json::from_str(&amp;recommendations_text)?;

    Ok(recommendations)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="aplicando-caching-a-best_prices"><a class="header" href="#aplicando-caching-a-best_prices">Aplicando Caching a <code>best_prices</code></a></h2>
<p>Agora para aplicarmos caching em <code>best_prices_info</code> podemos copiar a solução de <code>recommendations_info</code> modificando as funções para <code>best_prices</code> e definir a <code>redis_key</code> com a inicial <code>bp</code>, <code>let redis_key = format!(&quot;bp{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::boundaries::{
    http_out::{best_prices, recommendations},
    redis::redis_client};
use crate::schema::{errors::GenericError, model::web::{best_prices::BestPrices, recommendations::Recommendations}};
use redis::Commands;
use chrono::Utc;

pub fn best_prices_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;BestPrices, GenericError&gt; {
    let mut con = redis_client()?.get_connection()?;
    let today = Utc::today().to_string();
    let redis_key = format!(&quot;bp{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);

    let best_prices_text = match con.get(&amp;redis_key) {
        Ok(response) =&gt; response,
        Err(_) =&gt; {
            let _best_prices = best_prices(departure, origin, destination)?.text()?;
            let _: () = con.set(&amp;redis_key, &amp;_best_prices)?;
            _best_prices
        }
    };

    let best_prices: BestPrices = serde_json::from_str(&amp;best_prices_text)?;

    Ok(best_prices)
}

pub fn recommendations_info(
    departure: String,
    origin: String,
    destination: String,
) -&gt; Result&lt;Recommendations, GenericError&gt; {
    let mut con = redis_client()?.get_connection()?;
    let today = Utc::today().to_string();
    let redis_key = format!(&quot;r{}:{}:{}:{}&quot;, &amp;today, &amp;departure, &amp;origin, &amp;destination);

    let recommendations_text = match con.get(&amp;redis_key) {
        Ok(response) =&gt; response,
        Err(_) =&gt; {
            let _recommendations = recommendations(departure, origin, destination)?.text()?;
            let _: () = con.set(&amp;redis_key, &amp;_recommendations)?;
            _recommendations
        }
    };
    
    let recommendations: Recommendations = serde_json::from_str(&amp;recommendations_text)?;

    Ok(recommendations)
}
<span class="boring">}
</span></code></pre></pre>
<p>Em nossos exemplos fizemos caching de mesma data, mas é possível passar chaves que expiram com as funções <code>set_ex</code> que recebe a quantidade de segundos até expirar no formato <code>usize</code>, <code>pub fn set_ex&lt;'a, K: ToRedisArgs, V: ToRedisArgs&gt;(key: K, value: V, seconds: usize) -&gt; Self</code>, e a função <code>pset_ex</code> que faz a mesma coisa, mas com milisegundos, <code>pub fn pset_ex&lt;'a, K: ToRedisArgs, V: ToRedisArgs&gt;(key: K, value: V, milliseconds: usize) -&gt; Self</code>. Outras funcões interessantes de se olhar são <code>mset_nx</code>, <code>getset</code>, <code>getrange</code>, <code>setrange</code>, <code>persist</code>, <code>append</code>, outras funcões podem ser encontradas em https://docs.rs/redis/0.16.0/redis/struct.Cmd.html. </p>
<p>Nesta parte aprendemos a utilizar GraphQL com Actix, fazer requests HTTP síncronos e salvar essas informações como caching em uma banco de dados Redis. Com isso podemos começar um frontend com WebAssemby capaz de processar as informações do GraphQL em uma single page app que nos permitirá interagir com as passagens da Latam.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../part-2/03-recommendations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../part-3/00-capa.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../part-2/03-recommendations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../part-3/00-capa.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
