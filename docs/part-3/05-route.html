<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Aplicando um Router - Desenvolvimento Web em Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro/1-about.html">Sobre autora</a></li><li class="chapter-item expanded affix "><a href="../intro/2-Audience.html">Público alvo</a></li><li class="chapter-item expanded affix "><a href="../intro/3-book.html">Como o livro está organizado</a></li><li class="chapter-item expanded affix "><a href="../intro/4-setup.html">Instalando Rust</a></li><li class="chapter-item expanded affix "><a href="../intro/5-exercício.html">Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded affix "><a href="../part-1/00-capa.html">Parte 1</a></li><li class="chapter-item expanded affix "><a href="../part-1/01-ping-pong.html">Configurando os primeiros endpoints</a></li><li class="chapter-item expanded affix "><a href="../part-1/02-create.html">Criando Tarefas</a></li><li class="chapter-item expanded affix "><a href="../part-1/03-get.html">Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded affix "><a href="../part-1/04-serving.html">Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded affix "><a href="../part-1/05-auth.html">Autenticação</a></li><li class="chapter-item expanded affix "><a href="../part-1/06-middleware.html">Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded affix "><a href="../part-1/07-ci.html">Configurando um CI</a></li><li class="chapter-item expanded affix "><a href="../part-1/08-conclusao.html">Concluindo o serviço</a></li><li class="chapter-item expanded affix "><a href="../part-2/00-capa.html">Parte 2</a></li><li class="chapter-item expanded affix "><a href="../part-2/01-ping-gql.html">Configurando o GraphQL</a></li><li class="chapter-item expanded affix "><a href="../part-2/02-bestprices.html">Query Best Prices</a></li><li class="chapter-item expanded affix "><a href="../part-2/03-recommendations.html">Query Recommendations</a></li><li class="chapter-item expanded affix "><a href="../part-2/04-redis.html">Adicionando Caching com Redis</a></li><li class="chapter-item expanded affix "><a href="../part-3/00-capa.html">Parte 3</a></li><li class="chapter-item expanded affix "><a href="../part-3/01-setup.html">Setup de WebAssembly</a></li><li class="chapter-item expanded affix "><a href="../part-3/02-iniciando.html">Iniciando o projeto</a></li><li class="chapter-item expanded affix "><a href="../part-3/03-best-prices.html">Componente de Best Prices</a></li><li class="chapter-item expanded affix "><a href="../part-3/04-recommendations.html">Componente de Recomendações</a></li><li class="chapter-item expanded affix "><a href="../part-3/05-route.html" class="active">Aplicando um Router</a></li><li class="chapter-item expanded affix "><a href="../appendix.html">Appendix</a></li><li class="chapter-item expanded affix "><a href="../bibliografia.html">Bibliografia</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="aplicando-um-router"><a class="header" href="#aplicando-um-router">Aplicando um Router</a></h1>
<p>Neste capítulo vamos aprender a utilizar o <code>Router</code> da <code>YewStack</code>, pois <code>Routers</code> em <em>Single Page Apps</em> (SPA)manipulam a exibição de entidades diferentes, dependendo da <code>URL</code>. Em vez do comportamento padrão de solicitar um recurso remoto diferente quando um link é clicado, o roteador define a URL localmente para apontar para uma rota válida em seu aplicativo. O roteador detecta essa alteração e decide o que renderizar.</p>
<p>Vamos utilizar o <code>YewRouter</code>, adicionando <code>yew-router = &quot;0.13.0&quot;</code> ao <code>Cargo.toml</code>. o <code>YewRouter</code> possui alguns elementos centrais que valem mencionar:</p>
<ul>
<li><code>Route</code>: Contém uma <code>String</code> contendo tudo que aparece após o domínio na <code>URL</code>.</li>
<li><code>RouteService</code>: Comunica com o brrowser para receber e enviar as <code>Routes</code>.</li>
<li><code>RouteAgent</code>: Dono do <code>RouteService</code> e é usado para coordenar os updates quando as rotas mudam, tanto dentro da aplicação quanto por eventos do browser.</li>
<li><code>Switch</code>: É uma trait utilizada na conversão de <code>Route</code>.</li>
<li><code>Router</code>: O <code>Router</code> comunica com o <code>RouteAgent</code> e automaticamente resolve a <code>Route</code> que recebe do <code>RouteAgent</code> para uma das implementações do <code>Switch</code>.</li>
</ul>
<h2 id="explicando-como-funciona-o-router"><a class="header" href="#explicando-como-funciona-o-router">Explicando como funciona o Router</a></h2>
<p><code>Router</code> funciona de forma a aplicar um <em>pattern macthing</em> na url recebida pelo browser que instancia um tipo que implementa a trait <code>Switch</code> para a rota correspondente. Uma coisa importante de salientar é que utilizar tags de referência, <code>&lt;a href=...&gt;&lt;/a&gt;</code>, para a rota que você deseja não irá funcionar imediatamente e, no melhor cenário, irá fazer o servidor recarregar todo o bunde do App. No pior cenário, retorna apenas um código <code>404 - Not Found</code>, caso o serviço não esteja bem configurado. Assim,  utilizar <code>RouteService, RouteAgent, RouterButton, RouterLink</code> para definir a rota via <code>history.push_state()</code> modificará a rota, sem recarregar todo o App novamente.</p>
<p><strong>Configuração do Servidor</strong></p>
<p>Para que um link externo funcione com o App, o servidor precisa estar configurado para retornar o <code>index.html</code> para qualquer request <code>GET</code>, senão o retorno será sempre <code>404</code>. Além disso, não pode ser um redirecionamento <code>3xx</code> para o <code>index.html</code>, pois isso modificará a url no browser causando uma falha de roteamento. Assim, é preciso que a resposta seja um <code>200</code> que contém o <code>index.html</code>. Uma vez que o conteúdo de <code>index.html</code> carregar, resultando no carregamento de todos os assets para iniciar o App, que detectará a rota atual definindo o estado do App para o estado correspondente.</p>
<ol>
<li>O miserve que estamos utilizando já aponta para o diretório <code>static/</code> e para o índice  <code>index.html</code>, <code>miniserve ./static --index index.html</code>.</li>
<li>Se você quiser servir seu App do mesmo servidor que sua API está localizada, uma recomendação é definir a rota da API como <code>/api</code> e montar seus assets sob a rota <code>/</code> fazendo com que ela retorne o conteúdo de <code>index.html</code>.</li>
<li>É possivel também configurar o webpack dev server para apontar seus arquivos para <code>index.hmtl</code>. Mais informações em https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback.</li>
</ol>
<p>Neste livro vamos abordar s estratégias <code>1</code>, mas caso você prefira a estratégia <code>2</code>, poderiamos utilizar o serviço anterior, com a crate <code>actix-files = &quot;0.2.2&quot;</code>, para retornar nosso <code>index.html</code> executando um <code>GET</code> na rota <code>&quot;/&quot;</code>. O serviço fica configurado da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">use actix_files::NamedFile;
use actix_web::{get, middleware, web, App, Error, HttpResponse, HttpServer};

// Caminho para o diretório `static/`
const ASSETS_DIR: &amp;str = &quot;../../static&quot;;

async fn serve_index_html() -&gt; Result&lt;NamedFile, Error&gt; {
    const INDEX_HTML: &amp;str = &quot;index.html&quot;;
    let index_file = format!(&quot;{}/{}&quot;, ASSETS_DIR, INDEX_HTML);

    Ok(NamedFile::open(index_file)?)
}

#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    std::env::set_var(&quot;RUST_LOG&quot;, &quot;actix_server=info,actix_web=info&quot;);
    env_logger::init();

    let localhost: &amp;str = &quot;0.0.0.0&quot;;
    let port: u16 = 8000;
    let addr = (localhost, port);

    HttpServer::new(move || {
        App::new()
            .wrap(middleware::Logger::default())
            .service(actix_files::Files::new(&quot;/&quot;, ASSETS_DIR).index_file(&quot;index.html&quot;))
            .default_service(web::get().to(serve_index_html))
    })
    .bind(addr)?
    .workers(4)
    .run()
    .await
}
</code></pre></pre>
<h3 id="entendendo-as-rotas"><a class="header" href="#entendendo-as-rotas">Entendendo as Rotas</a></h3>
<p>Agora vamos entender um exemplo genérico de como configurar rotas, pois isto nos permitirá estender a lógica para o caso que vamos utilizar. A primeira coisa que precisamos fazer é definir um <code>enum</code> que seja responsável pelas rotas, no exemplo chamamos de <code>enum AppRoute</code>. Esse <code>enum</code> deve implementar a trait <code>Switch</code>, que vai correlacionar cada rota <code>to</code> a um elemente do <code>enum</code>, como o exemplo do <code>Index</code>. O exemplo do <code>AppRoute::Index</code> aponta para a rota <code>/</code> por conta da derivação <code>#[to = &quot;/&quot;]</code>, o mesmo vale para <code>Profile(u32)</code> que aponta para <code>#[to = &quot;/profile/{id}&quot;]</code>, na qual <code>{id}</code> é um valor do tipo <code>u32</code>. O caso de <code>Forum(ForumRoute),</code> é um pouco mais complicado, pois <code>ForumRoute</code> é uma sub rota associada a outro enum que implementa suas próprias rotas, mas seria possível deestrutura esses valores em uma  struct. Importante também salientar que o <em>pattern matching</em> ocorre de forma sequencial, então se <code>Index</code> fosse o primeiro, nenhuma das outras rotas aconteceria, pois todas as rotas seriam <code>&quot;/&quot;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Switch, Debug)]
pub enum AppRoute {
    #[to = &quot;/profile/{id}&quot;]
    Profile(u32),
    #[to = &quot;/forum{*:rest}&quot;]
    Forum(ForumRoute),
    #[to = &quot;/&quot;]
    Index,
}

#[derive(Switch, Debug)]
pub enum ForumRoute {
    #[to = &quot;/{subforum}/{thread_slug}&quot;]
    SubForumAndThread{subforum: String, thread_slug: String}
    #[to = &quot;/{subforum}&quot;]
    SubForum{subforum: String}
}

html! {
    &lt;Router&lt;AppRoute, ()&gt;
        render = Router::render(|switch: AppRoute| {
            match switch {
                AppRoute::Profile(id) =&gt; html!{&lt;ProfileComponent id = id/&gt;},
                AppRoute::Index =&gt; html!{&lt;IndexComponent/&gt;},
                AppRoute::Forum(forum_route) =&gt; html!{&lt;ForumComponent route = forum_route/&gt;},
            }
        })
    /&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Por último, a construção do <code>Router</code> se da através da tag <code>Router</code> que recebe como propridade <code>&lt;AppRoute, ()&gt;</code> e <code>render</code> que é a implementação da função <code>Router::render</code> no enum <code>AppRouter</code>.</p>
<h2 id="potencializando-o-componente-airline"><a class="header" href="#potencializando-o-componente-airline">Potencializando o componente <code>Airline</code></a></h2>
<p>A ideia agora é tornar nosso componente de <code>Airline</code> mais flexível para tirarmos maior proveito do <code>Router</code>, nesse sentido vamos lidar com as propriedades <code>departure, origin, destination</code> para no componente poder fazer queries customizadas. Para iniciarmos este processo, precisamos criar a <code>struct Props</code>, que conterá estes campos em <code>app.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Properties, Clone)]
pub struct Props {
    pub departure: String,
    pub origin: String,
    pub destination: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Note a presença da macro <code>Properties</code>, ela é quem nos permite tornar esses campos utilizáveis como propriedades do componente e o fato de que todas as propriedades são <code>pub</code> para poderem ser acessadas de fora durante a declaração do componente. Agora precisamos definir <code>Props</code> como o tipo <code>Properties</code> da trait <code>Component</code>, fazemos isso na implementação da trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Component for Airline {
    type Message = Msg;
    type Properties = Props;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Podemos seguir com o próximo passo que é salvar as propriedades no estado de <code>Airline</code>, que pode ser feito simplesmente adicionando os campos a struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Airline {
    // ...
    filter_cabin: String,
    departure: String,
    origin: String,
    destination: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta etapa nos obriga a salvar as propriedades no estado, podemos fazer isso na função <code>create</code> da trait <code>Component</code>, que agora terá o nome <code>props</code> para o argumento <code>Self::Properties</code>, que antes estava como <code>_: Self::Properties</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create(props: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {
    Airline {
        fetch: FetchService::new(),
        link: link,
        fetch_task: None,
        fetching: true,
        graphql_url: &quot;http://localhost:4000/graphql&quot;.to_string(),
        graphql_response: None,
        filter_cabin: String::from(&quot;Y&quot;),
        departure: props.departure,
        origin: props.origin,
        destination: props.destination
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta alteração nos permite passar como argumento para a função <code>fetch_gql</code>, chamada pela função <code>fetch_data</code>, os campos <code>departure, origin, destination</code>, que nos permitem flexibilizar o request para o servidor GraphQL. Em <code>fetch_data</code> a chama de <code>fetch_gql</code> passa a ser da sehguinte forma <code>let request = fetch_gql(self.departure.clone(), self.origin.clone(), self.destination.clone());</code>. Agora a implementação da função <code>fetch_gql</code> no módulo <code>gql</code> muda para comportar os novos argumentos:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fetch_gql(departure: String, origin: String, destination: String) -&gt; Value {
    json!({
        // ...
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Estes novos argumentos devem ser passados para a <code>query</code> através da chave <code>variables</code> que conterá um mapa na qual cada chave é o nome da variável que vamos passar para <code>query</code>. Além disso, na chave <code>query</code> agora devemos adicionar os argumentos de query, fazemos isso colocando <code>query($departure: String!, $origin: String!, $destination: String!)</code> antes da primeira chave de abertura, <code>{</code>. Perceba que o nome dos campos possui um <code>$</code> na frente, que nos permite definir como uma variável para utilizar dentro da <code>query</code>, como <code>recommendations(departure: $departure, origin: $origin, destination: $destination)</code>. O exemplo a seguir mostra como a modificação fica:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fetch_gql(departure: String, origin: String, destination: String) -&gt; Value {
    json!({
        &quot;variables&quot;: {
            &quot;departure&quot;: departure,
            &quot;origin&quot;: origin,
            &quot;destination&quot;: destination
        },
        &quot;query&quot;: &quot;query($departure: String!, $origin: String!, $destination: String!) {
                recommendations(departure: $departure, 
                    origin: $origin, 
                    destination: $destination) {
                    data{
                    // ...
                    }
                }
                bestPrices(departure: $departure, origin: $origin, destination: $destination) {
                    bestPrices {
                        date
                        available
                        price {amount}
                    }
                }
        }&quot;
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Para utilizamos esta nova <code>query</code>, precisamos passar <code>Props</code> como argumento em <code>run_app</code>, fazemos isso da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![recursion_limit=&quot;1024&quot;]
<span class="boring">fn main() {
</span>mod app;
mod gql;
mod best_prices;
mod reccomendation;

use wasm_bindgen::prelude::*;
use yew::prelude::App;
use app::Props;


#[wasm_bindgen(start)]
pub fn run_app() {
    App::&lt;app::Airline&gt;::new().mount_as_body_with_props(Props {
        origin: &quot;POA&quot;.to_string(),
        destination: &quot;GRU&quot;.to_string(),
        departure: &quot;2020-08-21&quot;.to_string(),
    });
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="criando-o-router"><a class="header" href="#criando-o-router">Criando o <code>Router</code></a></h2>
<p>Para começarmos o sistema de roteamento vamos precisar de um novo componente chamado <code>Model</code> que estará localizado no módulo <code>index</code>. Assim, a primeira coisa que vamos fazer é definir o <code>Model</code> e declarar as rotas no enum <code>AppRoutes</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use yew_router::Switch;
use yew::prelude::*;

#[derive(Switch, Debug, Clone)]
pub enum AppRoute {
    #[to = &quot;/oneway?departure={departure}&amp;origin={origin}&amp;destination={destination}&quot;]
    Oneway {departure: String, origin: String, destination: String},
    #[to = &quot;/&quot;]
    Index
}

#[derive(Debug)]
pub struct Model {}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso <code>AppRoute</code> possui duas rotas, a primeira é a rota inicial, que renderiza logo que acessamos <code>localhost:8080</code>, já a segunda é a rota que navegamos, uma vez que os parâmetros tenham sido definidos. Os parâmetros da rota <code>Oneway</code> são os mesmos da struct <code>Props</code>, e são definidos na declaração da opção. Note que a url possui o nome dos campos dentro de chaves, <code>/oneway?departure={departure}&amp;origin={origin}&amp;destination={destination}</code>, é dessa forma que a macro <code>Switch</code> consegue executar as substituições de valores. Precisamos adicioanr ao estado de <code>Model</code> os campos de <code>Oneway</code>, pois comente assim poderemos altera-los para executar a navegação entre rotas, para isso adicionamos os seguintes campos a <code>Model</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct Model {
    route_service: RouteService&lt;()&gt;,
    route: Route&lt;()&gt;,
    link: ComponentLink&lt;Self&gt;,
    origin: String,
    destination: String,
    departure: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Os campos <code>origin, destination, departure</code> já falamos sobre eles, mas adicionamos outros campos. <code>link</code> já mencionamos quando criamos os callbacks para <code>BestPrices</code>, mas <code>route</code> terá a função de receber uma das rotas que <code>AppRoute</code> define, que poderá ser utilizada em pattern matching depois e <code>route_service</code> serve para fazer a navegação entre as rotas. Além disso, precisamos da diretiva <code>use yew_router::{route::Route, service::RouteService, Switch}</code> para comportar os novos campos. Para começarmos a implementar a trait <code>Component</code> vamos precisar de um enum de mensagens, que também vamos chamar de <code>Msg</code> e conterá, inicialmente, dois campos:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Msg {
    RouteChanged(Route&lt;()&gt;),
    ChangeRoute(AppRoute),
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><code>RouteChanged</code> será responsável por avisar ao componente que a rota mudou, enquando <code>ChangeRoute</code> será responsável por efetivamente mudar a rota. Com isso, podemos iniciar a implementação da trait <code>Component</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Component for Model {
    type Message = Msg;
    type Properties = ();

    fn create(_: Self::Properties, link: ComponentLink&lt;Self&gt;) -&gt; Self {
        let mut route_service: RouteService&lt;()&gt; = RouteService::new();
        let route = route_service.get_route();
        let callback = link.callback(Msg::RouteChanged);
        route_service.register_callback(callback);

        Model {
            route_service,
            route,
            link,
            origin: String::new(),
            destination: String::new(),
            departure: String::new() 
        }
    }

    fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
        match msg {
            Msg::RouteChanged(route) =&gt; self.route = route,
            Msg::ChangeRoute(route) =&gt; {
                self.route = route.into();
                self.route_service.set_route(&amp;self.route.route, ());
            }
        }
        true
    }

    fn change(&amp;mut self, _: Self::Properties) -&gt; ShouldRender {
        false
    }

    fn view(&amp;self) -&gt; VNode {
        html! {
            &lt;div&gt;
                {
                    &quot;route&quot;
                }
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A função <code>create</code> começa um pouco diferente que o usual:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut route_service: RouteService&lt;()&gt; = RouteService::new();
let route = route_service.get_route();
let callback = link.callback(Msg::RouteChanged);
route_service.register_callback(callback);
<span class="boring">}
</span></code></pre></pre>
<p>Nela declaramos o <code>route_service</code> como um <code>RouteService::new()</code> e definimos a <code>route</code> como o atual estado de <code>route_service</code>, <code>route_service.get_route()</code>. Depois disso, criamos o <code>callback</code> que será chamado quando <code>Msg::RouteChanged</code> for enviada para <code>Model</code> e registramos esse <code>callback</code> em <code>route_service</code> com <code>route_service.register_callback(callback)</code>.</p>
<p>Nosso <code>update</code> vai fazer pattern matching nas duas mensagens, na qual <code>RouteChanged</code> atualiza <code>self.route</code> e <code>ChangeRoute</code> define a rota para navegar com <code>self.route_service.set_route(&amp;self.route.route, ())</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
    match msg {
        Msg::RouteChanged(route) =&gt; self.route = route,
        Msg::ChangeRoute(route) =&gt; {
            self.route = route.into();
            self.route_service.set_route(&amp;self.route.route, ());
        }
    }
    true
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="definindo-as-rotas-na-view"><a class="header" href="#definindo-as-rotas-na-view">Definindo as rotas na <code>view</code></a></h3>
<p>Agora podemos elaborar nossa <code>view</code> e para fazermos isso vamos applicar um <code>match</code> na rota, <code>self.route</code>, através a função <code>AppRoute::switch</code> que converte a <code>Route&lt;()&gt;</code> em um <code>Option&lt;AppRoute&gt;</code>. Para o caso <code>None</code>, retornamo <code>404</code> com <code>VNode::from(&quot;404&quot;)</code>, para o caso <code>Some(Index)</code> vamos apresentar a tela inicial para a pessoa inserir <code>origin, destination, departure</code>, para a Rota <code>Some(AppRoute::Oneway{departure, origin, destination})</code> vamos criar o componente <code>Airline</code> com as propriedades anteriores utilizando <code>html!{&lt;Airline departure = departure origin = origin destination = destination /&gt;},</code>. As propriedades são passadas no formato <code>propriedade = valor</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn view(&amp;self) -&gt; VNode {
    html! {
        &lt;div&gt;
            {
                match AppRoute::switch(self.route.clone()) {
                    Some(AppRoute::Index) =&gt; self.view_index(),
                    Some(AppRoute::Oneway{departure, origin, destination}) 
                        =&gt; html!{&lt;Airline departure = departure origin = origin destination = destination /&gt;},
                    None =&gt; VNode::from(&quot;404&quot;)
                }
            }
        &lt;/div&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora para a função <code>self.view_index()</code>. Ela deve ser implementada em um <code>impl Model</code> e conterá o HTML a ser exibido para a rota <code>Index</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Model {
    fn change_route(&amp;self, app_route: AppRoute) -&gt; Callback&lt;MouseEvent&gt; {
        self.link.callback(move |_| {
            let route = app_route.clone();
            Msg::ChangeRoute(route)
        })
    }

    fn view_index(&amp;self) -&gt; Html {
        html!{
            &lt;div class=&quot;index&quot;&gt;
                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Origin&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.origin,
                            oninput = self.link.callback(|e: InputData| Msg::UpdateOrigin(e.value)),
                        /&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Destination&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.destination,
                            oninput = self.link.callback(|e: InputData| Msg::UpdateDestination(e.value)),
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Departure&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.departure,
                            oninput = self.link.callback(|e: InputData| Msg::UpdateDeparture(e.value)),
                        /&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;input-cell submit&quot;&gt;
                        &lt;button onclick=&amp;self.change_route(AppRoute::Oneway
                            {departure: self.departure.clone(), 
                            origin: self.origin.clone(), 
                            destination: self.destination.clone()}) &gt; 
                            {&quot;Submit&quot;}
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A view está dividida basicamente uma tabela de duas linhas com dois elementos cada. Os 3 primeiro elementos são tags HTML para inserção de texto e farão isso para as propriedades <code>origin, destination, departure</code>. A estrutura é bastante simples, definimos o tipo do <code>input</code> como <code>type = &quot;text&quot;</code>, o valor, <code>value</code> como <code>&amp;self.&lt;propriedade&gt;</code> e a ação <code>oninput</code> como um <code>callback</code> para uma mensagem que definimos no padrão <code>Update&lt;Propriedade&gt;</code> que recebe o valor de <code>InputData</code>. A última célula da tabela é uma tag <code>button</code> com a ação de navegar para a nova rota. A ação é <code>onclick</code> e recebe a função <code>change_route</code> com uma rota <code>Oneway</code>.</p>
<blockquote>
<p>A mensagem de Update poderia receber um novo parâmetro como um enum que indicasse qual a propriedade e fazer um pattern matching interno.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Origin&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.origin,
                            oninput = self.link.callback(|e: InputData| Msg::Update(Prop::Origin, e.value)),
                        /&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Destination&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.destination,
                            oninput = self.link.callback(|e: InputData| Msg::Update(Prop:Destination, e.value)),
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;row&quot;&gt;
                    &lt;div class=&quot;input-cell&quot;&gt;
                        &lt;p&gt; {&quot;Departure&quot;} &lt;/p&gt;
                        &lt;input
                            type = &quot;text&quot;,
                            value = &amp;*self.departure,
                            oninput = self.link.callback(|e: InputData| Msg::Update(Prop::Departure, e.value)),
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p><code>change_route</code> tem uma execução bastante simples, pois define a nova rota através de <code>let route: AppRoute = app_route.clone();</code>, cria a mensagem <code>Msg::ChangeRoute</code> com a rota criada e atribui isso a um <code>callback</code>. Isso nos força a expandirmos <code>Msg</code> para os novos casos que descrevemos:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Msg {
    RouteChanged(Route&lt;()&gt;),
    ChangeRoute(AppRoute),
    UpdateOrigin(String),
    UpdateDestination(String),
    UpdateDeparture(String)
}
<span class="boring">}
</span></code></pre></pre>
<p>ou</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Prop {
    Origin,
    Destination,
    Departure
}

pub enum Msg {
    RouteChanged(Route&lt;()&gt;),
    ChangeRoute(AppRoute),
    Update(Prop, String)
}
<span class="boring">}
</span></code></pre></pre>
<p>E como última tarefa precisamos adicionar as novas mensagens a função <code>update</code>. Tanto <code>origin</code>, quanto <code>destination</code> limitei fracamente em três caracteres pois códigos IATAs possuem apenas três caracteres.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
    match msg {
        Msg::RouteChanged(route) =&gt; self.route = route,
        Msg::ChangeRoute(route) =&gt; {
            self.route = route.into();
            self.route_service.set_route(&amp;self.route.route, ());
        },
        Msg::UpdateOrigin(origin) =&gt; self.origin = origin[0..3].to_string(),
        Msg::UpdateDestination(destination) =&gt; self.destination = destination[0..3].to_string(),
        Msg::UpdateDeparture(departure) =&gt; self.departure = departure
    }
    true
}
<span class="boring">}
</span></code></pre></pre>
<p>Seguindo o uso de <code>Prop</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, msg: Self::Message) -&gt; ShouldRender {
    match msg {
        Msg::RouteChanged(route) =&gt; self.route = route,
        Msg::ChangeRoute(route) =&gt; {
            self.route = route.into();
            self.route_service.set_route(&amp;self.route.route, ());
        },
        Msg::Update(prop, value) =&gt; match prop {
            Prop::Origin =&gt; self.origin = value[0..3].to_string(),
            Prop::Destinationj =&gt; self.destination = value[0..3].to_string(),
            Prop::Departure =&gt; self.departure = value,
        }
    }
    true
}
<span class="boring">}
</span></code></pre></pre>
<p>Para finalizar o css utilizado em <code>view_index</code>:</p>
<pre><code class="language-css">
.index {
  display: table;
  height: 20%;
  width: auto;
  background-color: darkblue;
  color: wheat;
  transform: translate(150%, 20%);
}

.row {
  display: table-row;
}

.input-cell {
  display: table-cell;
  padding: 1rem;
}

.submit {
  vertical-align: middle;
  text-align: center;
}
</code></pre>
<p>E uma imagem com o resultado de <code>view_index</code> na rota <code>&quot;/&quot;</code>:</p>
<p><img src="../imagens/view_index.png" alt="View da rota &quot;/&quot;" /></p>
<p>Agora basta subir, no diretório do GraphQL, o Redis com <code>make redis</code>, subir o GraphQL com <code>make run</code> e subir, no diretório wasm, o wasm com <code>make run</code> adicionar suas rotas desejada e datas desejadas e procurar seu próximo voo em sua própria API.</p>
<p>Esta parte nos trouxe alguns conceitos de desenvolvimento front-end com Rust e Wasm, nos permitindo consultar a API que criamos na parte anterior. Aprendemos a criar um componente com a trait <code>COmponent1</code> que realiza um fetch logo no primeiro render da página, comunicando-se por mensagens que alteram o front-end entre um <code>loader</code> e os dados que queremos exibir. Aprendemos a navegar através de um <code>Router</code> e <code>Properties</code> de um componente ao outro e aprendemos a criar componentes the recebem <code>inputs</code> de valores textuais, assim como, componentes que tomam ações com vase em cliques, como o <code>button</code>. Além disso, para o serviço que criamos executar com nosso front-end local precisamos utilizar a crate <code>actix-cors</code> para configurar o <code>CORS</code> da API.</p>
<p>Na API que atendia ao front-end utilizamos a crate <code>juniper</code> para configurar o GraphQL em cima do <code>actix-web</code>, assim como a crate <code>reqwest</code> para realizar requests HTTP para uma API externa e utilizamos a crate <code>redis</code> para configurar a comunicação com um container Redis. Já no nosso outro serviço, aprendemos a configurar middlewares, como Logger, para o Actix, sistema de tolerância a falhas com <code>bastion/fort</code>, uuids, configurações de json com <code>serde</code>, configuramos um DynamoDB com a crate <code>rusoto</code>, assim como um <code>Postgres</code> com a crate <code>diesel</code>, utilizamos a crate <code>chrono</code> para gerenciar datas, fizemos sistemas de autenticação que utilizavam <code>jwt</code> e <code>bcrypt</code> para parsear tokens e senhas, além de  testes extensivos para estes cenários, tanto unitários quanto de integração. Vale mencionar também que configuramos um Travis-CI para este cenário. </p>
<p>Agora você já pode começar a investir em serviços e front-ends Rust para demonstrar seu poder e levar a palavra do Rust a diante.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../part-3/04-recommendations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../appendix.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../part-3/04-recommendations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../appendix.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
