<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Criando Tarefas - Desenvolvimento Web em Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li class="chapter-item expanded "><a href="../intro/1-about.html"><strong aria-hidden="true">2.</strong> Sobre autora</a></li><li class="chapter-item expanded "><a href="../intro/2-Audience.html"><strong aria-hidden="true">3.</strong> Público alvo</a></li><li class="chapter-item expanded "><a href="../intro/3-book.html"><strong aria-hidden="true">4.</strong> Como o livro está organizado</a></li><li class="chapter-item expanded "><a href="../intro/4-setup.html"><strong aria-hidden="true">5.</strong> Instalando Rust</a></li><li class="chapter-item expanded "><a href="../intro/5-exercício.html"><strong aria-hidden="true">6.</strong> Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded "><a href="../part-1/00-capa.html"><strong aria-hidden="true">7.</strong> Todo Server com Actix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-1/01-ping-pong.html"><strong aria-hidden="true">7.1.</strong> Configurando os primeiros endpoints</a></li><li class="chapter-item expanded "><a href="../part-1/02-create.html" class="active"><strong aria-hidden="true">7.2.</strong> Criando Tarefas</a></li><li class="chapter-item expanded "><a href="../part-1/03-get.html"><strong aria-hidden="true">7.3.</strong> Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded "><a href="../part-1/04-serving.html"><strong aria-hidden="true">7.4.</strong> Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded "><a href="../part-1/05-auth.html"><strong aria-hidden="true">7.5.</strong> Autenticação</a></li><li class="chapter-item expanded "><a href="../part-1/06-middleware.html"><strong aria-hidden="true">7.6.</strong> Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded "><a href="../part-1/07-ci.html"><strong aria-hidden="true">7.7.</strong> Configurando um CI</a></li><li class="chapter-item expanded "><a href="../part-1/08-conclusao.html"><strong aria-hidden="true">7.8.</strong> Concluindo o serviço</a></li></ol></li><li class="chapter-item expanded "><a href="../part-2/00-capa.html"><strong aria-hidden="true">8.</strong> GraphQL com Actix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-2/01-ping-gql.html"><strong aria-hidden="true">8.1.</strong> Configurando o GraphQL</a></li><li class="chapter-item expanded "><a href="../part-2/02-bestprices.html"><strong aria-hidden="true">8.2.</strong> Query Best Prices</a></li><li class="chapter-item expanded "><a href="../part-2/03-recommendations.html"><strong aria-hidden="true">8.3.</strong> Query Recommendations</a></li><li class="chapter-item expanded "><a href="../part-2/04-redis.html"><strong aria-hidden="true">8.4.</strong> Adicionando Caching com Redis</a></li></ol></li><li class="chapter-item expanded "><a href="../part-3/00-capa.html"><strong aria-hidden="true">9.</strong> Frontend com WebAssembly e YewStack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-3/01-setup.html"><strong aria-hidden="true">9.1.</strong> Setup de WebAssembly</a></li><li class="chapter-item expanded "><a href="../part-3/02-iniciando.html"><strong aria-hidden="true">9.2.</strong> Iniciando o projeto</a></li><li class="chapter-item expanded "><a href="../part-3/03-best-prices.html"><strong aria-hidden="true">9.3.</strong> Componente de Best Prices</a></li><li class="chapter-item expanded "><a href="../part-3/04-recommendations.html"><strong aria-hidden="true">9.4.</strong> Componente de Recomendações</a></li><li class="chapter-item expanded "><a href="../part-3/05-route.html"><strong aria-hidden="true">9.5.</strong> Aplicando um Router</a></li></ol></li><li class="chapter-item expanded "><a href="../appendix.html"><strong aria-hidden="true">10.</strong> Appendix</a></li><li class="chapter-item expanded "><a href="../bibliografia.html"><strong aria-hidden="true">11.</strong> Bibliografia</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="criando-tarefas"><a class="header" href="#criando-tarefas">Criando tarefas</a></h1>
<p>O primeiro passo para criar nossa tarefa será entender o que é uma tarefa. A ideia de uma tarefa é conter informações sobre ela e que outras pessoas do time tenham visibilidade do que se trata a tarefa. Assim vamos começar por modelar o domínio de entrada e saída. Usaremos a <code>struct</code> do Rust para modelar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Task {
    is_done: bool,
    title: String
}

enum State {
    Todo,
    Doing,
    Done,
}

struct TodoCard {
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;Task&gt;,
    state: State
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, nossa struct principal é a <code>TodoCard</code>, que possui os campos <code>String</code> <code>title</code> e <code>description</code>, correspondentes ao título da tarefa e a sua descrição. Depois disso, podemos ver que existe um campo do tipo <code>Uuid</code> (inclua a crate <code>uuid</code> com as <code>features</code> <code>serde</code> e <code>v4</code> ativadas em seu <code>Cargo.toml</code>), que é um <code>owner</code>, ou seja, a pessoa dona da tarefa. Cada tarefa possui um conjunto de subtarefas a fazer, que podem estar completas ou não. Essas subtarefas são chamadas de <code>Task</code>, e é uma struct que possui um título, <code>title</code>, e um estado booleano que chamamos de <code>is_done</code>. Em seguida temos o estado da tarefa no fluxo de cards, <code>state</code>, que corresponde ao enum <code>State</code>, com os campos <code>Todo</code>, <code>Doing</code> e <code>Done</code>. O primeiro passo do serviço será algo bastante simples, receber um <code>POST</code> JSON com o <code>TodoCard</code> e respondermos um <code>TodoCardId</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TodoCardId {
    id: Uuid
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Uuid</strong></p>
<p>A crate Uuid possui várias configurações, mas para o que vamos utilizar precisamos de compatibilidade com <code>Serde</code> e a versão 4. Serde para garantir que ela é serializável e desserializável para JSON, e versão 4, pois é o formato que vamos utilizar. Assim, essas configurações são adicionadas ao <code>[dependencies]</code> do <code>Cargo.toml</code> como <code>uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }</code>.</p>
</blockquote>
<p>Um exemplo de <code>POST</code> em json de uma <code>TodoCard</code> seria:</p>
<pre><code class="language-json">{
    &quot;title&quot;: &quot;This is a card&quot;,
    &quot;description&quot;: &quot;This is the description of the card&quot;,
    &quot;owner&quot;: &quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;,
    &quot;tasks&quot;: [
        {
            &quot;title&quot;: &quot;title 1&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 2&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 3&quot;,
            &quot;is_done&quot;: false
        }
    ],
    &quot;state&quot;: &quot;Doing&quot;
}
</code></pre>
<p>Agora que modelamos nosso <code>TodoCard</code> podemos começar sua implementação com testes.</p>
<h2 id="criando-o-primeiro-teste-de-todocard"><a class="header" href="#criando-o-primeiro-teste-de-todocard">Criando o primeiro teste de <code>TodoCard</code></a></h2>
<p>O novo teste envolve uma série de alterações no código, como criar um novo <code>scope</code> para rotas de <code>api</code>, enviar <code>payloads</code> e responder objetos JSON. Assim, a estratégia desse teste vai envolver enviar um <code>TodoCard</code> para ser criado e termos como resposta um JSON contendo o id desse <code>TodoCard</code>. Lembrando que agora que vamos manipular JSON, precisamos poder serializar e desserializar eles, e para isso devemos incluir a biblioteca <code>serde</code> no Cargo.toml:</p>
<pre><code class="language-toml">// ...
[dependencies]
actix-web = &quot;2.0&quot;
actix-rt = &quot;1.0&quot;
uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
num_cpus = &quot;1.0&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
actix-service = &quot;1.0.5&quot;
</code></pre>
<p>Assim, podemos escrever nosso teste sem conflito de dependências em <code>tests/todo_api_web/controller.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod create_todo {
    use todo_server::todo_api_web::{controller::todo::create_todo, model::todo::TodoIdResponse};

    use actix_web::{http::header::CONTENT_TYPE, test, web, App, body};
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        String::from(
            &quot;{
                \&quot;title\&quot;: \&quot;This is a card\&quot;,
                \&quot;description\&quot;: \&quot;This is the description of the card\&quot;,
                \&quot;owner\&quot;: \&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442\&quot;,
                \&quot;tasks\&quot;: [
                    {
                        \&quot;title\&quot;: \&quot;title 1\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 2\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 3\&quot;,
                        \&quot;is_done\&quot;: false
                    }
                ],
                \&quot;state\&quot;: \&quot;Doing\&quot;
            }&quot;,
        )
    }

    #[actix_web::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(App::new().service(create_todo)).await;

        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(post_todo().as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Duas características já se destacam, <code>controller::todo::create_todo</code> e <code>model::TodoIdResponse</code>, que correspondem ao recursos que de fato estão sendo testados. <code>TodoIdResponse</code> corresponde ao Json com o id de criação da <code>TodoCard</code>, sua definição é a seguinte:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct TodoIdResponse {
    id: Uuid,
}
<span class="boring">}
</span></code></pre></pre>
<p>Perceba que utilizamos as macros de <code>Serialize, Deserialize</code> para sua fácil conversão entre JSON e String. Além disso, <code>TodoIdResponse</code> possui um campo <code>id</code> que é do tipo <code>Uuid</code>, um <code>Uuid</code> do tipo <code>v4</code>, conforme definimos no <code>Cargo.toml</code>. Agora temos também o controller <code>create_todo</code>, que receberá um <code>POST</code> do tipo JSON, fará sua inserção no banco de dados e retornará seu id. Felizmente, para este primeiro momento, não precisamos fazer a inserção no banco, pois o teste espera somente um tipo de retorno <code>id</code>. </p>
<p>Outro ponto importante é o uso da biblioteca <code>use serde_json::from_str;</code>. Essa função em especial serve para converter uma <code>&amp;str</code> em uma das structs serializáveis, conforme a linha <code>let id: TodoIdResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();</code>. Note que como a função não sabe para qual struct deve converter a resposta <code>resp</code>, tivemos de definir seu tipo na declaração do valor id, <code>id: TodoIdResponse</code>. O JSON do <code>payload</code> do <code>POST</code> está definido como uma string na função auxiliar de teste <code>post_todo</code>.</p>
<p>A seguir possuímos a definição do teste e o uso do runtime do actix, seguidos da definição do <code>App</code>, que vamos utilizar para mockar o serviço e suas rotas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//definição do teste
#[actix_web::test]
async fn valid_todo_post() {
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Definição do App
let mut app = test::init_service(
    App::new().service(create_todo)
).await;
<span class="boring">}
</span></code></pre></pre>
<p>Note duas mudanças na definição do <code>App</code>: nossa rota possui um padrão diferente <code>/api/create</code> e o controller <code>create_todo</code> está sendo passado para um método <code>service()</code>. Outro detalhe é que estamos utilizando mais recursos na criação do request:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let req = test::TestRequest::post()
    .uri(&quot;/api/create&quot;)
    .insert_header((CONTENT_TYPE, ContentType::json()))
    .set_payload(post_todo().as_bytes().to_owned())
    .to_request();
<span class="boring">}
</span></code></pre></pre>
<p>Veja que <code>TestRequest</code> agora instancia um tipo <code>POST</code> antes de adicionar informações ao seu builder, <code>TestRequest::post()</code>. As duas outras mudanças são a adição das funções <code>header</code> e <code>set_payload</code>, <code>.header(&quot;Content-Type&quot;, ContentType::json()).set_payload(post_todo().as_bytes().to_owned())</code>. <code>header</code> define o tipo de conteúdo que estamos enviando e sua ausência nesse caso pode implicar em uma resposta com o status <code>400</code>. <code>set_payload</code> recebe um array de bytes com o conteúdo do <code>payload</code>, ou seja <code>post_todo</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp = test::call_service(&amp;mut app, req).await;
    let body = resp.into_body();
    let bytes = body::to_bytes(body).await.unwrap();
    let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
    assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
<span class="boring">}
</span></code></pre></pre>
<p>Depois podemos ler a resposta normalmente, <code>let resp = test::call_service(&amp;mut app, req).await;</code>, obter o body da response em bytes <code>let body = resp.into_body();let bytes = body::to_bytes(body).await.unwrap();</code> e transformar essa resposta em uma struct conhecida pelo serviço, <code>from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();</code>. O último passo é garantir que a resposta contendo o <code>TodoIdResponse</code> seja de fato um id válido e para isso utilizamos a macro <code>assert!</code> em <code>assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());</code>. Note a função auxiliar <code>get_id</code>, se nosso teste estivesse dentro do nosso módulo em vez de na pasta de testes de integração, seria possível anotar ela com <code>#[cfg(test)]</code> e economizar espaço no executável e tempo de compilação. Eu optei por deixá-la visível e testar o controller nos testes de integração, mas a escolha é sua:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TodoIdResponse {
    // #[cfg(test)]
    pub fn get_id(self) -&gt; String {
        format!(&quot;{}&quot;, self.id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementando-o-controller-do-teste-anterior"><a class="header" href="#implementando-o-controller-do-teste-anterior">Implementando o controller do teste anterior</a></h3>
<p>Agora, com o teste implementado, precisamos entender quais são as coisas que necessitamos implementar:</p>
<ol>
<li>Controller <code>create_todo</code>.</li>
<li>O controller recebe um Json do tipo <code>TodoCard</code> , que precisa ser deserializável com a macro <code>#[derive(Deserialize)]</code>.</li>
<li>Um struct <code>TodoIdResponse</code> que precisa ser serializável com <code>#[derive(Serialize)]</code>.</li>
</ol>
<p>Como os itens 2 e 3 já foram mencionados na seção anterior, vou mostrar como eles ficaram com as macros de serialização e desserialização. Além disso, inclui a macro de <code>Debug</code>, pois pode ser útil durante o desenvolvimento, se você achar necessário retirá-la no futuro pode ajudar a economizar espaço do binário.</p>
<ul>
<li>Para utilizar as macros de serde, lembre-se de incluir <code>#[macro_use] extern crate serde;</code> em <code>lib.rs</code> e em <code>main.rs</code> (versões mais antigas do Rust).</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/model/mod.rs
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug)]
struct Task {
    is_done: bool,
    title: String,
}

#[derive(Serialize, Deserialize, Debug)]
enum State {
    Todo,
    Doing,
    Done,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct TodoCard {
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;Task&gt;,
    state: State,
}

#[derive(Serialize, Deserialize)]
pub struct TodoIdResponse {
    id: Uuid,
}

impl TodoIdResponse {
    // #[cfg(test)]
    pub fn get_id(self) -&gt; String {
        format!(&quot;{}&quot;, self.id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para o item 1, <code>create_todo</code> controller, devemos novamente criar uma função <code>async</code>, que tem como tipo de resposta uma implementação da trait <code>Responder</code>, a <code>impl Responder</code>, como fizemos com <code>pong</code> e <code>readiness</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/todo.rs
use crate::todo_api_web::model::todo::TodoIdResponse;
use actix_web::{ http::header::ContentType, post, web, HttpResponse, Responder};
use uuid::Uuid;

#[post(&quot;/api/create&quot;)]
pub async fn create_todo(_payload: web::Payload) -&gt; impl Responder {
    let new_id = Uuid::new_v4();
    let str = serde_json::to_string(&amp;TodoIdResponse::new(new_id)).unwrap();
    HttpResponse::Created()
        .content_type(ContentType::json())
        .body(str)
}
<span class="boring">}
</span></code></pre></pre>
<p>As primeiras coisas que podemos perceber são a create de <code>Uuid</code> para gerar novos <code>uuids</code> com <code>Uuid::new_v4()</code>, e os tipos de entrada e de saída, <code>TodoCard, TodoIdResponse</code>, respectivamente. O actix possui uma forma interna de desserializar objetos JSON que é definido no módulo <code>web</code> com <code>web::Json&lt;T&gt;</code> e é em <code>T</code> que vamos incluir nossa struct <code>TodoCard</code>. Veja que o tipo de retorno <code>TodoIdResponse</code> está sendo serializado pelo <code>serde_json</code> e retornado ao <code>body</code>. Note também que adicionamos o header <code>Content-type</code> através da função <code>.content_type(ContentType::json())</code>. Assim já seria suficiente para nosso teste passar, mas se quisermos testar essa rota com um <code>curl</code> é preciso adicionar ao <code>App</code> de <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HttpServer::new(|| {
    App::new()
        .service(readiness)
        .service(ping)
        .service(create_todo)
        .default_service(web::to(|| HttpResponse::NotFound()))
})
<span class="boring">}
</span></code></pre></pre>
<h3 id="refatorando-as-rotas"><a class="header" href="#refatorando-as-rotas">Refatorando as rotas</a></h3>
<p>No nosso teste anterior, percebemos que nossas rotas da <code>main.rs</code> são desconectadas das rotas do teste (<code>tests/todo_api_web/controller</code>), pois iniciamos um servidor de teste (<code>test::init_service</code>) que pode possuir uma rota aleatória, já que iniciamos um novo <code>App</code> dentro dele. Assim, basta direcionarmos a rota a um controller correto e fazer o request ser direcionado para essa rota que tudo ocorrerá bem. Para resolver isso, a sugestão é refatorarmos o <code>App</code> de forma que suas rotas sejam configuradas em um único lugar e possam ser utilizadas tanto na <code>main.rs</code> quanto nos testes. Para isso, vamos refatorar nosso <code>main</code> para extrair todo o <code>web::scope</code> de forma que as configurações venham de um módulo de rotas. Assim, devemos criar um módulo de rotas em <code>src/todo_api_web/routes.rs</code> e adicionar o seguinte código:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web, HttpResponse};
use crate::todo_api_web::controller::{
    pong, readiness,
    todo::create_todo
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
                .service(
                    web::scope(&quot;api/&quot;)
                        .route(&quot;create&quot;, web::post().to(create_todo))
                )
                .route(&quot;ping&quot;, web::get().to(pong))
                .route(&quot;~/ready&quot;, web::get().to(readiness))
                .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound()))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Basicamente estamos extraindo todas as rotas para uma nova função que alterará o está do configuração do serviço dentro de  <code>App</code> com a função <code>config.service</code>. Isso impacta também nosso <code>main</code>, pois agora somente vamos precisar declarar a função <code>app_routes</code>:</p>
<pre><pre class="playground"><code class="language-rust">// main.rs
mod todo_api_web;
use todo_api_web::routes::app_routes;

use actix_web::{App, HttpServer};
use num_cpus;

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new().configure(app_routes) 
    })
    .workers(num_cpus::get() + 2)
    .bind((&quot;localhost&quot;, 4004))
    .unwrap()
    .run()
    .await
}
</code></pre></pre>
<p>Agora podemos fazer a mesma refatoração nos testes, <code>tests/todo_api_web/controller</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ping_readiness {
    use todo_server::todo_api_web::routes::app_routes;

    use actix_web::{body, http::StatusCode, test, web, App};

    #[actix_web::test]
    async fn test_ping_pong() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;

        let req = test::TestRequest::get().uri(&quot;/ping&quot;).to_request();
        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();

        assert_eq!(bytes, web::Bytes::from_static(b&quot;pong&quot;));
    }

    #[actix_web::test]
    async fn test_readiness() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
        let req = test::TestRequest::get().uri(&quot;/~/ready&quot;).to_request();
        let resp = test::call_service(&amp;mut app, req).await;

        assert_eq!(resp.status(), StatusCode::ACCEPTED);
    }
}

mod create_todo {
    use todo_server::todo_api_web::{controller::todo::create_todo, model::todo::TodoIdResponse};

    use actix_web::{body, http::header::CONTENT_TYPE, test, web, App};
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        String::from(
            &quot;{
                \&quot;title\&quot;: \&quot;This is a card\&quot;,
                \&quot;description\&quot;: \&quot;This is the description of the card\&quot;,
                \&quot;owner\&quot;: \&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442\&quot;,
                \&quot;tasks\&quot;: [
                    {
                        \&quot;title\&quot;: \&quot;title 1\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 2\&quot;,
                        \&quot;is_done\&quot;: true
                    },
                    {
                        \&quot;title\&quot;: \&quot;title 3\&quot;,
                        \&quot;is_done\&quot;: false
                    }
                ],
                \&quot;state\&quot;: \&quot;Doing\&quot;
            }&quot;,
        )
    }

    #[actix_web::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(App::new().service(create_todo)).await;

        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(post_todo().as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Com estas alterações podemos perceber que um teste falha ao executarmos <code>cargo test</code>, esse é o teste <code>test todo_api_web::controller::ping_readiness::test_readiness_ok</code>, que falha com um <code>404</code>. Isso se deve ao fato de que a rota que estamos enviando o request de <code>readiness</code> estava errada esse tempo todo, pois escrevemos <code>/readiness</code>, enquanto a rota real é <code>/~/ready</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get(&quot;/~/ready&quot;)]
pub async fn readiness() -&gt; impl Responder {
    let process = std::process::Command::new(&quot;sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&quot;echo hello&quot;)
        .output();
    match process {
        Ok(_) =&gt; HttpResponse::Accepted(),
        Err(_) =&gt; HttpResponse::InternalServerError(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso próximo passo é incluir nosso <code>TodoCard</code> em nossa base de dados.</p>
<h2 id="configurando-a-base-de-dados"><a class="header" href="#configurando-a-base-de-dados">Configurando a base de dados</a></h2>
<p>A base de dados que vamos utilizar agora é o DyanmoDB. O objetivo de utilizar essa base de dados é salvar as <code>TodoCards</code> para podermos buscá-las no futuro, assim o primeiro passo é configurar e modelar a base de dados para que nosso servidor a reconheça. A instância que vamos utilizar é derivada de um contêiner docker cuja imagem é <code>amazon/dynamodb-local</code> e pode ser executada com <code>docker run -p 8000:8000 amazon/dynamodb-local</code>. Observe que a porta que o DynamoDB está expondo é a <code>8000</code>. Eu gosto muito de utilizar Makefiles, pois eles facilitam a vida quando precisamos rodar vários comandos, especialmente em serviços diferentes. Assim, criei o seguinte Makefile para executar o DynamoDB:</p>
<pre><code class="language-sh">db:
	docker run -p 8000:8000 amazon/dynamodb-local

</code></pre>
<h3 id="escrevendo-no-banco-de-dados"><a class="header" href="#escrevendo-no-banco-de-dados">Escrevendo no banco de dados</a></h3>
<p>Como essa primeira feature envolve exploração, primeiro vou apresentar a lógica de como fazemos para depois escrever os testes e generalizações. O próximo passo para termos a lógica do banco de dados é criar um novo módulo em <code>lib.rs</code> (e no <code>main.rs</code>) chamado <code>todo_api</code>, que por sua vez possuirá o módulo <code>db</code>, que vai gerenciar todas as relações com o DynamoDB. Antes de seguir com o servidor em si, vou comentar a atual função <code>main</code> e substituir por outra simples que sera descrita posteriormente, que utiliza somente o módulo <code>todo_api</code> para executar a criação de uma <code>TodoCard</code> no banco de dados, depois disso podemos conectar as partes novamente.</p>
<p>Para podermos nos comunicar facilmente com o DynamoDB em Rust, existem a biblioteca oferecida pela AWS, chamada <code>aws-sdk-dynamodb</code>. Basta adicioná-las às dependências no <code>Cargo.toml</code>. (Atualmente a sdk Rust da AWS está em Developer Preview e não deve ser usada em produção).</p>
<pre><code class="language-toml">[dependencies]
actix-web = &quot;2.0&quot;
actix-rt = &quot;1.0&quot;
actix-http = &quot;1.0.1&quot;
uuid = { version = &quot;0.7&quot;, features = [&quot;serde&quot;, &quot;v4&quot;] }
serde = { version = &quot;1.0.104&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.44&quot;
serde_derive = &quot;1.0.104&quot;
num_cpus = &quot;1.0&quot;
aws-config = &quot;0.49.0&quot;
aws-sdk-dynamodb = &quot;0.19.0&quot;

[dev-dependencies]
bytes = &quot;0.5.3&quot;
actix-service = &quot;1.0.5&quot;
</code></pre>
<p>Com a biblioteca <code>aws-sdk-dynamodb</code> disponível, podemos começar a pensar em como nos comunicar com o DynamoDB. Podemos fazer isso adicionando um módulo <code>helpers</code> dentro de <code>todo_api/db</code> e criando uma função que retorna o cliente:</p>
<p>Nota: Para utilizar o dynamodb localmente, deve ser criado um arquivo de configuração contendo uma região e credenciais (que não precisam ser validas) da AWS em <code>~/.aws/config</code> contendo:</p>
<pre><code class="language-code">[profile localstack]
region=us-east-1
aws_access_key_id=AKIDLOCALSTACK
aws_secret_access_key=localstacksecret
</code></pre>
<p>Agora precisamos criar uma tabela, para nosso caso não vou utilizar uma migracão pois acredito que em um cenário real este banco de dados será configurado por outro serviço, algo mais próximo a um ambiente cloud. Assim, vamos criar a função <code>create_table</code> em <code>todo_api/db/helpers.rs</code>, que fará a configuração da tabela para nós:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::http::Uri;
use aws_sdk_dynamodb::{
    model::{
        AttributeDefinition, KeySchemaElement, KeyType, ProvisionedThroughput, ScalarAttributeType,
    },
    Client, Endpoint,
};

pub static TODO_CARD_TABLE: &amp;str = &quot;TODO_CARDS&quot;;

pub async fn create_table() {
    let config = aws_config::load_from_env().await;
    let dynamodb_local_config = aws_sdk_dynamodb::config::Builder::from(&amp;config)
        .endpoint_resolver(
            Endpoint::immutable(Uri::from_static(&quot;http://localhost:8000&quot;)),
        )
        .build();

    let client = Client::from_conf(dynamodb_local_config);

    let table_name = TODO_CARD_TABLE.to_string();
    let ad = AttributeDefinition::builder()
        .attribute_name(&quot;id&quot;)
        .attribute_type(ScalarAttributeType::S)
        .build();

    let ks = KeySchemaElement::builder()
        .attribute_name(&quot;id&quot;)
        .key_type(KeyType::Hash)
        .build();

    let pt = ProvisionedThroughput::builder()
        .read_capacity_units(1)
        .write_capacity_units(1)
        .build();

    match client
        .create_table()
        .table_name(table_name)
        .key_schema(ks)
        .attribute_definitions(ad)
        .provisioned_throughput(pt)
        .send()
        .await
    {
        Ok(output) =&gt; {
            println!(&quot;Output: {:?}&quot;, output);    
        }
        Err(error) =&gt; {
            println!(&quot;Error: {:?}&quot;, error);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para testar precisamos executar o comando <code>make db</code>. Iremos seguir a <a href="https://docs.aws.amazon.com/sdk-for-rust/latest/dg/dynamodb-local.html">documentação</a> do aws-sdk-rust para configurar o DynamoDB local. Em outro terminal, precisamos setar uma variavel de ambiente para a <code>aws-config</code> utilizar o profile <code>localstack</code> que adicionamos em <code>~/.aws/config</code>, para isso usamos <code>export AWS_PROFILE=localstack</code> (no osx ou linux). Depois atualizamos a main com o cdigo abaixo e executamos em seguida, no mesmo terminal aonde setamos a variavel de ambiente <code>AWS_PROFILE</code> executamos <code>cargo build &amp;&amp; cargo run</code>. </p>
<pre><pre class="playground"><code class="language-rust">// main.rs
use todo_api::db::helpers::create_table;

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    create_table();
}
</code></pre></pre>
<p>Executando esta sequência de comandos, recebemos o seguinte output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Output: CreateTableOutput CreateTableOutput {
	table_description: Some(TableDescription {
		attribute_definitions: Some([AttributeDefinition {
			attribute_name: Some(&quot;id&quot;),
			attribute_type: Some(S)
		}]),
		table_name: Some(&quot;TODO_CARDS&quot;),
		key_schema: Some([KeySchemaElement {
			attribute_name: Some(&quot;id&quot;),
			key_type: Some(Hash)
		}]),
		table_status: Some(Active),
		creation_date_time: Some(DateTime {
			seconds: 1665206254,
			subsecond_nanos: 461999893
		}),
		provisioned_throughput: Some(ProvisionedThroughputDescription {
			last_increase_date_time: Some(DateTime {
				seconds: 0,
				subsecond_nanos: 0
			}),
			last_decrease_date_time: Some(DateTime {
				seconds: 0,
				subsecond_nanos: 0
			}),
			number_of_decreases_today: Some(0),
			read_capacity_units: Some(1),
			write_capacity_units: Some(1)
		}),
		table_size_bytes: 0,
		item_count: 0,
		table_arn: Some(&quot;arn:aws:dynamodb:ddblocal:000000000000:table/TODO_CARDS&quot;),
		table_id: None,
		billing_mode_summary: None,
		local_secondary_indexes: None,
		global_secondary_indexes: None,
		stream_specification: None,
		latest_stream_label: None,
		latest_stream_arn: None,
		global_table_version: None,
		replicas: None,
		restore_summary: None,
		sse_description: None,
		archival_summary: None,
		table_class_summary: None
	})
}
<span class="boring">}
</span></code></pre></pre>
<p>Tabela criada! Mas se executarmos <code>cargo run</code> de novo, receberemos um erro dizendo que não é possível criar uma tabela que já existe:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Error: ServiceError {
	err: CreateTableError {
		kind: ResourceInUseException(ResourceInUseException {
			message: Some(&quot;Cannot create preexisting table&quot;)
		}),
		meta: Error {
			code: Some(&quot;ResourceInUseException&quot;),
			message: Some(&quot;Cannot create preexisting table&quot;),
			request_id: Some(&quot;543a624e-7f21-4dd2-80f2-520ae078152b&quot;),
			extras: {}
		}
	},
	raw: Response {
		inner: Response {
			status: 400,
			version: HTTP / 1.1,
			headers: {
				&quot;date&quot;: &quot;Sat, 08 Oct 2022 05:33:45 GMT&quot;,
				&quot;content-type&quot;: &quot;application/x-amz-json-1.0&quot;,
				&quot;x-amzn-requestid&quot;: &quot;543a624e-7f21-4dd2-80f2-520ae078152b&quot;,
				&quot;content-length&quot;: &quot;112&quot;,
				&quot;server&quot;: &quot;Jetty(9.4.48.v20220622)&quot;
			},
			body: SdkBody {
				inner: Once(Some(b &quot;{\&quot;__type\&quot;:\&quot;com.amazonaws.dynamodb.v20120810#ResourceInUseException\&quot;,\&quot;Message\&quot;:\&quot;Cannot create preexisting table\&quot;}&quot;)),
				retryable: true
			}
		},
		properties: SharedPropertyBag(Mutex {
			data: PropertyBag,
			poisoned: false,
			..
		})
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Para corrigir esse erro, sugiro modificar o método <code>create_table</code> para verificar se existem tabelas com a função <code>client.list_tables().send()</code>. Para isso, fazemos a seguinte modificação:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::http::Uri;
use aws_sdk_dynamodb::{
    model::{
        AttributeDefinition, KeySchemaElement, KeyType, ProvisionedThroughput, ScalarAttributeType,
    },
    Client, Endpoint
};

pub static TODO_CARD_TABLE: &amp;str = &quot;TODO_CARDS&quot;;

pub async fn create_table() {
    let config = aws_config::load_from_env().await;
    let dynamodb_local_config = aws_sdk_dynamodb::config::Builder::from(&amp;config)
        .endpoint_resolver(
            Endpoint::immutable(Uri::from_static(&quot;http://localhost:8000&quot;)),
        )
        .build();

    let client = Client::from_conf(dynamodb_local_config);

    match client.list_tables().send().await {
        Ok(list) =&gt; {
            match list.table_names {
                Some(table_vec) =&gt; {
                    if table_vec.len() &gt; 0 {
                        println!(&quot;Error: {:?}&quot;, &quot;Table already exists&quot;);
                    } else {
                        create_table_input(&amp;client).await
                    }
                }
                None =&gt; create_table_input(&amp;client).await,
            };
        }
        Err(_) =&gt; {
            create_table_input(&amp;client).await;
        }
    }
}

fn build_key_schema() -&gt; KeySchemaElement {
    KeySchemaElement::builder()
        .attribute_name(&quot;id&quot;)
        .key_type(KeyType::Hash)
        .build()
}

fn build_provisioned_throughput() -&gt; ProvisionedThroughput {
    ProvisionedThroughput::builder()
        .read_capacity_units(1)
        .write_capacity_units(1)
        .build()
}

fn build_attribute_definition() -&gt; AttributeDefinition {
    AttributeDefinition::builder()
        .attribute_name(&quot;id&quot;)
        .attribute_type(ScalarAttributeType::S)
        .build()
}

async fn create_table_input(client: &amp;Client) {
    let table_name = TODO_CARD_TABLE.to_string();
    let ad = build_attribute_definition();
    let ks = build_key_schema();
    let pt = build_provisioned_throughput();

    match client
        .create_table()
        .table_name(table_name)
        .key_schema(ks)
        .attribute_definitions(ad)
        .provisioned_throughput(pt)
        .send()
        .await
    {
        Ok(output) =&gt; {
            println!(&quot;Output: {:?}&quot;, output);
        }
        Err(error) =&gt; {
            println!(&quot;Error: {:?}&quot;, error);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que, quando verificamos as listas existentes na tabela, surgiram várias situações possíveis e para facilitar a criação da tabela, extraímos sua lógica para <code>create_table_input</code>. A primeira situação é <code>Err</code>, que possivelmente representa algum problema de listagem de tabelas na base, indicando ausência de tabelas, que nos permite criar tabelas. O segundo caso, dentro do <code>Ok</code> é um <code>None</code>, que pode significar os mais diversos problemas. Depois disso obtemos a listagem em <code>Some</code>, mas esta listagem pode estar vazia, sendo um caso para criar tabela, o <code>else</code>, e se a listagem for maior que zero, não criamos a tabela.</p>
<h3 id="inserindo-conteúdo-na-tabela"><a class="header" href="#inserindo-conteúdo-na-tabela">Inserindo conteúdo na tabela</a></h3>
<p>Para inserirmos a tabela, vamos precisar de uma struct de <code>rusoto_dynamo</code> chamada <code>PutItemInput</code>, que nos permitirá inserir o JSON que recebemos na tabela, porém o JSON que recebemos em <code>TodoCard</code> não possui o id do card. Para podermos utilizar o <code>PutItemInput</code> como definimos na tabela, vamos criar um <code>model</code> que possua um id.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/mod.rs
use rusoto_dynamodb::AttributeValue;
use std::collections::HashMap;
use uuid::Uuid;

#[derive(Debug, Clone)]
struct TaskDb {
    is_done: bool,
    title: String,
}

#[derive(Debug, Clone)]
enum StateDb {
    Todo,
    Doing,
    Done,
}

#[derive(Debug, Clone)]
pub struct TodoCardDb {
    id: Uuid,
    title: String,
    description: String,
    owner: Uuid,
    tasks: Vec&lt;TaskDb&gt;,
    state: StateDb,
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos criar uma função que permita transformar um <code>TodoCard</code> em um <code>TodoCardDb</code>, em <code>src/todo_api/model/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::model::{State, TodoCard};
use actix_web::web;

impl TodoCardDb {
    pub fn new(card: web::Json&lt;TodoCard&gt;) -&gt; Self {
        Self {
            id: Uuid::new_v4(),
            title: card.title.clone(),
            description: card.description.clone(),
            owner: card.owner,
            tasks: card
                .tasks
                .iter()
                .map(|t| TaskDb {
                    is_done: t.is_done,
                    title: t.title.clone(),
                })
                .collect::&lt;Vec&lt;TaskDb&gt;&gt;(),
            state: match card.state {
                State::Doing =&gt; StateDb::Doing,
                State::Done =&gt; StateDb::Done,
                State::Todo =&gt; StateDb::Todo,
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, podemos fazer nosso <code>controller</code> momentaneamente gerenciar todas as ações com o banco de dados:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use uuid::Uuid;
use crate::todo_api_web::model::{TodoCard, TodoIdResponse};
use crate::todo_api::model::{TodoCardDb};

pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = TodoCardDb::new(info);
    let client = get_client().await;
    match put_todo(&amp;client, todo_card).await {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(&quot;Failed to serialize todo card&quot;))
    }
}

/// A partir daqui vamos extrair logo mais
use aws_sdk_dynamodb::{Client};
use crate::{
    todo_api::db::helpers::{TODO_CARD_TABLE},
};
use super::helpers::get_client;

pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt;  Option&lt;uuid::Uuid&gt; {
    match client.put_item()
    .table_name(TODO_CARD_TABLE.to_string())
    .set_item(Some(todo_card.clone().into()))
    .send()
    .await {
        Ok(_) =&gt; {
            Some(todo_card.id)
        },
        Err(_) =&gt; {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que nosso controller ficou muito mais funcional agora. Ele recebe um JSON do tipo <code>TodoCard</code>, transforma esse JSON em um <code>TodoCardDb</code> e envia para a função <code>put_todo</code> inserir no banco de dados. Caso ocorra algum problema com a inserção fazemos pattern matching com o <code>None</code> e retornamos algo como <code>HttpResponse::BadRequest()</code> ou <code>HttpResponse::InternalServerError()</code>, mas caso o retorno seja um id em <code>Some</code>, retornamos um JSON contendo <code>TodoIdResponse</code>. Note que foi necessário adicionar a função <code>body</code> ao <code>HttpResponse::BadRequest()</code> para garantir que os dois pattern matchings tivessem o mesmo tipo de retorno <code>Response</code>, em vez de <code>ResponseBuilder</code>. </p>
<p>Se você estiver utilizando o <code>rust-analyzer</code> do rust, vai perceber que o <code>into</code> de <code>item: todo_card.clone().into(),</code> está destacado, isso se deve ao fato de que precisamos implementar a função <code>into</code> para o tipo <code>TodoCardDB</code> de forma que retorne <code>HashMap&lt;String, AttributeValue&gt;</code>. Para isso, utilizamos a declaração <code>impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb</code> com a seguinte implementação:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/mod.rs
use std::collections::HashMap;

impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb {
    fn into(self) -&gt; HashMap&lt;String, AttributeValue&gt; {
        let mut todo_card = HashMap::new();
        todo_card.insert(&quot;id&quot;.to_string(), val!(S =&gt; self.id.to_string()));
        todo_card.insert(&quot;title&quot;.to_string(), val!(S =&gt; self.title));
        todo_card.insert(&quot;description&quot;.to_string(), val!(S =&gt; self.description));
        todo_card.insert(&quot;owner&quot;.to_string(), val!(S =&gt; self.owner.to_string()));
        todo_card.insert(&quot;state&quot;.to_string(), val!(S =&gt; self.state.to_string()));
        todo_card.insert(&quot;tasks&quot;.to_string(), val!(L =&gt; task_to_db_val(self.tasks)));
        todo_card
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Se você está utilizando <code>rls</code> vai perceber que o <code>state.to_string()</code> e o <code>task_to_db_val</code> estão destacados como errados, assim como a macro <code>val!</code>. Vamos falar do <code>val!</code> logo, mas primeiro vamos entender como funciona a criação do tipo <code>AttributeValue</code> para ser inserido dentro do banco. A função <code>into</code> espera como retorno um tipo <code>HashMap&lt;String, AttributeValue&gt;</code>, no qual <code>AttributeValue</code> é uma struct com a seguinte estrutura:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AttributeValue {
    pub b: Option&lt;Bytes&gt;,
    pub bool: Option&lt;bool&gt;,
    pub bs: Option&lt;Vec&lt;Bytes&gt;&gt;,
    pub l: Option&lt;Vec&lt;AttributeValue&gt;&gt;,
    pub m: Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;,
    pub n: Option&lt;String&gt;,
    pub ns: Option&lt;Vec&lt;String&gt;&gt;,
    pub null: Option&lt;bool&gt;,
    pub s: Option&lt;String&gt;,
    pub ss: Option&lt;Vec&lt;String&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>AttributeValue</code></p>
<p>Os tipos <code>T</code> dentro do <code>Option&lt;T&gt;</code> são os tipos possíveis dentro do DynamoDB. Veja que alguns tipos são bem fáceis de perceber como <code>bool</code>, <code>Vec&lt;AttributeValue&gt;</code> e <code>HashMap&lt;String, AttributeValue&gt;</code>, isto é, um valor booleano, um vetor de atributos do dynamo e um mapa com keys strings e valores como atributos, respectivamente. Outros valores podem ser confusos, como as chaves <code>s</code>, <code>ss</code>, <code>n</code> e <code>ns</code>. As chaves dos tipos <code>b</code> e <code>bs</code> são para valores binários como <code>&quot;B&quot;: &quot;dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk&quot;</code>, além disso o tipo <code>n</code> serve para representar um tipo numérico, enquanto o tipo <code>s</code> serve para tipos String. Os tipos <code>ss</code> e <code>ns</code> são as versões vetores de <code>s</code> e de <code>n</code>, respectivamente.</p>
</blockquote>
<p>Para resovermos a falha de compilação em <code>state.to_string()</code> precisamos implementar a trait <code>std::fmt::Display</code> que nos permite transformar o valor de <code>state</code> em uma String:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl std::fmt::Display for StateDb {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, &quot;{:?}&quot;, self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos verificar a função <code>task_to_db_val</code>, cujo objetivo é transformar um vetor do tipo <code>TaskDb</code> em um vetor de <code>AttributeValue</code>. Essa transformação nos permite inserir as <code>tasks</code> como um único campo contendo um vetor de objetos, como se diria na linguagem JSON, <code>TaskDB</code>. A função <code>task_to_db_val</code> é bastante simples, pois recebe uma <code>tasks</code> do tipo <code>Vec&lt;TaskDb&gt;</code> e aplica um mapa sobre cada <code>TaskDb</code> para substituí-las por um <code>AttributeValue</code> da chave <code>m</code>, <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code>, e depois coleciona todos esses <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code> em um vetor <code>Vec&lt;AttributeValue&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn task_to_db_val(tasks: Vec&lt;TaskDb&gt;) -&gt; Vec&lt;AttributeValue&gt; {
    tasks
        .iter()
        .map(|t| {
            let mut tasks_hash = HashMap::new();
            tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; t.title.clone()));
            tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; t.is_done));
            val!(M =&gt; tasks_hash)
        })
        .collect::&lt;Vec&lt;AttributeValue&gt;&gt;()
}
<span class="boring">}
</span></code></pre></pre>
<p>Ainda falta falarmos da <code>val!</code>. <code>val!</code> é uma macro criada para transformar os valores de nossa struct em valores do DynamoDB. Inseri essa macro em um novo módulo chamado <code>adapter</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
#[macro_export]
macro_rules! val {
    (B =&gt; $bval:expr) =&gt; {{
        AttributeValue::Bool($bval)
    }};
    (L =&gt; $val:expr) =&gt; {{
        AttributeValue::L($val)
    }};
    (S =&gt; $val:expr) =&gt; {{
        AttributeValue::S($val)
    }};
    (M =&gt; $val:expr) =&gt; {{
        AttributeValue::M($val)
    }};
}
<span class="boring">}
</span></code></pre></pre>
<p>Para que essa macro esteja disponível dentro do módulo <code>todo_api</code>, precisamos utilizar <code>#[macro_use]</code> na declaração dos módulos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
pub mod adapter;
pub mod db;
pub mod model;
<span class="boring">}
</span></code></pre></pre>
<p>Agora tudo deve estar funcionando. Podemos executar <code>make db</code> e <code>cargo run</code> para fazer um <code>curl</code> em <code>http://localhost:4000/api/create</code> com o seguinte JSON:</p>
<pre><code class="language-json">{
	&quot;title&quot;: &quot;title&quot;,
	&quot;description&quot;: &quot;descrition&quot;,
	&quot;state&quot;: &quot;Done&quot;,
	&quot;owner&quot;: &quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;,
	&quot;tasks&quot;: [
        {
			&quot;is_done&quot;: true,
			&quot;title&quot;: &quot;blob&quot;
			
		}
    ]
}
</code></pre>
<p>E vamos receber um <code>Uuid</code> como resposta e o status <code>201</code>:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;ae1cb12c-6c67-4337-bd7b-b557d7568c60&quot;
}
</code></pre>
<h3 id="organizando-nosso-código"><a class="header" href="#organizando-nosso-código">Organizando nosso código</a></h3>
<p>Nosso controller possui um conjunto de códigos que não fazem sentido dentro do contexto de controller, no caso a função <code>put_todo</code>. A primeira coisa que vamos fazer é criar um módulo <code>todo</code> dentro de <code>todo_api/db</code> que conterá toda a lógica de banco de dados para o <code>todo</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::helpers::get_client;
use crate::todo_api::db::helpers::TODO_CARD_TABLE;
use aws_sdk_dynamodb::Client;

pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    match client
        .put_item()
        .table_name(TODO_CARD_TABLE.to_string())
        .set_item(Some(todo_card.clone().into()))
        .send()
        .await
    {
        Ok(_) =&gt; Some(todo_card.id),
        Err(_) =&gt; None,
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>E agora podemos simplificar muito nosso controller com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::db:: {helpers::get_client, todo::put_todo};
use crate::todo_api::model::TodoCardDb;
use crate::todo_api_web::model::todo::{TodoCard, TodoIdResponse};
use actix_web::{http::header::ContentType, post, web, HttpResponse, Responder};

#[post(&quot;/api/create&quot;)]
pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = TodoCardDb::new(info);
    let client = get_client().await;
    match put_todo(&amp;client, todo_card).await {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
        .content_type(ContentType::json())
            .body(
                serde_json::to_string(&amp;TodoIdResponse::new(id))
                    .expect(&quot;Failed to serialize todo card&quot;),
            ),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que para declarar todos os módulos internos utilizei o <code>use crate::{// ...}</code>, pois ajuda na organização. Além disso, na minha opinião, a função <code>new</code> de <code>TodoCardDb</code> é um adapter e pode estar mal localizada. Uma possível solução para isso seria mover e renomear a função <code>new</code> para o módulo adapter com nome de <code>todo_json_to_db</code>, mas isso implicaria em tornar todos os campos de <code>TodoCardDb</code> públicos, assim como de <code>TaskDb</code>. Por isso, essa parte da refatoração fica a seu critério de estilo, mas vou fazer para exemplificar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
// ...
use actix_web::web;
use uuid::Uuid;
use crate::{
    todo_api_web::model::{State, TodoCard},
    todo_api::model::{StateDb, TodoCardDb, TaskDb}
};

pub fn todo_json_to_db(card: web::Json&lt;TodoCard&gt;) -&gt; TodoCardDb {
    TodoCardDb {
        id: Uuid::new_v4(),
        title: card.title.clone(),
        description: card.description.clone(),
        owner: card.owner,
        tasks: card
            .tasks
            .iter()
            .map(|t| TaskDb {
                is_done: t.is_done,
                title: t.title.clone(),
            })
            .collect::&lt;Vec&lt;TaskDb&gt;&gt;(),
        state: match card.state {
            State::Doing =&gt; StateDb::Doing,
            State::Done =&gt; StateDb::Done,
            State::Todo =&gt; StateDb::Todo,
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A compilação falha pois <code>StateDB</code> e <code>TaskDB</code> são privados, assim como quase todos campos de <code>TodoCardDb</code>, para isso modificamos o módulo <code>todo_api/model</code> para:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[derive(Debug, Clone)]
pub struct TaskDb {
    pub is_done: bool,
    pub title: String,
}

#[derive(Debug, Clone)]
pub enum StateDb {
    Todo,
    Doing,
    Done,
}

#[derive(Debug, Clone)]
pub struct TodoCardDb {
    pub id: Uuid,
    pub title: String,
    pub description: String,
    pub owner: Uuid,
    pub tasks: Vec&lt;TaskDb&gt;,
    pub state: StateDb,
}

impl TodoCardDb {
    #[allow(dead_code)]
    pub fn get_id(self) -&gt; Uuid {
        self.id
    }
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Também precisamos mudar o controller para utilizar nossa nova função:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use crate::{
    todo_api::{
        db::todo::put_todo,
        adapter
    },
    todo_api_web::model::{TodoCard, TodoIdResponse}
};


pub async fn create_todo(info: web::Json&lt;TodoCard&gt;) -&gt; impl Responder {
    let todo_card = adapter::todo_json_to_db(info);

    match put_todo(todo_card) {
        None =&gt; HttpResponse::BadRequest().body(&quot;Failed to create todo card&quot;),
        Some(id) =&gt; HttpResponse::Created()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;TodoIdResponse::new(id)).expect(&quot;Failed to serialize todo card&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Uma última refatoração que podemos fazer é a função <code>task_to_db_val</code>, já que sua função é essencialmente transformar <code>TaskDb</code> em um tipo <code>AttributeValue</code>. Assim, podemos implementar uma função que faça isso com <code>TaskDb</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Into&lt;HashMap&lt;String, AttributeValue&gt;&gt; for TodoCardDb {
    fn into(self) -&gt; HashMap&lt;String, AttributeValue&gt; {
        let mut todo_card = HashMap::new();
        todo_card.insert(&quot;id&quot;.to_string(), val!(S =&gt; self.id.to_string()));
        todo_card.insert(&quot;title&quot;.to_string(), val!(S =&gt; self.title));
        todo_card.insert(&quot;description&quot;.to_string(), val!(S =&gt; self.description));
        todo_card.insert(&quot;owner&quot;.to_string(), val!(S =&gt; self.owner.to_string()));
        todo_card.insert(&quot;state&quot;.to_string(), val!(S =&gt; self.state.to_string()));
        todo_card.insert(&quot;tasks&quot;.to_string(), 
            val!(L =&gt; self.tasks.into_iter().map(|t| t.to_db_val()).collect::&lt;Vec&lt;AttributeValue&gt;&gt;()));
        todo_card
    }
}

impl TaskDb {
    fn to_db_val(self) -&gt; AttributeValue {
        let mut tasks_hash = HashMap::new();
            tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; self.title.clone()));
            tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; self.is_done));
            val!(M =&gt; tasks_hash)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora faltam alguns testes.</p>
<h2 id="aplicando-testes-a-nosso-endpoint"><a class="header" href="#aplicando-testes-a-nosso-endpoint">Aplicando testes a nosso endpoint</a></h2>
<p>Creio que uma boa abordagem agora seja começar pelos testes mais unitários, por isso vamos começar pelo adapter. Nosso primeiro teste será com a função <code>converts_json_to_db</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use std::collections::HashMap;

    use super::*;
    use crate::{
        todo_api::model::{StateDb, TaskDb, TodoCardDb},
        todo_api_web::model::todo::{State, Task, TodoCard},
    };
    use actix_web::web::Json;

    #[test]
    fn converts_json_to_db() {
        let id = uuid::Uuid::new_v4();
        let owner = uuid::Uuid::new_v4();
        let json = Json(TodoCard {
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: owner,
            state: State::Done,
            tasks: vec![Task {
                is_done: true,
                title: &quot;title&quot;.to_string(),
            }],
        });
        let expected = TodoCardDb {
            id: id,
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: owner,
            state: StateDb::Done,
            tasks: vec![TaskDb {
                is_done: true,
                title: &quot;title&quot;.to_string(),
            }],
        };
        assert_eq!(todo_json_to_db(json, id), expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que, para facilitar a testabilidade, mudamos a assinatura da função para receber um <code>id</code>, <code>todo_json_to_db(json, id)</code>. Isso se deve ao fato de que gerar id randomicamente não ajuda os testes e testar campo a campo não parece uma boa solução. Além disso, adicionamos a macro <code>PartialEq</code> nas structs <code>StateDb</code>, <code>TaskDb</code> e <code>TodoCardDb</code> para fins de comparabilidade. Agora precisamos testar a função <code>to_db_val</code> de <code>TaskDb</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn task_db_to_db_val() {
        let actual = TaskDb {
            title: &quot;blob&quot;.to_string(),
            is_done: true,
        }
        .to_db_val();
        let mut tasks_hash = HashMap::new();
        tasks_hash.insert(&quot;title&quot;.to_string(), val!(S =&gt; &quot;blob&quot;.to_string()));
        tasks_hash.insert(&quot;is_done&quot;.to_string(), val!(B =&gt; true));
        let expected = val!(M =&gt; tasks_hash);
        assert_eq!(actual, expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A lógica do teste <code>task_db_to_db_val</code> é basicamente a mesma que a implementação da função, mas já vale como um simples teste unitário. Agora podemos testar a função <code>into</code>, que também teria a mesma implementação da própria função, note que estamos utilizando apenas um id:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
    fn todo_card_db_to_db_val() {
        let id = uuid::Uuid::new_v4();
        let actual: HashMap&lt;String, AttributeValue&gt; = TodoCardDb {
            id: id,
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            owner: id,
            state: StateDb::Done,
            tasks: vec![TaskDb {
                is_done: true,
                title: &quot;title&quot;.to_string(),
            }],
        }
        .into();
        let mut expected = HashMap::new();
        expected.insert(&quot;id&quot;.to_string(), val!(S =&gt; id.to_string()));
        expected.insert(&quot;title&quot;.to_string(), val!(S =&gt; &quot;title&quot;.to_string()));
        expected.insert(
            &quot;description&quot;.to_string(),
            val!(S =&gt; &quot;description&quot;.to_string()),
        );
        expected.insert(&quot;owner&quot;.to_string(), val!(S =&gt; id.to_string()));
        expected.insert(&quot;state&quot;.to_string(), val!(S =&gt; StateDb::Done.to_string()));
        expected.insert(
            &quot;tasks&quot;.to_string(),
            val!(L =&gt; vec![TaskDb {is_done: true, title: &quot;title&quot;.to_string()}.to_db_val()]),
        );
        assert_eq!(actual, expected);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos <code>cargo test</code> enquanto o <code>make db</code> roda, teremos duas situações: uma em que a base de dados já está configurada e tudo ocorre normalmente e outra em que ela não está configurada e o teste falha. Para resolvermos esse problema, bastaria adicionar o <code>create_table</code> ao cenário de teste assim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> #[actix_web::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
<span class="boring">}
</span></code></pre></pre>
<p>É bem claro para mim que um teste que precisa executar o contêiner do banco de dados para passar é bastante frágil. Assim vamos precisar fazer algumas modificações para tornar o teste passável. A mudança que vamos fazer é, na minha opinião, uma forma mais elegante de fazer mocks em rust, pois ela não necessita criar uma trait e uma struct para mockar uma função específica, basta definirmos que para modo de compilação em test, <code>#[cfg(test)]</code>, a função terá outro comportamento, geralmente evitando efeitos colaterais com base de dados. Agora, o que vai mudar é que nosso teste de controller deixará de estar presente na pasta <code>tests</code> e passará a ser um módulo <code>#[cfg(test)]</code> junto ao controller:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod create_todo {
    use crate::todo_api_web::{
        model::TodoIdResponse,
        routes::app_routes
    };

    use actix_web::{
        test, App,
    };
    use serde_json::from_str;

    fn post_todo() -&gt; String {
        // ...
    }

     #[actix_web::test]
    async fn valid_todo_post() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, agora precisamos fazer com que nossa interação com o banco de dados seja &quot;mockada&quot;, para isso reescrevi o módulo <code>src/todo_api/db/todo.rs</code> para conter duas formas de compilacão &quot;com testes&quot; e  &quot;sem testes&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
#[cfg(not(test))]
pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    use crate::todo_api::db::helpers::TODO_CARD_TABLE;

    match client
        .put_item()
        .table_name(TODO_CARD_TABLE.to_string())
        .set_item(Some(todo_card.clone().into()))
        .send()
        .await
    {
        Ok(_) =&gt; Some(todo_card.id),
        Err(e) =&gt; {
            println!(&quot;{:?}&quot;, e);
            None
        }
    }
}

#[cfg(test)]
pub async fn put_todo(_client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    Some(todo_card.id)
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que <code>put_todo</code> com <code>cfg(test)</code> ativado pula a etapa <code>match client.put_item().table_name(TODO_CARD_TABLE.to_string()).set_item(Some(todo_card.clone().into())).send().await</code> e simplesmente retorna  um <code>Option&lt;Uuid&gt;</code>. </p>
<p>Outro modo de fazer esse teste, utilizando <code>cfg</code>, é utilizar <code>features</code>, mas por ser um pouco mais sensível deixei para apresentar depois. Neste repositório, vamos utilizar <code>features</code> para testar os controllers, o que deixará o código mais limpo, porém mais difícil de gerenciar, podendo fazer com que uma feature indesejada suba para a produção. Assim, recomendo fortemente que os builds de produção utilizem a flag <code>--release</code> e que os <code>cfg</code> mapeie corretamente isso. Para utilizar essa feature, uma boa prática é adicioná-la ao campo <code>[features]</code> do <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;todo-server&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Julia Naomi &lt;jnboeira@outlook.com&gt;&quot;]
edition = &quot;2018&quot;

[features]
dynamo = []

// ...
</code></pre>
<p>Além disso, precisamos gerar a nova função, muito semelhante ao <code>cfg(test)</code> de antes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::model::TodoCardDb;
use aws_sdk_dynamodb::Client;

#[cfg(feature = &quot;dynamo&quot;)]
pub async fn put_todo(client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    use crate::todo_api::db::helpers::TODO_CARD_TABLE;

    match client
        .put_item()
        .table_name(TODO_CARD_TABLE.to_string())
        .set_item(Some(todo_card.clone().into()))
        .send()
        .await
    {
        Ok(_) =&gt; Some(todo_card.id),
        Err(e) =&gt; {
            println!(&quot;{:?}&quot;, e);
            None
        }
    }
}

#[cfg(not(feature = &quot;dynamo&quot;))]
pub async fn put_todo(_client: &amp;Client, todo_card: TodoCardDb) -&gt; Option&lt;uuid::Uuid&gt; {
    Some(todo_card.id)
}
<span class="boring">}
</span></code></pre></pre>
<p>E movemos novamente nosso teste para a pasta <code>tests</code>. Para executar todos os testes corretamente usamos <code>cargo teste --features &quot;dynamo&quot;</code>, é sempre bom adicionar este comando a um Makefile.</p>
<pre><code class="language-sh">db:
	docker run -p 8000:8000 amazon/dynamodb-local

test:
	cargo test --features &quot;dynamo&quot;
</code></pre>
<p>O último passo para nossos testes é gerar ums função de teste que nos permita retirar a grosseria que é a função de teste <code>post_todo</code>. Assim, faremos uma função que le um arquivo <code>json</code> e retorna uma string contendo seu conteúdo. Vamos chamá-la de <code>read_json</code> e vai receber como argumento uma string com o nome do arquivo. A primeira mudança que faremos é adicionar <code>mod helpers</code> no arquivo <code>tests/lib.rs</code>. Depois vamos criar o módulo <code>tests/helpers.rs</code> e adicionar a função <code>read_json</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Read;

pub fn read_json(file: &amp;str) -&gt; String {
    let path = String::from(&quot;dev-resources/&quot;) + file;
    let mut file = File::open(&amp;path).unwrap();
    let mut data = String::new();
    file.read_to_string(&amp;mut data).unwrap();
    data
}
<span class="boring">}
</span></code></pre></pre>
<p>Com a função <code>read_json</code> pronta, podemos adicionar o Json <code>post_todo.json</code> na pasta (que vamos criar junto) <code>dev-resources</code> do projeto:</p>
<pre><code class="language-json">{
    &quot;title&quot;: &quot;This is a card&quot;,
    &quot;description&quot;: &quot;This is the description of the card&quot;,
    &quot;owner&quot;: &quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;,
    &quot;tasks&quot;: [
        {
            &quot;title&quot;: &quot;title 1&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 2&quot;,
            &quot;is_done&quot;: true
        },
        {
            &quot;title&quot;: &quot;title 3&quot;,
            &quot;is_done&quot;: false
        }
    ],
    &quot;state&quot;: &quot;Doing&quot;
}
</code></pre>
<p>Agora, podemos remover a função <code>post_todo()</code> do módulo <code>create_todo</code> encontrado no módulo <code>tests/todo_api_web/controller.rs</code> e adicionar o <code>use</code> da função <code>read_json</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod create_todo {
    // ...
    use crate::helpers::read_json;

    #[actix_web::test]
    async fn valid_todo_post() {
        ...
        let req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        let body = resp.into_body();
        let bytes = body::to_bytes(body).await.unwrap();
        let id = from_str::&lt;TodoIdResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        assert!(uuid::Uuid::parse_str(&amp;id.get_id()).is_ok());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>No próximo capítulo vamos aprender a obter todos os <code>TodoCard</code> que criamos na base de dados para depois podermos melhorar as configurações do serviço, por exemplo logs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-1/01-ping-pong.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../part-1/03-get.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-1/01-ping-pong.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../part-1/03-get.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
