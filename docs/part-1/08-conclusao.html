<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concluindo o serviço - Desenvolvimento Web em Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro/1-about.html">Sobre autora</a></li><li class="chapter-item expanded affix "><a href="../intro/2-Audience.html">Público alvo</a></li><li class="chapter-item expanded affix "><a href="../intro/3-book.html">Como o livro está organizado</a></li><li class="chapter-item expanded affix "><a href="../intro/4-setup.html">Instalando Rust</a></li><li class="chapter-item expanded affix "><a href="../intro/5-exercício.html">Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded affix "><a href="../part-1/00-capa.html">Parte 1</a></li><li class="chapter-item expanded "><a href="../part-1/01-ping-pong.html"><strong aria-hidden="true">1.</strong> Configurando os primeiros endpoints</a></li><li class="chapter-item expanded "><a href="../part-1/02-create.html"><strong aria-hidden="true">2.</strong> Criando Tarefas</a></li><li class="chapter-item expanded "><a href="../part-1/03-get.html"><strong aria-hidden="true">3.</strong> Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded "><a href="../part-1/04-serving.html"><strong aria-hidden="true">4.</strong> Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded "><a href="../part-1/05-auth.html"><strong aria-hidden="true">5.</strong> Autenticação</a></li><li class="chapter-item expanded "><a href="../part-1/06-middleware.html"><strong aria-hidden="true">6.</strong> Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded "><a href="../part-1/07-ci.html"><strong aria-hidden="true">7.</strong> Configurando um CI</a></li><li class="chapter-item expanded "><a href="../part-1/08-conclusao.html" class="active"><strong aria-hidden="true">8.</strong> Concluindo o serviço</a></li><li class="chapter-item expanded affix "><a href="../https://github.com/naomijub/web-dev-rust-book/blob/master/book.html">Topo</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="07-ci.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-2/00-capa.html">Próximo</a></p>
<h1 id="concluindo-o-serviço"><a class="header" href="#concluindo-o-serviço">Concluindo o serviço</a></h1>
<p>Falta pouco para termos nosso serviço pronto, pois precisamos implementar um <code>get</code> por id e um <code>update</code>. O <code>get</code> por id não é muito diferente da rota <code>index</code>, a única diferença é que vamos passar um parâmetro <code>id</code> e chamaremos a rota de <code>show</code> e será um método <code>GET</code> também. Já o <code>update</code> é um pouco diferente pois vamos enviar um corpo Json com as informações para atualizar em uma rota <code>update</code> com o método <code>PUT</code>. Assim, os endpoints que vamos implementar são:</p>
<ol>
<li>HTTP autenticado em <code>show/{id}</code> com o método <code>GET</code>.</li>
<li>HTTP autenticado em <code>update/{id}</code> com o método <code>PUT</code> e um body do tipo Json.</li>
</ol>
<h2 id="show-por-id"><a class="header" href="#show-por-id">Show por ID</a></h2>
<p>Como já falamos anteriormente, nosso objetivo agora é recuperar um <code>TodoCard</code> com base em seu <code>id</code> de inserção no banco de dados. Faremos isso utilizando a mesma função que utilizamos na rota <code>index</code>, <code>scan</code>. Para isso, sabemos que vamos precisar da rota <code>show/{id}</code>, como já mencionamos, e vamos precisar retornar um <code>TodoCard</code>. Assim, imagino que um bom teste para este cenário seria o seguinte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(test)]
mod show_by_id {
    use actix_web::{test, App};
    use dotenv::dotenv;
    use todo_server::todo_api_web::model::{
        http::Clients,
        todo::TodoCard,
    };
    use todo_server::todo_api_web::routes::app_routes;
    use serde_json::from_str;
    use crate::helpers::{mock_get_todos};

    #[actix_rt::test]
    async fn test_todo_card_by_id() {
        dotenv().ok();
        let mut app =
            test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

        let req = test::TestRequest::with_uri(&quot;/api/show/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;).to_request();
        let resp = test::read_response(&amp;mut app, req).await;

        let todo_card: TodoCard =
            from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
        assert_eq!(&amp;todo_card, mock_get_todos().get(0usize).unwrap());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este teste consiste em definir um request com um uuid, neste caso aleatório, para a rota <code>show</code> com <code>test::TestRequest::with_uri(&quot;/api/show/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;).to_request()</code>. Com o request em mão, chamamos o serviço para obter uma respose com <code>test::read_response(&amp;mut app, req).await</code> e convertemos esta response em um <code>TodoCard</code>, <code>let todo_card: TodoCard = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap()</code>. Como vamos mockar a resposta de <code>TodoCard</code> com o primeiro valor de <code>mock_get_todos</code>, basta comparar os dois com <code>assert_eq!(&amp;todo_card, mock_get_todos().get(0usize).unwrap())</code>.</p>
<p>O primeiro passo para resolver este teste é adicionar a rota a função <code>app_routes</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/routes.rs
// ...
pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                    .route(&quot;create&quot;, web::post().to(create_todo))
                    .route(&quot;index&quot;, web::get().to(show_all_todo))
                    .route(&quot;show/{id}&quot;, web::get().to(show_by_id)),
            )
            .service(
                web::scope(&quot;auth/&quot;)
                    .route(&quot;signup&quot;, web::post().to(signup_user))
                    .route(&quot;login&quot;, web::post().to(login))
                    .route(&quot;logout&quot;, web::delete().to(logout)),
            )
            .route(&quot;ping&quot;, web::get().to(pong))
            .route(&quot;~/ready&quot;, web::get().to(readiness))
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Para recebermos o ID como argumento de rota precisamos definir-lo como <code>{id}</code>, depois disso fazemos um <code>GET</code> redirecionando o request para o controller <code>show_by_id</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/todo.rs
// ...
pub async fn show_by_id(id: web::Path&lt;String&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    match get_todo_by_id(uuid, state.dynamo.clone()) {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::NotFound().finish()
        }
        Some(todo_id) =&gt; HttpResponse::Ok().content_type(&quot;application/json&quot;)
            .json(todo_id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Na função <code>show_by_id</code> vemos um ítem novo logo de cara, <code>web::Path&lt;String&gt;</code>, a função deste ítem é extrair o conteúdo dos argumentos presentes na url do request, ou seja, todas as chaves encontradas entres os símbolos <code>{</code> e <code>}</code>, no nosso caso <code>{id}</code>. Para o caso de um único argumento a estrutura de <code>web::Path</code> é como estamos utilizando, mas para o caso de mais argumentos se utiliza tuplas para definir a sequencia de argumentos, por exemplo <code>/api/show/{id}/task/{title}</code>, uma rota para obter o status de uma <code>task</code> de um <code>TodoCard</code> de <code>id</code> específico, obteriamos os valores com <code>web::Path&lt;(String,String)&gt;</code>. Valores diferentes de string podem ser passados desde que sejam serializáveis pelo serviço, por exemplo o código que escrevemos poderia substituir <code>String</code> por <code>Uuid</code>, caso fossemos utiliza-la:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_by_id(id: web::Path&lt;uuid::Uuid&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.into_inner().to_string();
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Não vamos utilizar o <code>web::Path</code> com <code>Uuid</code> pois, no futuro, vamos querer enviar um response <code>BadRequest</code> caso o campo <code>id</code> não seja um <code>Uuid</code>. Se deixassemos assim o response seria <code>InternalServerError</code>, que não é um status muito indicativo. Mantendo o <code>web::Path</code> como <code>String</code> passamos ao próximo ítem, uma funcnao de <code>todo_api/db/todo.rs</code> que recupera um <code>TodoCard</code> com base em seu <code>id</code>, <code>get_todo_by_id</code>. Os argumentos passados a <code>get_todo_by_id</code> são uma <code>String</code> contendo o <code>id</code> e o cliente para <code>dynamo</code>. Essa função retorna o tipo <code>Option&lt;TodoCard&gt;</code>, que para o padrão <code>None</code> vai retornar um status <code>NotFound</code>, indicando que este elemento não foi encontrado e para o caso <code>Some</code> vai retornar um <code>Ok</code> com um corpo contendo um Json com o valor do <code>TodoCard</code> encontrado.</p>
<p>A função <code>get_todo_by_id</code> é semelhante a função <code>get_todos</code>, mas com uma pequerna diferença, a struct <code>ScanInput</code> utilizanda para fazer a busca no banco possui dois campos extras <code>filter_expression</code> e <code>expression_attribute_values</code>. <code>filter_expression</code> é responsável por definir qual vai ser o filtro aplicado a este <code>scan</code>, por exemplo <code>=, &gt;=, &lt;</code>. No nosso caso, nossa <code>filter_expression</code> será <code>Some(&quot;id = :id&quot;.into())</code>, ou seja, vamos procurar um <code>id</code> que seja igual ao argumento <code>:id</code>. Poderiamos ter mais filtros em <code>filter_expression</code>, mas usaremos somente esse. Agora precisamos definir o argumento <code>:id</code> para aplicar em <code>filter_expression</code>. Este argumento é adicionado a query através de <code>expression_attribute_values</code>, que recebe um <code>HashMap</code> contendo o nome das chaves, <code>:id</code> no nosso caso, e um <code>AttributeValue</code> com a informação de <code>id</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use rusoto_dynamodb::{AttributeValue, DynamoDb};


let mut _map = HashMap::new();
let mut attr = AttributeValue::default();
attr.s = Some(id);
_map.insert(String::from(&quot;:id&quot;), attr);

let scan_item = ScanInput {
    // ...
    filter_expression: Some(&quot;id = :id&quot;.into()),
    expression_attribute_values: Some(_map),
    ..ScanInput::default()
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Filter Expression</strong></p>
<p>A lista de possíveis operadores para <code>filter_expression</code> é a seguinte:</p>
<ul>
<li>Funções: <code>attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size</code>, todas sensitivas a letras maísculas.</li>
<li>Operadores de comparação: <code>= | &lt;&gt; | &lt; | &gt; | &lt;= | &gt;= | BETWEEN | IN</code></li>
<li>Operadores lógicos: <code>AND | OR | NOT</code></li>
</ul>
</blockquote>
<p>Com a Struct <code>ScanInput</code> definida podemos executar a query em si com <code>client.scan(scan_item).sync()</code> e aplicar um <code>match</code> a resposta de <code>scan</code>. Existem dois padrões possíveis <code>Ok</code> e <code>Err</code>, como nosso controller espera um <code>Option&lt;TodoCard&gt;</code> retornamos um <code>None</code> no caso de <code>Err</code>. E no caso de <code>Ok</code> ainda temos que cuidar o caso de a resposta de <code>Ok</code> vir vazia:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match client.scan(scan_item).sync() {
    Ok(resp) =&gt; {
        let todo_id = adapter::scanoutput_to_todocards(resp);
        if todo_id.first().is_some() {
            debug!(&quot;Scanned {:?} todo cards&quot;, todo_id);
            Some(todo_id.first().unwrap().to_owned())
        } else {
            error!(&quot;Could find todocard with ID.&quot;);
            None
        }
    }
    Err(e) =&gt; {
        error!(&quot;Could not scan todocard due to error {:?}&quot;, e);
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Como a estrutura de <code>resp</code> é um <code>ScanOutput</code>, como em <code>get_todos</code>, podemos aplicar o mesmo adapter <code>adapter::scanoutput_to_todocards</code> a <code>resp</code>, porém a resposta deste adapter será um vetor de <code>TodoCard</code>. Como queremos somente um único elemento na resposta dessa query, aplicamos a função <code>first</code> e validamos o caso de ela não retornar <code>Some</code>, indicando com uma respostas <code>None</code>. Para o caso de retornar sim, retornamos um <code>Option</code> com o primeiro <code>TodoCard</code> com <code>Some(todo_id.first().unwrap().to_owned())</code>. A função completa ficou como a seguir, funcnao de teste esta logo depois retornando apenas <code>Some(TodoCard{...})</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn get_todo_by_id(id: String, client: DynamoDbClient) -&gt; Option&lt;TodoCard&gt; {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;:id&quot;), attr);

    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        filter_expression: Some(&quot;id = :id&quot;.into()),
        expression_attribute_values: Some(_map),
        ..ScanInput::default()
    };

    match client.scan(scan_item).sync() {
        Ok(resp) =&gt; {
            let todo_id = adapter::scanoutput_to_todocards(resp);
            if todo_id.first().is_some() {
                debug!(&quot;Scanned {:?} todo cards&quot;, todo_id);
                Some(todo_id.first().unwrap().to_owned())
            } else {
                error!(&quot;Could find todocard with ID.&quot;);
                None
            }
        }
        Err(e) =&gt; {
            error!(&quot;Could not scan todocard due to error {:?}&quot;, e);
            None
        }
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn get_todo_by_id(id: String, client: DynamoDbClient) -&gt; Option&lt;TodoCard&gt; {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;
    use crate::todo_api_web::model::todo::{State, Task};

    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;:id&quot;), attr);

    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        filter_expression: Some(&quot;id = :id&quot;.into()),
        expression_attribute_values: Some(_map),
        ..ScanInput::default()
    };

    Some(
        TodoCard {
            id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
            title: String::from(&quot;This is a card&quot;),
            description: String::from(&quot;This is the description of the card&quot;),
            owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
            tasks: vec![
                Task {
                    title: String::from(&quot;title 1&quot;),
                    is_done: true,
                },
                Task {
                    title: String::from(&quot;title 2&quot;),
                    is_done: true,
                },
                Task {
                    title: String::from(&quot;title 3&quot;),
                    is_done: false,
                },
            ],
            state: State::Doing,
        }
    )
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="validando-o-uuid"><a class="header" href="#validando-o-uuid">Validando o Uuid</a></h3>
<p>Nosso próximo passo é validar que o formato enviado é um <code>Uuid</code>. Para isso criaremos um teste que faz um request com um formato aleatório de dado e retorna <code>BadRequest</code> com a mesagem que &quot;id deve ser um Uuid&quot;.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_todo_card_without_uuid() {
    dotenv().ok();
    let mut app =
        test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

    let req = test::TestRequest::with_uri(&quot;/api/show/fake-uuid&quot;).to_request();
    let resp = test::read_response(&amp;mut app, req).await;

    let message = String::from_utf8(resp.to_vec()).unwrap();
    assert_eq!(&amp;message, &quot;Id must be a Uuid::V4&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver este teste a implementação de código é bastante simples, basta adicioanrmos um <code>if</code> que verifica se o <code>parse_str</code> é do tipo <code>Err</code> e em caso de <code>true</code> retornar <code>HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;)</code>. Assim, nossa função ficou da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_by_id(id: web::Path&lt;String&gt;, state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    if uuid::Uuid::parse_str(&amp;uuid).is_err() {
        return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
    }

    match get_todo_by_id(uuid, state.dynamo.clone()) {
        None =&gt; {
            error!(&quot;Failed to read todo cards&quot;);
            HttpResponse::NotFound().finish()
        }
        Some(todo_id) =&gt; HttpResponse::Ok().content_type(&quot;application/json&quot;)
            .json(todo_id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="atualizando-todocards"><a class="header" href="#atualizando-todocards">Atualizando TodoCards</a></h2>
<p>Agora vamos aprender como atualizar as informações de uma <code>TodoCard</code> no DynamoDB. Vamos focar em atualizar somente dois atributos <code>description</code> e <code>state</code>, depois discutiremos estratégias para implementar updates em <code>tasks</code>, pois os outros argumentos são essencialmente iguais a <code>description</code> e <code>state</code>. Agora precisamos definir como será nosso endpoint de atualização, para isso podemos definir sua rota como <code>/api/update/{id}</code> e responderá via método <code>PUT</code>. Assim, nosso body conterá os campos <code>state</code> e/ou <code>description</code>, como no exemplo de <code>put_todo.json</code>:</p>
<pre><code class="language-json">{
	&quot;state&quot;: &quot;Doing&quot;,
	&quot;description&quot;: &quot;dfwgferf&quot;
}
</code></pre>
<p>Um teste para esse cenário seria o seguinte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/test_api_web/controller.rs
// ...
#[cfg(test)]
mod update {
    use actix_web::{test, App, http::StatusCode};
    use dotenv::dotenv;
    use todo_server::todo_api_web::model::{
        http::Clients,
    };
    use todo_server::todo_api_web::routes::app_routes;
    use crate::helpers::{read_json};


    #[actix_rt::test]
    async fn test_todo_card_by_id() {
        dotenv().ok();
        let mut app =
            test::init_service(App::new().data(Clients::new()).configure(app_routes)).await;

        let req = test::TestRequest::put()
            .uri(&quot;/api/update/544e3675-19f5-4455-9ed9-9ccc577f70fe&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;put_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = test::call_service(&amp;mut app, req).await;
        assert_eq!(resp.status(), StatusCode::OK);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="criando-a-rota"><a class="header" href="#criando-a-rota">Criando a Rota</a></h3>
<p>Temos nosso teste, mas agora precisamos criar a rota em <code>src/todo_api_web/routes.rs</code> seguindo o padrão <code>PUT</code> na rota <code>/api/update/{id}</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    todo::{create_todo, show_all_todo, show_by_id, update_todo},
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                    .route(&quot;create&quot;, web::post().to(create_todo))
                    .route(&quot;index&quot;, web::get().to(show_all_todo))
                    .route(&quot;show/{id}&quot;, web::get().to(show_by_id))
                    .route(&quot;update/{id}&quot;, web::put().to(update_todo)),
            )
            // ...
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, precisamos implementar o controller <code>update_todo</code> em <code>src/todo_api_web/controller/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn update_todo(
    id: web::Path&lt;String&gt;,
    info: web::Json&lt;TodoCardUpdate&gt;, 
    state: web::Data&lt;Clients&gt;) -&gt; impl Responder {
    let uuid = id.to_string();

    if uuid::Uuid::parse_str(&amp;uuid).is_err() {
        return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
    }

    match update_todo_info(uuid, info.into_inner(), state.dynamo.clone()) {
        true =&gt; HttpResponse::Ok().finish(),
        false =&gt; HttpResponse::NotFound().finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Os argumentos para a função <code>update_todo</code> são <code>id</code> que vem da rota da url <code>{id}</code> com <code>web::Path&lt;String&gt;</code>, <code>info</code> que corresponde ao corpo do <code>PUT</code> do tipo <code>web::Json&lt;TodoCardUpdate&gt;</code> e o <code>state</code> que vem do estao da aplicação com <code>web::Data&lt;Clients&gt;</code>. Primeiro passo é converter o campo <code>id</code> em <code>String</code> com <code>to_string</code> para validar se essa string é um <code>Uuid</code> com <code>uuid::Uuid::parse_str(&amp;uuid)</code> e retornar um <code>HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;)</code> caso o resultado de <code>parse_str</code> seja do tipo <code>Err</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uuid = id.to_string();

if uuid::Uuid::parse_str(&amp;uuid).is_err() {
    return HttpResponse::BadRequest().body(&quot;Id must be a Uuid::V4&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois disso, chamamos a função <code>update_todo_info</code> que retorna um booleano para aplicarmos pattern matching em <code>true</code>, retornando <code>HttpResponse::Ok().finish()</code>, ou em <code>false</code>, retornando <code>HttpResponse::NotFound().finish()</code>. A função <code>update_todo_info</code> está localizada em <code>src/todo_api/db/todo.rs</code> e é bastante extensa:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn update_todo_info(id: String, info: TodoCardUpdate, client: DynamoDbClient) -&gt; bool {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let expression = adapter::update_expression(&amp;info);
    let attribute_values = adapter::expression_attribute_values(&amp;info);
    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;id&quot;), attr);

    let update = UpdateItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        key: _map,
        update_expression: expression,
        expression_attribute_values: attribute_values,
        ..UpdateItemInput::default()
    };

    match client.update_item(update).sync() {
        Ok(_) =&gt; true,
        Err(e) =&gt; {
            error!(&quot;failed due to {:?}&quot;, e);
            false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que precisamos ressaltar neste código é o <code>UpdateItemInput</code>, que é a struct responsável por executar a atualização da <code>todo</code> com o <code>id</code> enviado na rota. Os campos necessários são <code>table_name</code>, que é o nome da tabela, <code>key</code> que é um <code>AttributeValue</code> com todos os valores de <code>key</code>, no nosso caso é somente <code>id</code>, <code>update_expression</code> que define quais argumentos serão atualizados através do adapter <code>adapter::update_expression</code>, <code>expression_attribute_values</code> que contém os argumentos para atualizar as informações através do <code>adapter::expression_attribute_values</code> que transforma os valores de <code>TodoCardUpdate</code> em um <code>HashMap&lt;String, AttributeValue&gt;</code>. Assim, para transformar o <code>id</code> em um <code>HashMap&lt;String, AttributeValue&gt;</code> podemos utilizar a seguinte lógica:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut _map = HashMap::new();
let mut attr = AttributeValue::default();
attr.s = Some(id);
_map.insert(String::from(&quot;id&quot;), attr);
<span class="boring">}
</span></code></pre></pre>
<p>A função para executar a atualização no Dynamo é <code>update_item</code>, lembre-se que após o <code>sync</code> o resultado é do tipo <code>Result</code>, por isso do <code>match</code>. Já os adapter são os seguintes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/adapter/mod.rs
// ...
pub fn update_expression(info: &amp;TodoCardUpdate) -&gt; Option&lt;String&gt; {
    let data = info.clone();
    match (data.description, data.state) {
        (Some(_), Some(_)) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s&quot;)),
        (_, Some(_)) =&gt; Some(String::from(&quot;SET  state_db = :s&quot;)),
        (Some(_), _) =&gt; Some(String::from(&quot;SET description = :d&quot;)),
        _ =&gt; None
    }
}

pub fn expression_attribute_values(info: &amp;TodoCardUpdate) -&gt; Option&lt;HashMap&lt;String, AttributeValue&gt;&gt; {
    let data = info.clone();
    match (data.description, data.state) {
        (Some(desc), Some(state)) =&gt; {
            let mut _map = HashMap::new();
            let mut attr_d = AttributeValue::default();
            attr_d.s = Some(String::from(desc));
            let mut attr_s = AttributeValue::default();
            attr_s.s = Some(String::from(state.to_string()));
            _map.insert(String::from(&quot;:d&quot;), attr_d);
            _map.insert(String::from(&quot;:s&quot;), attr_s);
            Some(_map)
        },
        (_, Some(state)) =&gt; {
            let mut _map = HashMap::new();
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(state.to_string()));
            _map.insert(String::from(&quot;:s&quot;), attr);
            Some(_map)
        },
        (Some(desc), _) =&gt; {
            let mut _map = HashMap::new();
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(desc));
            _map.insert(String::from(&quot;:d&quot;), attr);
            Some(_map)
        },
        _ =&gt; None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>update_expression</code> é responsável pro criar a expressão que vai determinar o que será atualizado. Como recebemos 2 campos <code>Optional</code>, <code>description</code> e <code>state</code>, temos 4 possibilidades:</p>
<ol>
<li>Ambos existem retorna <code>&quot;SET description = :d, state_db = :s&quot;)</code>.</li>
<li>Somente <code>state</code> existe retorna <code>&quot;SET state_db = :s&quot;</code>.</li>
<li>Somente <code>description</code> existe retorna <code>&quot;SET description = :d&quot;</code>.</li>
<li>Nenhum retorna um <code>None</code>.</li>
</ol>
<p>Os testes para <code>update_expression</code> são os seguintes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod update_expression_test {
    use super::update_expression;
    use crate::todo_api_web::model::todo::{State, TodoCardUpdate};

    #[test]
    fn description_and_state() {
        let todo_update = TodoCardUpdate {description: Some(&quot;haiushdusd&quot;.to_string()), state: Some(State::Doing)};
        let expected = Some(String::from(&quot;SET description = :d, state_db = :s&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn description() {
        let todo_update = TodoCardUpdate {description: Some(&quot;haiushdusd&quot;.to_string()), state: None};
        let expected = Some(String::from(&quot;SET description = :d&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn state() {
        let todo_update = TodoCardUpdate {description: None, state: Some(State::Doing)};
        let expected = Some(String::from(&quot;SET state_db = :s&quot;));

        assert_eq!(expected, update_expression(&amp;todo_update));
    }

    #[test]
    fn none() {
        let todo_update = TodoCardUpdate {description: None, state: None};
        let expected = None;

        assert_eq!(expected, update_expression(&amp;todo_update));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Já <code>expression_attribute_values</code> é um pouco mais complicada pois deve retornar um <code>Option&lt;HashMap&lt;String, AttributeValue&gt;&gt;</code>, mas as regras de pattern matching são as mesmas. Assim vamos entender o caso que existe tanto <code>description</code> quanto <code>state</code>. Para <code>update_expression</code> não nos interessava o conteúdo da expression, assim utilizavamos <code>Some(_)</code> para fazer pattern matching, porém em <code>expression_attribute_values</code> eles interessam já que será inseridos dentro do <code>HashMap</code>. A primeira cosia que devemos fazer é criar um <code>HashMap</code> com <code>let mut _map = HashMap::new();</code> e determinar os <code>AttributeValue</code> para <code>state</code> e para <code>description</code>, <code>let mut attr_s = AttributeValue::default();</code> e <code>let mut attr_d = AttributeValue::default();</code> respectivamente. Depois disso, inserimos o conteúdo de <code>state</code> e de <code>description</code> no campo <code>s</code>, de String, através de <code>attr_d.s</code>, <code>attr_s.s = Some(String::from(state.to_string()));</code> e <code>attr_d.s = Some(String::from(desc));</code>. Inserimos estes valores no mapa com <code>_map.insert(String::from(&quot;:d&quot;), attr_d); _map.insert(String::from(&quot;:s&quot;), attr_s);</code> e retornamos seu valor em <code>Some(_map)</code>. A função para teste é a seguinte: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dbtest&quot;)]
pub fn update_todo_info(id: String, info: TodoCardUpdate, client: DynamoDbClient) -&gt; bool {
    use rusoto_dynamodb::{AttributeValue, DynamoDb};
    use std::collections::HashMap;

    let expression = adapter::update_expression(&amp;info);
    let attribute_values = adapter::expression_attribute_values(&amp;info);
    let mut _map = HashMap::new();
    let mut attr = AttributeValue::default();
    attr.s = Some(id);
    _map.insert(String::from(&quot;id&quot;), attr);

    let update = UpdateItemInput {
        table_name: TODO_CARD_TABLE.to_string(),
        key: _map,
        update_expression: expression,
        expression_attribute_values: attribute_values,
        ..UpdateItemInput::default()
    };

    true
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos entender como nosso código mudaria para incluir os outros campos de atualização.</p>
<h2 id="atualizando-outros-campos"><a class="header" href="#atualizando-outros-campos">Atualizando outros campos</a></h2>
<p>Considerando que a struct que temos no banco de dados é a seguinte e que o campo <code>id</code> não será atualizado, podemos discutir como adicionar <code>title</code>, <code>owner</code> e <code>tasks</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TodoCard {
    pub id: Option&lt;Uuid&gt;,
    pub title: String,
    pub description: String,
    pub owner: Uuid,
    pub tasks: Vec&lt;Task&gt;,
    pub state: State,
}
<span class="boring">}
</span></code></pre></pre>
<p>Bom, <code>title</code> e <code>owner</code> são bastante triviais, pois bastaria expandir nossos adapters para lidarem com mais duas strings, modificando nossa struct <code>TodoCardUpdate</code> para:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TodoCardUpdate {
    pub description: Option&lt;String&gt;,
    pub state: Option&lt;State&gt;,
    pub title: Option&lt;String&gt;,
    pub owner: Option&lt;Uuid&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Já o adapter <code>update_expression</code> ficaria semelhante ao seguinte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_expression(info: &amp;TodoCardUpdate) -&gt; Option&lt;String&gt; {
    let data = info.clone();
    match (data.description, data.state, data.title, data.owner) {
        (Some(_), Some(_), Some(_), Some(_)) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s, title = :t, owner = :o&quot;)),
        ...
        (Some(_), Some(_), _, _) =&gt; Some(String::from(&quot;SET description = :d, state_db = :s&quot;)),
        (_, Some(_), Some(_), _) =&gt; Some(String::from(&quot;SET title = :t, state_db = :s&quot;)),
        (_, _, Some(_), Some(_)) =&gt; Some(String::from(&quot;SET title = :t, owner = :o&quot;)),
        (Some(_), _, _, Some(_)) =&gt; Some(String::from(&quot;SET description = :d, owner = :o&quot;)),
        ...
        (_, Some(_), _, _) =&gt; Some(String::from(&quot;SET  state_db = :s&quot;)),
        (Some(_), _, _, _) =&gt; Some(String::from(&quot;SET description = :d&quot;)),
        (_, _, Some(_), _) =&gt; Some(String::from(&quot;SET title = :t&quot;)),
        (_, _, _, Some(_)) =&gt; Some(String::from(&quot;SET owner = :o&quot;)),
        _ =&gt; None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Acredito que esta solução pode ficar um pouco verbosa, assim, uma ideia seria transformar esses 4 campos em um vetor e iterar nele de forma posicional, o que não geraria uma solução muito elegante também, mas seria muito útil para o caso de <code>expression_attribute_values</code>, como o <strong>pseudo código</strong> a seguir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// pseudo código
pub fn expression_attribute_values(info: &amp;TodoCardUpdate) -&gt; Option&lt;HashMap&lt;String, AttributeValue&gt;&gt; {
    let data = info.clone();
    let mut _map = HashMap::new();
    let data_vec = vec![data.description, data.state, data.title, data.owner];

    data_vec.iter()
        .map(|i| if i.is_some() {
            let mut attr = AttributeValue::default();
            attr.s = Some(String::from(i));
            attr
        } else {
            None
        })
        .enumerate(|(idx, item)| 
          match idx {
              0 =&gt; (&quot;:d&quot;.to_string(), item),
              1 =&gt; (&quot;:s&quot;.to_string(), item),
              2 =&gt; (&quot;:t&quot;.to_string(), item),
              3 =&gt; (&quot;:o&quot;.to_string(), item),
              _ =&gt; (&quot;&quot;.to_string(), None)
          })
        .fold(_map,|acc, i| 
          if i.is_some() {
              acc.insert(i.0, i.1)
          };
          acc);
        Some(_map)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tasks"><a class="header" href="#tasks">Tasks</a></h3>
<p>Agora precisamos discutir <code>tasks</code>, elas são mais complicadas pois não criamos o conceito de <code>id</code> nelas, assim a solução que eu creio ser mais simples para lidar com elas é criar uma struct que contém três argumentos <code>is_bool</code>, <code>previous_text</code>, <code>new_text</code>. O campo <code>is_bool</code> é equivalente ao da struct <code>Task</code>, já o argumento <code>previous_text</code> é o argumento que identifica qual o texto existente de <code>Task</code> no banco, e <code>new_text</code> é o texto que queremos atualizar. Para entender como ficaria a adição, a atualização e o remoção teremos o seguinte:</p>
<ul>
<li>Adicão: <code>previous_text = None</code>, <code>new_text = Some</code>.</li>
<li>Atualização: <code>previous_text = Some</code>, <code>new_text = Some</code>.</li>
<li>Remoção: <code>previous_text = Some</code>, <code>new_text = None</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskUpdate {
    pub is_bool: bool,
    pub previous_text: Option&lt;String&gt;,
    pub new_text: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Portanto, quando identificarmos que <code>previous_text</code> não existe, criamos uma nova <code>task</code>, e quando identificarmos que <code>new_text</code> não existe, deletamos a <code>task</code> com o texto da <code>previous_text</code>. Já a atualização filtramos todas as tasks que contém o <code>previous_text</code> com <code>new_text</code>, assim se ambos são iguais atualizamos somente <code>is_bool</code> e em caso de não existir uma task com <code>previous_text</code>, simplesmente criamos uma nova <code>new_text</code>. Isso poderia ser feito em endpoint que responde a um <code>POST</code> em <code>/api/update/{id}/tasks</code>. </p>
<p>Fica como um bom desafio fazer estas mudanças que discutimos aqui antes de seguir para a próxima parte, assim como criar um endpoint de <code>DELETE</code>. Nesta parte aprendemos a criar um serviço <code>REST</code> com actix que cria e gerencia tarefas via <code>create</code>, <code>update</code>, <code>show</code> e <code>index</code>, salvando estas informações em um DynamoDB. Além disso, criamos um middleware de autenticação e endpoints de autenticação, via diesel. Outros middlewares que utilizamos foi o <code>Logger</code>, que infelizmente não funciona com <code>dotenv</code>, necessária para o <code>Logger</code>, e um middleware que cria o header <code>x-request-id</code>. Aprendemos a gerenciar o estado da aplicação com <code>.data()</code> e a configurar rotas com <code>.configure()</code>. Por último, aprendemos a tornar nosso sistema tolerante a falhas e a configurar o docker com todas as dependências.</p>
<p>Agora vamos aprender a utilizar graphql com Actix para fazer um sistema de busca de rotas de voos.</p>
<p><a href="07-ci.html">Anterior</a> | <a href="https://github.com/naomijub/web-dev-rust-book/blob/master/book.md">Topo</a> | <a href="part-2/00-capa.html">Próximo</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../part-1/07-ci.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../https://github.com/naomijub/web-dev-rust-book/blob/master/book.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../part-1/07-ci.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../https://github.com/naomijub/web-dev-rust-book/blob/master/book.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
