<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Autenticação - Desenvolvimento Web em Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li class="chapter-item expanded "><a href="../intro/1-about.html"><strong aria-hidden="true">2.</strong> Sobre autora</a></li><li class="chapter-item expanded "><a href="../intro/2-Audience.html"><strong aria-hidden="true">3.</strong> Público alvo</a></li><li class="chapter-item expanded "><a href="../intro/3-book.html"><strong aria-hidden="true">4.</strong> Como o livro está organizado</a></li><li class="chapter-item expanded "><a href="../intro/4-setup.html"><strong aria-hidden="true">5.</strong> Instalando Rust</a></li><li class="chapter-item expanded "><a href="../intro/5-exercício.html"><strong aria-hidden="true">6.</strong> Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded "><a href="../part-1/00-capa.html"><strong aria-hidden="true">7.</strong> Todo Server com Actix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-1/01-ping-pong.html"><strong aria-hidden="true">7.1.</strong> Configurando os primeiros endpoints</a></li><li class="chapter-item expanded "><a href="../part-1/02-create.html"><strong aria-hidden="true">7.2.</strong> Criando Tarefas</a></li><li class="chapter-item expanded "><a href="../part-1/03-get.html"><strong aria-hidden="true">7.3.</strong> Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded "><a href="../part-1/04-serving.html"><strong aria-hidden="true">7.4.</strong> Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded "><a href="../part-1/05-auth.html" class="active"><strong aria-hidden="true">7.5.</strong> Autenticação</a></li><li class="chapter-item expanded "><a href="../part-1/06-middleware.html"><strong aria-hidden="true">7.6.</strong> Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded "><a href="../part-1/07-ci.html"><strong aria-hidden="true">7.7.</strong> Configurando um CI</a></li><li class="chapter-item expanded "><a href="../part-1/08-conclusao.html"><strong aria-hidden="true">7.8.</strong> Concluindo o serviço</a></li></ol></li><li class="chapter-item expanded "><a href="../part-2/00-capa.html"><strong aria-hidden="true">8.</strong> GraphQL com Actix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-2/01-ping-gql.html"><strong aria-hidden="true">8.1.</strong> Configurando o GraphQL</a></li><li class="chapter-item expanded "><a href="../part-2/02-bestprices.html"><strong aria-hidden="true">8.2.</strong> Query Best Prices</a></li><li class="chapter-item expanded "><a href="../part-2/03-recommendations.html"><strong aria-hidden="true">8.3.</strong> Query Recommendations</a></li><li class="chapter-item expanded "><a href="../part-2/04-redis.html"><strong aria-hidden="true">8.4.</strong> Adicionando Caching com Redis</a></li></ol></li><li class="chapter-item expanded "><a href="../part-3/00-capa.html"><strong aria-hidden="true">9.</strong> Frontend com WebAssembly e YewStack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-3/01-setup.html"><strong aria-hidden="true">9.1.</strong> Setup de WebAssembly</a></li><li class="chapter-item expanded "><a href="../part-3/02-iniciando.html"><strong aria-hidden="true">9.2.</strong> Iniciando o projeto</a></li><li class="chapter-item expanded "><a href="../part-3/03-best-prices.html"><strong aria-hidden="true">9.3.</strong> Componente de Best Prices</a></li><li class="chapter-item expanded "><a href="../part-3/04-recommendations.html"><strong aria-hidden="true">9.4.</strong> Componente de Recomendações</a></li><li class="chapter-item expanded "><a href="../part-3/05-route.html"><strong aria-hidden="true">9.5.</strong> Aplicando um Router</a></li></ol></li><li class="chapter-item expanded "><a href="../appendix.html"><strong aria-hidden="true">10.</strong> Appendix</a></li><li class="chapter-item expanded "><a href="../bibliografia.html"><strong aria-hidden="true">11.</strong> Bibliografia</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="autenticação"><a class="header" href="#autenticação">Autenticação</a></h1>
<p>Criaremos funções do serviço para registrar e para fazer login no nosso serviço. Além disso, implementaremos um middleware que protege nossos endpoints de usuários não autenticados. Para realizar isso vamos utilizar a crate <code>Diesel</code> para lidar com a base de dados, que será o Postgres. Para isso precisamos seguir alguns passos (também em https://diesel.rs/guides/getting-started):</p>
<ol>
<li>Instale a <code>diesel_cli</code>, pois este binário ajuda a gerenciar o projeto. Utilize <code>cargo install diesel_cli</code> para isso. Para compilar o <code>diesel_cli</code> é preciso ter a lib <code>libpq</code>, no MacOS podemos fazer isso com <code>brew install postgresql</code>, <code>brew install libpq</code> e depois <code>cargo install diesel_cli --no-default-features --features postgres</code> para instalar somente o conector de <code>postgres</code>. </li>
<li>Ter um container disponível <code>docker run -i --rm --name auth-db -p 5432:5432 -e POSTGRES_USER=auth -e POSTGRES_PASSWORD=secret -d postgres</code></li>
<li>Para utilizar o <code>diesel_cli</code> executamos o comando <code>diesel setup</code>, mas para isso precisamos da url do postgress em um arquivo <code>.env</code>. Para isso precisamos executar <code>echo DATABASE_URL=postgres://auth:secret@localhost/auth_db &gt; .env</code>. Agora executamos <code>diesel setup --migration-dir src/migrations</code> para estabelecer a conexão.</li>
<li>Depois podemos criar nossas migrações com <code>diesel migration generate create_auth</code>, note a pasta <code>migrations</code> com duas subpastas cada uma contendo um <code>up.sql</code> e um <code>down.sql</code>.</li>
<li>Na segunda pasta vamos criar a tabela <code>auth_user</code> em <code>up.sql</code>:</li>
</ol>
<pre><code class="language-sql">-- up.sql
CREATE TABLE auth_user (
    email VARCHAR(100) NOT NULL PRIMARY KEY,
    id UUID NOT NULL,
    password VARCHAR(64) NOT NULL, --bcrypt hash
    expires_at TIMESTAMP NOT NULL
);
</code></pre>
<pre><code class="language-sql">--down.sql
DROP TABLE auth_user;
</code></pre>
<ol start="6">
<li>Agora basta executar as migrations com <code>diesel migration run --migration-dir src/migrations</code>, caso você queira reverter as migrations basta executar <code>diesel migration redo</code>. Note a criação de um arquivo <code>src/schema.rs</code> em nosso projeto:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table! {
    auth_user (email) {
        email -&gt; Varchar,
        id -&gt; Uuid,
        password -&gt; Varchar,
        expires_at -&gt; Timestamp,
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A macro table! gera código baseado no schema da base de dados que representes todas as tabelas e colunas.</p>
</blockquote>
<ol start="7">
<li>Tipicamente um schema não é criado na mão e sim gerado pelo binário <code>diesel</code>. Quando executamos <code>diesel setup</code>, um arquivo <code>diesel.toml</code> é criado para indicar ao <code>Diesel</code> para manter o arquivo <code>src/schema.rs</code> por nós.</li>
</ol>
<blockquote>
<p>Nota sobre Diesel em Produção</p>
<p>Quando em produção você talvez prefira executar suas migrações na inicialização da aplicação. Assim, a <a href="https://docs.diesel.rs/master/diesel_migrations/macro.embed_migrations.html_">crate Diesel disponibiliza a macro</a> <code>embed_migrations!</code>, permitindo embedar os scripts de migração como parte final do binário. Para usá-la, basta usar um snippet similar ao abaixo no início de suas <code>main</code> e as migrações serão executadas.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!(&quot;../../migrations/postgresql&quot;);

fn run_migrations(connection: &amp;mut impl MigrationHarness&lt;DB&gt;) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync + 'static&gt;&gt; {
   connection.run_pending_migrations(MIGRATIONS)?;

   Ok(())
}
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<h2 id="configurando-o-postgres-com-rust"><a class="header" href="#configurando-o-postgres-com-rust">Configurando o Postgres com Rust</a></h2>
<p>Agora podemos começar a evoluir a autenticação do nosso servidor, para isso devemos adicionar algumas crates ao <code>[dependencies]</code> do Cargo.toml:</p>
<pre><code class="language-toml">actix = &quot;0.11.0&quot;
chrono = { version = &quot;0.4.23&quot;, features = [&quot;serde&quot;] }
diesel = {version = &quot;2.0.2&quot;, features = [&quot;chrono&quot;, &quot;postgres&quot;, &quot;r2d2&quot;, &quot;uuid&quot;]}
dotenv = &quot;0.15.0&quot;
r2d2 = &quot;0.8.10&quot;
</code></pre>
<p>A abordagem que vamos seguir aqui é diferente da apresentada no guia do diesel, consulte bibliografia para obter o link, pois vamos tentar tirar proveito do sistema de actors do actix (caso você queira, é um bom exercício aplicar a mesma estratégia ao <code>Client</code>). Assim, em nosso módulo <code>src/todo_api/db/helpers.rs</code> vamos criar uma struct <code>DbExecutor</code>, com um tipo de conexão de pool, que vai implementar a trait <code>Actor</code> do actix:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, SyncContext};
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool};

pub struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;);

impl Actor for DbExecutor {
    type Context = SyncContext&lt;Self&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Actors</p>
<p>Actors se comunicam exclusivamente pela troca de mensagens. Assim, o actor que envia a mensagem irá, opcionalmente, esperar pela respostas. Além disso, actors não são referenciados diretamente, mas sim pelos seus endereços. Qualquer tipo no Rust pode se tornar um actor, o único requerimento é que implemente a trait <code>Actor</code>.</p>
</blockquote>
<p>Depois disso precisamos adicionar a struct <code>DbExecutor</code> ao nosso <code>Clients</code>, porém nosso <code>DbExecutor</code> vai precisar precisar ser envelopado em um <code>Addr&lt;T&gt;</code>, que corresponde ao endereço do actor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/model/http.rs
use actix::prelude::Addr;
use crate::todo_api::db::helpers::{client, DbExecutor};

#[derive(Clone)]
pub struct Clients {
    pub dynamo: aws_sdk_dynamodb::Client,
    pub postgres: Addr&lt;DbExecutor&gt;,
}

impl Clients {
    pub fn new(pg: Addr&lt;DbExecutor&gt;) -&gt; Self {
        Self { 
            dynamo: client(),
            postgres: pg
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos de uma função que crie o <code>Addr&lt;DbExecutor&gt;</code> para podemos enviar como argumento ao <code>new</code>. Essa função se chamara <code>db_executor_address</code> e estará localizada em <code>src/todo_api/db/helpers.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Addr, SyncContext, SyncArbiter};
// ...
use diesel::{
    r2d2::{ConnectionManager, Pool},
    pg::PgConnection
};
use std::env;

// ...

pub struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;);

impl Actor for DbExecutor {
    type Context = SyncContext&lt;Self&gt;;
}

pub fn db_executor_address() -&gt; Addr&lt;DbExecutor&gt; {
    let database_url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);

    let manager = ConnectionManager::&lt;PgConnection&gt;::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect(&quot;Failed to create pool.&quot;);

    SyncArbiter::start(4, move || DbExecutor(pool.clone()))
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos modificar a função <code>Clients::new</code> para que não seja preciso passar <code>Addr&lt;DbExecutor&gt;</code> como argumento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::db::helpers::{client, DbExecutor, db_executor_address};
use actix::prelude::Addr;
use aws_sdk_dynamodb::Client;

#[derive(Clone)]
pub struct Clients {
    pub dynamo: aws_sdk_dynamodb::Client,
    pub postgres: Addr&lt;DbExecutor&gt;,
}

impl Clients {
    pub fn new() -&gt; Self {
        Self {
            dynamo: client(),
            postgres: db_executor_address(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ao executar o código obtemos uma falha, pois <code>DATABASE_URL</code> não está setada, agora precisamos utilizar as configurações do postgres para o <code>docker-compose</code>:</p>
<pre><code class="language-yml"># ...
services:
# ...
  web:
  environment:
      # ...
      DATABASE_URL: 'postgres://auth:secret@postgres:5432/auth_db'
  postgres:
    container_name: &quot;postgres&quot;
    image: postgres
    ports:
      - &quot;5432:5432&quot;
    environment:
      - POSTGRES_USER=auth
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=auth_db
# ...
</code></pre>
<p>Para isso precisamos remover nosso <code>env_logger</code> do nosso código e Cargo.toml. Além disso, a definição da variável de ambiente do log passa para o arquivo <code>.env</code>:</p>
<pre><code>DATABASE_URL=postgres://auth:secret/auth_db
RUST_LOG=actix_web=info
</code></pre>
<p>Agora precisamos executar as migrações no docker compose, para isso vamos utilizar <code>embed_migrations!</code> migrations como falamos anteriormente. A macro <code>embed_migrations!</code> está disponível na crate <code>diesel_migrations = &quot;2.0.0&quot;</code>, adicione ela a seu <code>[dependencies]</code> do Cargo.toml. E agora precisamos que o código execute a migração. Para isso adicionamos a função <code>run_migrations</code> em <code>create_table</code>, no módulo <code>src/todo_api/db/helpers.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Addr, SyncArbiter, SyncContext};
use diesel::{
    prelude::*,
    r2d2::{ConnectionManager, Pool},
};
use diesel_migrations::run_pending_migrations;
use log::{debug, error};
use std::env;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!(&quot;src/migrations&quot;);

// ...

pub async fn create_table(client: &amp;Client) {
    let database_url = env::var(&quot;DATABASE_URL&quot;).expect(&quot;DATABASE_URL must be set&quot;);
    let mut pg_conn = PgConnection::establish(&amp;database_url)
        .expect(&amp;format!(&quot;Error connecting to {}&quot;, database_url));

    run_migrations(&amp;mut pg_conn);
    match client.list_tables().send().await {
        Ok(list) =&gt; {
            match list.table_names {
                Some(table_vec) =&gt; {
                    if table_vec.len() &gt; 0 {
                        println!(&quot;Error: {:?}&quot;, &quot;Table already exists&quot;);
                    } else {
                        create_table_input(&amp;client).await
                    }
                }
                None =&gt; create_table_input(&amp;client).await,
            };
        }
        Err(_) =&gt; {
            create_table_input(&amp;client).await;
        }
    }
}

fn run_migrations(pg_conn: &amp;mut PgConnection) {
    match pg_conn.run_pending_migrations(MIGRATIONS) {
        Ok(_) =&gt; debug!(&quot;auth database created&quot;),
        Err(_) =&gt; error!(&quot;auth database creation failed&quot;),
    };
}
// ...
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Cuidado pois esta configuração do docker-compose pode consumir muita memória. Pode ser interessante executar um <code>docker system prune --volumes</code> caso seu docker falhe. </li>
</ul>
<h2 id="criando-o-endpoint-de-cadastro-de-usuários"><a class="header" href="#criando-o-endpoint-de-cadastro-de-usuários">Criando o endpoint de cadastro de usuários</a></h2>
<p>Nosso próximo passo é modelar o domínio de autenticação em <code>todo_api</code>, chamaremos nossa struct de <code>User</code> e incluiremos no módulo <code>src/todo_api/model/auth.rs</code>. A primeira coisa que devemos fazer é declarar <code>mod schema</code> em <code>main.rs</code> e <code>lib.rs</code>, e por motivos de agilidade utilizar <code>#[macro_use] extern crate diesel_migrations;</code> e <code>#[macro_use] extern crate diesel;</code> para disponibilizar as macros utilizads em <code>schema.rs</code>. Depois disso, podemos criar nossa struct <code>User</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::schema::*;

#[derive(Debug, Serialize, Deserialize, Queryable, Insertable)]
#[diesel(table_name = auth_user)]
pub struct User {
    email: String,
    id: uuid::Uuid,
    password: String,
    expires_at: chrono::NaiveDateTime,
}
<span class="boring">}
</span></code></pre></pre>
<p>Utilizamos a linha <code>use crate::schema::*;</code> para disponibilizar a tabela <code>auth_user</code> neste contexto para que a &quot;anotação&quot; <code>table_name</code> funcione. Além disso, aplicamos as macros <code>Queryable, Insertable</code> para que possamos utilizar nossa struct com o postgres. Agora sabemos que vamos receber 2 argumentos para criar um user, que serão <code>email</code> e <code>password</code>, com isso podemos presupor que vamos precisar implementar uma função que gere um tipo <code>User</code> destes dois argumentos, algo como <code>fn from(email: String, password: String) -&gt; User</code>. Assim, podemos implementar um teste para esta funcão. Para este teste vamos ter que adicionar a crate <code>regex = &quot;1.3.4&quot;</code> ao nosso <code>[dev-dependencies]</code> do Cargo.toml:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;
    use regex::Regex;

    #[test]
    fn user_is_correctly_created() {
        let user = User::from(String::from(&quot;email&quot;), String::from(&quot;password&quot;));
        let rx = Regex::new(&quot;[0-9]{4}-[0-1]{1}[0-9]{1}-[0-3]{1}[0-9]{1} [0-2]{1}[0-9]{1}:[0-6]{1}[0-9]{1}:[0-6]{1}[0-9]{1}&quot;).unwrap();

        assert_eq!(user.email, String::from(&quot;email&quot;));
        assert_eq!(user.password, String::from(&quot;password&quot;));
        assert!(uuid::Uuid::parse_str(&amp;user.id.to_string()).is_ok());
        assert!(rx.is_match(&amp;format!(&quot;{}&quot;, user.expires_at.format(&quot;%Y-%m-%d %H:%M:%S&quot;))));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Neste teste estamos testando se <code>email</code> e <code>password</code> são exatamente como enviamos, se o <code>Uuid</code> é gerado como <code>Uuid</code> e se o formato da data está de acordo coma  regex <code>&quot;[0-9]{4}-[0-1]{1}[0-9]{1}-[0-3]{1}[0-9]{1} [0-2]{1}[0-9]{1}:[0-6]{1}[0-9]{1}:[0-6]{1}[0-9]{1}&quot;</code>. Agora podemos implementar a funcão <code>from</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        use chrono::{DateTime, Duration, Utc};

        let utc: DateTime&lt;Utc&gt; = Utc::now() + Duration::days(1);

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que está funcão começa com <code>use chrono::</code>, isso se deve ao fato de estas structs ainda não serem necessárias em outras partes do código. Depois disso vemos a linha <code>let utc: DateTime&lt;Utc&gt; = Utc::now() + Duration::days(1);</code>, que é depois inserida em <code>expires_at</code>, ela referencia a ideia de que o token vai sobreviver apenas até este período, que é deste instante até mais um dia. Podemos ainda simplificar esta função para extrair o <code>DateTime&lt;Utc&gt;</code> com <code>one_day_from_now()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora <code>one_day_from_now</code> está definida no módulo <code>src/todo_api/db/helpers.rs</code> como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Duration, Utc};
// ...
pub fn one_day_from_now() -&gt; DateTime&lt;Utc&gt; {
    Utc::now() + Duration::days(1)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="adaptando-o-request-para-um-modelo-de-banco-de-dados"><a class="header" href="#adaptando-o-request-para-um-modelo-de-banco-de-dados">Adaptando o request para um modelo de banco de dados.</a></h3>
<p>Agora precisamos de um modelo que represente o request HTTP de <code>signup</code>. Iremos criar o módulo <code>src/todo_api_web/model/auth.rs</code> com a struct <code>SignUp</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct SignUp {
    pub email: String,
    pub password: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que ambos campos são <code>pub</code>, isso é porque vamos precisar deles no <code>adapter</code>. Felizmente não podemos guardar o <code>password</code> como texto em nosso banco de dados, para isso vamos utilizar uma crate chamada bcrypt, adicionando <code>bcrypt = &quot;0.13&quot;</code> ao nosso <code>[dependencies]</code> do Cargo.toml (caso você se interesse por criptografia e queira outras opções, sugiro olhar também as crates <code>argonautica</code> e <code>libreauth</code>). Faremos está conversão no módulo <code>src/todo_api/adapter/auth.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api::model::auth::User;
use crate::todo_api_web::model::auth::SignUp;
use bcrypt::{hash, DEFAULT_COST};

pub fn signup_to_hash_user(su: SignUp) -&gt; User {
    let hashed_pw = hash(su.password, DEFAULT_COST);
    User::from(su.email, hashed_pw.unwrap())
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora importamos duas coisas ao escopo, a função <code>hash</code> e <code>DEFAULT_COST</code>. <code>bcrypt</code> possui 3 principais funções e um padrão de custo, que é <code>DEFAULT_COST</code> e definido como <code>12u32</code>. As funções são:</p>
<ol>
<li><code>hash</code> recebe um password do tipo genérico <code>P</code>, no nosso caso <code>password</code> do tipo <code>String</code> e um custo, no caso <code>DEFAULT_COST</code>.</li>
<li><code>verify</code> verifica se o <code>password</code> enviado é igual a <code>hash</code>enviada.</li>
<li><code>bcrypt</code> é similar ao <code>hash</code>, porém o segundo argumento é um <code>salt</code> do tipo <code>&amp;[u8]</code></li>
</ol>
<p>Quanto ao custo, quanto maior o valor de custo, mais lento o hashing. Existe um benchmark com diferentes custos que apresenta uma relação de custo por velocidade:</p>
<ul>
<li>Custo = 4: test bench_cost_4       ... bench:   1,197,414 ns/iter (+/- 112,856)</li>
<li>Custo = 10: test bench_cost_10      ... bench:  73,629,975 ns/iter (+/- 4,439,106)</li>
<li>Custo = 12: test bench_cost_default ... bench: 319,749,671 ns/iter (+/- 29,216,326)</li>
<li>Custo = 14: test bench_cost_14      ... bench: 1,185,802,788 ns/iter (+/- 37,571,986)</li>
</ul>
<p>Creio que podemos escrever um teste simples para <code>signup_to_hash_user</code> como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;
    use crate::todo_api_web::model::auth::SignUp;

    #[test]
    fn asser_signup_becomes_user() {
        let email = &quot;my@email.com&quot;;
        let pass = &quot;this Is a cr4zy p@ssw0rd&quot;;
        let signup = SignUp {
            email: String::from(email), 
            password: String::from(pass)
        };
        let user = signup_to_hash_user(signup);
        user.is_user_valid(email, pass)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Este teste que criamos funciona da seguinte maneira, ele cria um <code>SignUp</code> com valores fixos e passa para a função adapter <code>signup_to_hash_user</code>, depois disso validamos que os inputs passados para <code>SignUp</code> formam um <code>User</code> válido com <code>.is_user_valid(email, pass)</code>. Agora a função <code>is_user_valid</code> é um pouco diferente do que já vimos, pois ela é uma função que compila apenas para testes com <code>#[cfg(test)]</code>, e possui <code>asserts</code> internos. Os asserts foram movidos para o arquivo de <code>src/todo_api/model/auth.rs</code> pois os campos de <code>User</code> são privados:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    // ...

    #[cfg(test)]
    pub fn is_user_valid(self, email: &amp;str, password: &amp;str) {
        use bcrypt::verify;

        assert_eq!(self.email, String::from(email));
        assert!(verify(password, &amp;self.password).unwrap());
        assert!(self.id.to_string().len() == 36);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Com está função de teste podemos testar os valores internos de 1 User, comparando se o <code>email</code> interno é igual ao <code>email</code> recebido, se a string de <code>password</code> é um caso possível para <code>user.password</code> e se o <code>id</code> tem o tamanho de um <code>Uuid</code> do tipo <code>v4</code>. </p>
<h3 id="comunicando-signup-com-o-banco"><a class="header" href="#comunicando-signup-com-o-banco">Comunicando <code>SignUp</code> com o banco</a></h3>
<p>Agora temos <code>SignUp</code> e podemos converter em <code>User</code> com a função adapter <code>signup_to_hash_user</code>, falta inserir <code>User</code> no banco de dados para podermos criar nosso endpoint de <code>signup</code>. O primeiro passo para isso é criarmos a função <code>insert_new_user</code> em <code>src/todo_api/db/auth.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

pub fn insert_new_user(user: User, conn: &amp;mut PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let new_user = diesel::insert_into(auth_user)
        .values(&amp;user)
        .execute(conn);

    match new_user {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::UserNotCreated)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Na versão que estamos usando da lib diesel, connection tem que ser <a href="https://github.com/Diesel-rs/Diesel/blob/master/guide_drafts/migration_guide.md#mutable-connections-required">mutáveis</a></p>
<p>Vamos explicar o que se passa neste módulo. Precisamos de <code>PgConnection</code> para disponibilizar uma conexão a nosso <code>execute</code>, que é o executor da nossa query. <code>prelude::*</code> serve para disponibilizar funções como <code>execute</code>. Além disso, criamos um módulo para conter todos nossos erros de banco de dados em <code>src/todo_api/db/error.rs</code>, que possui o enum <code>DbError</code> que veremos a seguir. Depois disso, temos <code>use crate::schema::auth_user::dsl::*;</code>, que disponibiliza a table <code>auth_user</code> para utilizar em <code>insert_into(auth_user)</code>. Temos, também, <code>diesel::insert_into(auth_user).values(&amp;user).execute(conn)</code> que insere na tabale <code>auth_user</code> com <code>insert_into</code>, define seus valores de inserção com <code>values</code>, recebendo a struct <code>User</code>, e executa a query com <code>execute</code>, ou com <code>get_result</code> caso você queria algum dos valores existente no banco após a inserção. Por último aplicamos um <code>match</code> ao tipo <code>Result</code> de <code>new_user</code>, caso o tipo seja <code>Ok</code> retornamos um sucesso, caso o tipo seja <code>Err</code>, retornamos o erro <code>DbError::UserNotCreated</code>. Agora vamos para a implementação da trait <code>Error</code> em <code>DbError</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
pub enum DbError {
    UserNotCreated
}

impl std::fmt::Display for DbError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            DbError::UserNotCreated =&gt; write!(f, &quot;User could not be created&quot;)
        }        
    }
}

impl Error for DbError {
    fn description(&amp;self) -&gt; &amp;str {
        match self {
            DbError::UserNotCreated =&gt; &quot;User could not be created, check for possible conflits&quot;
        } 
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; {
        Some(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Por enquanto temos somente um item em <code>DbError</code>, <code>UserNotCreated</code>. E agora precisamos implementar a trait <code>std::error::Error</code> para que nosso enum possa ser utilizado como um tipo erro em nosso projeto. A trait <code>Error</code> exige duas funções <code>description</code> e <code>cause</code>. <code>cause</code> é importante caso nosso erro receba algum argumento, pois nos permite retornar coisas específica com <code>&amp;dyn</code>, já description é o texto que veremos quando, por exemplo, logarmos o erro. Além disso, notamos que a trait <code>Error</code> exige a implementação de <code>std::fmt::Display</code>, que corresponde ao <code>to_string()</code>. Agora podemos criar uma versão de teste desta função da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/db/auth.rs
#[cfg(test)]
mod test {
    use diesel::debug_query;
    use diesel::pg::Pg;
    use crate::schema::auth_user::dsl::*;

    #[test]
    fn insert_user_matches_url() {
        use crate::todo_api::model::auth::User;

        let user = User::from(String::from(&quot;email@my.com&quot;), String::from(&quot;pswd&quot;));
        let query = diesel::insert_into(auth_user).values(&amp;user);
        let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
                -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot;, \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;]&quot;;
        assert_eq!(sql, debug_query::&lt;Pg, _&gt;(&amp;query).to_string());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Eu acredito que testes que comparam strings caractere a caractere é uma péssima ideia, mas a comunidade Diesel parece gostar, quando formos testar a nível de integração usaremos outra estratégia. Notamos a presença de <code>debug_query</code> e <code>Pg</code>, ambos são responsáveis por nos permitir debugar a query que que montamos com <code>diesel::insert_into(auth_user).values(&amp;user)</code> sem executá-la. Depois fazemos um assert de nossa query com <code>let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \ -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot; \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;]&quot;;</code> que é uma string com o valor que esperamos para o sql. Note que estamos acessando os campos <code>id</code> e <code>expires_at</code> neste teste, para fazermos isso mudamos a implementação de <code>User</code> um pouco:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
#[derive(Debug, Serialize, Deserialize, Queryable, Insertable)]
#[table_name = &quot;auth_user&quot;]
pub struct User {
    #[cfg(test)] pub email: String,
    #[cfg(not(test))] email: String,
    #[cfg(test)] pub id: uuid::Uuid,
    #[cfg(not(test))] id: uuid::Uuid,
    #[cfg(test)] pub password: String,
    #[cfg(not(test))] password: String,
    #[cfg(test)] pub expires_at: chrono::NaiveDateTime,
    #[cfg(not(test))] expires_at: chrono::NaiveDateTime,
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Fizemos com que os campos sejam públicos para teste e privado para todos os outros ambientes. Agora implementaremos o endpoint em si.</p>
<blockquote>
<p>Formatando <code>expires_at</code> e a crate Chrono</p>
<p>Muitas vezes é complicado acertar diretamente qual o formato que você quer que sua string contendo a data tenha, por isso, aqui está um bom referencial para o tipo <code>UTC</code> do Chrono:</p>
<ul>
<li><code>assert_eq!(dt.format(&quot;%Y-%m-%d %H:%M:%S&quot;).to_string(), &quot;2014-11-28 12:00:09&quot;);</code></li>
<li><code>assert_eq!(dt.format(&quot;%a %b %e %T %Y&quot;).to_string(), &quot;Fri Nov 28 12:00:09 2014&quot;);</code></li>
<li><code>assert_eq!(dt.format(&quot;%a %b %e %T %Y&quot;).to_string(), dt.format(&quot;%c&quot;).to_string());</code></li>
<li><code>assert_eq!(dt.to_string(), &quot;2014-11-28 12:00:09 UTC&quot;);</code></li>
<li><code>assert_eq!(dt.to_rfc2822(), &quot;Fri, 28 Nov 2014 12:00:09 +0000&quot;);</code></li>
<li><code>assert_eq!(dt.to_rfc3339(), &quot;2014-11-28T12:00:09+00:00&quot;);</code></li>
<li><code>assert_eq!(format!(&quot;{:?}&quot;, dt), &quot;2014-11-28T12:00:09Z&quot;);</code></li>
</ul>
</blockquote>
<h3 id="definindo-o-endpoint"><a class="header" href="#definindo-o-endpoint">Definindo o endpoint</a></h3>
<p>Nosso primeiro passo é definir um teste para este endpoint e a partir deste teste podemos implementar a solução:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod  auth {
    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use actix_service::Service;
    use todo_server::todo_api_web::{
        routes::app_routes
    };
    use dotenv::dotenv;
    use crate::helpers::{read_json};
    use todo_server::todo_api_web::model::http::Clients;

    #[actix_rt::test]
    async fn signup_returns_created_status() {
        dotenv().ok();
        let app =
            test::init_service(App::new().app_data(Clients::new()).configure(app_routes)).await;

        let signup_req = test::TestRequest::post()
            .uri(&quot;/auth/signup&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;signup.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp = app.call(signup_req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::CREATED);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso teste define <code>signup_req</code> como o request que vamos enviar para <code>app.call(signup_req)</code>, mas este request possui uma nova <code>URI</code> <code>&quot;/auth/signup&quot;</code> e um novo arquivo Json com o conteúdo de post <code>&quot;signup.json&quot;</code>. Precisamos então definir este arquivo em <code>dev-resources</code> e implementar a rota. Note que o <code>assert</code> neste caso é somente para verificar se o usuário foi criado. O arquivo <code>signup.json</code> possui o seguinte formato:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;,
    &quot;password&quot;: &quot;My cr4azy p@ssw0rd&quot;
}
</code></pre>
<blockquote>
<p>Reconfigurando os testes</p>
<p>Ao executarmos os testes agora termos um retorno de <code>InternalServerError</code>, isso se deve ao fato de que <code>DbExecutor</code> não consegue encontrar a <code>DATABASE_URL</code> que está associada ao banco. Isso se deve pelo fato de estarmos utilizando uma url diferente para o docker compose e outra para testes locais. Além disso, Postgres é mais complicado que DynamoDB no sentido de que o cliente realmente tenta estabelecer uma conexão para iniciar e para isso precisamos de uma base de dados falsa executando. Além disso, essa base deve estar migrada para as queries ocorrerem sem problemas. Assim, nosso <code>make test</code> fica mais complicado:</p>
<pre><code class="language-Makefile">db:
	docker run -i --rm --name auth-db -p 5432:5432 -e POSTGRES_USER=auth -e POSTGRES_PASSWORD=secret -d postgres

test: db
  diesel setup --migration-dir src/migrations
  diesel migration run --migration-dir src/migrations
	cargo test --features &quot;dbtest&quot;
	diesel migration redo
 
clear-db:
  docker ps -a | awk '{ print $1,$2 }' | grep postgres | awk '{print $1 }' | xargs -I {} docker stop {}
</code></pre>
<p>Note que a partir da agora para rodar os testes precisamos de um container postgres configurado (<code>setup</code> e <code>migration run</code>) para podermos executar nossos testes sem quebrar o <code>DbExecutor</code>. Pode ser necessário adicionar um <code>sleep 3</code> depois de <code>test: db</code> para dar tempo do container executar. A última linha iniciada em <code>docker ps</code> serve para remover o container que executamos. Além disso, <code>DbExecutor</code> depende de <code>dotenv</code>, assim, devemos incluir <code>dotenv().ok()</code> antes de executar os testes e incorporar o <code>dotenv</code> no escopo com <code>use dotenv::dotenv;</code>. </p>
</blockquote>
<p>Agora que configuramos o teste, precisamos fazer a configuração de rotas, <code>app_routes</code> passa a ser:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user}
};
use actix_web::{web, HttpResponse};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(ping)
            .service(readiness)
            .service(create_todo)
            .service(show_all_todo)
            .service(signup_user)
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Ainda precisamos implementar o controller <code>signup_user</code> no módulo de controllers <code>auth</code>, porém ao contrário do método que vinhamos utilizando para inserir <code>User</code> no nosso banco de dados, que é o default do Diesel, vamos tirar proveito do sistema de actors do Actix e implementar um handler para permitir a comunição entre nosso serviço e o <code>Diesel</code> por mensagens. Assim, devemos mudar nossa struct <code>SignUp</code> para que ela implemente as traits <code>Handler</code> e <code>Message</code>, que vão nos permitir enviar mensagens para o <code>DbExecutor</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::prelude::*;
use crate::todo_api::{
    db::{
        error::DbError,
        helpers::DbExecutor,
    },
    adapter
};
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct SignUp {
    pub email: String,
    pub password: String,
}

impl Message for SignUp {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;SignUp&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: SignUp, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::schema::auth_user::dsl::*;
        use crate::diesel::RunQueryDsl;

        let user = adapter::auth::signup_to_hash_user(msg);
        let new_user = diesel::insert_into(auth_user)
            .values(&amp;user)
            .execute(&amp;mut self.0.get().expect(&quot;Failed to open connection&quot;));

        match new_user {
            Ok(_) =&gt; Ok(()),
            Err(_) =&gt; Err(DbError::UserNotCreated)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para a trait <code>Message</code> devemos implementar o tipo de retorna da comunicação, como no nosso caso não vamos retornar nada deixamos o <code>()</code> e caso ocorra um erro, retornamos o que já implementamos, <code>DbError</code>. Depois disso implementamos o <code>Handler</code> para <code>DbExecutor</code> com o tipo de mensagem <code>SignUp</code>, que possui a função <code>handle</code>. O primeiro argumento de <code>handle</code> é o prório <code>DbExecutor</code>, que está implementado como <code>struct DbExecutor(pub Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;)</code>, o segundo argumento é a mensagem, no nosso caso <code>SignUp</code>, e o terceiro argumento é o contexto do actix. Note que a função <code>handle</code> é praticamente igual a <code>insert_new_user</code>, mas em vez de passarmos um <code>PgConnection</code> passamos um <code>PooledConnection</code>, uma referência ao <code>Pool</code> de conexões que criamos em <code>DbExecutor</code>, e para isso precisamos adicionar <code>use crate::diesel::RunQueryDsl;</code> que altera nosso <code>execute</code> para poder realizar erstá operação. Com isto encaminhado, agora podemos criar o controller. Este controller será um pouco diferente do que usamos usualmente, pois o adapter se encontra dentro do <code>Handler</code> e o controller simplesmente ficará responsável por fazer a comunicação via mensagem entre os actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{HttpResponse, web, Responder};
use log::{error};
use crate::{
    todo_api_web::model::{
        http::Clients,
        auth::SignUp,
    }
};

pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    let signup = info.into_inner();

    let resp = state.postgres
        .send(signup)
        .await;

    match resp {
        Ok(_) =&gt; HttpResponse::Created(),
        Err(e) =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::InternalServerError()
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora estamos fazendo a conversão do tipo <code>web::Json&lt;SignUp&gt;</code> na nossa struct <code>SignUp</code> com <code>let signup = info.into_inner();</code> e enviando seu conteúdo para o <code>DbExecutor</code> através de:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp = state.postgres
    .send(signup)
    .await;
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos os testes agora veremos que eles falham, pois nosso teste tenta invocar o banco de dados de verdade, para isso, podemos utilizar a função que criamos anteriormente <code>insert_new_user</code> dentro do <code>Handler</code> para abstrair a lógica com o banco de dados e nos permitir utilizar features. Assim, a primeira mudança passa a ser o <code>handle</code> que utiliza o <code>insert_new_user</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler&lt;SignUp&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: SignUp, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::insert_new_user;

        let user = adapter::auth::signup_to_hash_user(msg);

        insert_new_user(user, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar uma solução de <code>insert_new_user</code>que utilize a feature <code>dynamo</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn insert_new_user(user: User, conn: &amp;mut PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let new_user = diesel::insert_into(auth_user)
        .values(&amp;user)
        .execute(conn);

    match new_user {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::UserNotCreated)
    }
}

#[cfg(feature = &quot;dynamo&quot;)]
pub fn insert_new_user(_user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;

    let user = User::from(String::from(&quot;my@email.com&quot;), String::from(&quot;My cr4azy p@ssw0rd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
            -- binds: [\&quot;my@email.com\&quot;, &quot;;
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(sql));
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(&quot;My cr4azy p@ssw0rd&quot;));

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Com o <code>#[cfg(feature = &quot;dynamo&quot;)]</code> fazemos uma query para <code>diesel_query</code> com os valores de <code>user</code> (não usamos <code>_user</code> pois seus campos são privados), como fizemos no módulo de testes e depois fazemos um assert que a query retornada de <code>debug_query::&lt;Pg, _&gt;(&amp;query).to_string()</code> contém a substring <code>sql</code> e que contém a substring de password <code>&quot;My cr4azy p@ssw0rd&quot;</code>. Depois disso retornamos <code>Ok(())</code> para conformar com o esperado do <code>Result</code>.</p>
<h2 id="validando-email-e-password"><a class="header" href="#validando-email-e-password">Validando email e password</a></h2>
<p>Agora vamos fazer algo pequeno, pois nosso objetivo é garantir que o email é no formato válido <code>\w{1,}@\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?</code> (regex significando qualquer conjunto de caracteres com mais de 1 elemento entre letras, números e <code>_</code>, seguido de <code>@</code>, repete o primeiro, seguido de ponto e 2 ou 3 caracteres de letras, seguido pela possível existência de ponto e 2 ou 3 caracteres de letras). Além disso, vamos garantir que o password contém umais de 32 caracteres, com letras maiúsculas e minúsculas, números e alguns caracterés especiais. </p>
<p>No controller <code>signup_user</code> adicionaremos uma validação da string de email com a crate Regex. Para isso definiremos nossa regex com <code>Regex::new</code> e depois compararemos com <code>is_match</code>. Caso a validação falhe, retornaremos <code>HttpResponse::BadRequest()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let signup = info.into_inner();
    if !email_regex.is_match(&amp;signup.email) {
        return HttpResponse::BadRequest();
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora usaremos uma regex que garante que a senha possua pelo menos uma letra maiúscula, pelo menos uma letra minúscula, pelo menos um número e pelo menos algum dos caracteres <code>@!=_#&amp;~[]{}?/</code> com uma tamanho entre 32 e 64 caracteres. Essa regex será <code>[[a-z]+[A-Z]+[0-9]+(\s@!=_#&amp;~\[\]\{\}\?\/)]{32,64}</code>. Cuidado que nosso teste deve falhar a partir de agora, para isso, modifiquei <code>signup.json</code> para:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;,
    &quot;password&quot;: &quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;
}
</code></pre>
<p>E atualizei <code>db/auth</code> para validar este novo password:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dynamo&quot;)]
pub fn insert_new_user(user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;

    let user = User::from(String::from(&quot;my@email.com&quot;), String::from(&quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) \
            -- binds: [\&quot;my@email.com\&quot;, &quot;;
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(sql));
    assert!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string().contains(&quot;My cr4azy p@ssw0rd My cr4azy p@ssw0rd&quot;));

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, podemos implementar a mudança no controller com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?\\/)]{32,64}&quot;).unwrap();
    
    let signup = info.into_inner();
    if !(email_regex.is_match(&amp;signup.email) &amp;&amp; pswd_regex.is_match(&amp;signup.password)) {
        return HttpResponse::BadRequest();
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Um bom exercício aqui seria criar alguns testes para o controller validar as novas regras do <code>email</code> e do <code>password</code>, lembrando que o teste de cenário válido já acontece a nível de integração. Alguns possíveis <code>emails</code> de teste são <code>&quot;my_email.com.br&quot;</code> ou <code>&quot;my@email.com.br.us&quot;</code>, além disso alguns casos interessantes de teste para <code>passwords</code> são <code>&quot;My Cr4zy p@ssw0rd&quot;</code>, <code>&quot;my cr4zy p@ssw0rd my cr4zy p@ssw0rd&quot;</code> e <code>&quot;My Crazy password My Crazy password&quot;</code>.</p>
<h2 id="implementando-login"><a class="header" href="#implementando-login">Implementando login</a></h2>
<p>O objetivo de nosso endpoint de login será retornar um token <code>jwt</code> com informações garantindo a validade do sistema. Assim, nosso endpoint receberá um <code>email</code> e um <code>password</code>, validará se o password é válido e retornará um token <code>jwt</code>, que passará a ser validado nos outros endpoints. </p>
<p>Podemos agora mudar a feature <code>dynamo</code> que atua sobre o Postgres e o DynamoDB para <code>db-test</code>. Para isso, devemos adicionar a feature a nosso Cargo.toml:</p>
<pre><code class="language-toml">[features]
db-test = []
</code></pre>
<p>E a nosso Makefile:</p>
<pre><code class="language-sh">test: db
	sleep 2
	diesel setup
	diesel migration run
	cargo test --features &quot;dbtest&quot;
	diesel migration redo

run-local:
	cargo run --features &quot;db-test&quot;
# ...
</code></pre>
<p>Por último, devemos modificar o arquivo <code>src/todo_api/db/auth.rs</code> para utilizar a nova feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use diesel::{PgConnection, prelude::*};

use crate::todo_api::model::auth::User;
use crate::todo_api::db::error::DbError;

#[cfg(not(feature = &quot;db-test&quot;))]
pub fn insert_new_user(user: User, conn: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    // ...
}

#[cfg(feature = &quot;db-test&quot;)]
pub fn insert_new_user(user: User, _: &amp;PgConnection) -&gt; Result&lt;(),DbError&gt;{
    // ...

    Ok(())
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Repita isso para os outros cenários.</p>
<h3 id="criando-o-endpoint-de-login"><a class="header" href="#criando-o-endpoint-de-login">Criando o endpoint de login</a></h3>
<p>A partir deste momento vou mudar a forma como apresento os testes, pois creio que já temos uma boa ideia de como eles funcionam. Assim, vou apresentar o teste que escrevi para cada endpoint, mas não resolverei eles mais de forma a relacionar o código sendo escrito ao teste que queremos resolver. Isso se deve ao fato de que eles são praticamente iguais. Assim, o teste deste endpoint seria apenas validar que o status é <code>200</code>, mas vamos mudar um pouco e esperar que a resposta venha com uma chave Json <code>token</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod  auth {
    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use todo_server::todo_api_web::{
        routes::app_routes
    };
    use crate::helpers::{read_json};
    use dotenv::dotenv;

    // ...
    #[actix_rt::test]
    async fn login_returns_token() {
        let mut app = test::init_service(
            App::new()
                .data(Clients::new())
                .configure(app_routes)
        ).await;

        let login_req = test::TestRequest::post()
            .uri(&quot;/auth/login&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;signup.json&quot;).as_bytes().to_owned())
            .to_request();

        let resp_body = test::read_response(&amp;mut app, login_req).await;

        let jwt: String = String::from_utf8(resp_body.to_vec()).unwrap();
        
        assert!(jwt.contains(&quot;token&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso próximo passo será definir o endpoint <code>/auth/login</code> que receberá um <code>POST</code> com um Json representado pela struct <code>Login</code>, que contém os mesmos campos de <code>SignUp</code>. Faremos uma nova struct para podermos tirar mais proveito do sistema de actors do Actix.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user, login}
};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(ping)
            .service(readiness)
            .service(create_todo)
            .service(show_all_todo)
            .service(signup_user)
            .service(login)
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}

<span class="boring">}
</span></code></pre></pre>
<p>Aqui adicionamo uma rota <code>login</code> que envia o request para o controller <code>login</code>. Agora vamos ao controller <code>login</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?)]{32,64}&quot;).unwrap();
    
    let login_user = info.clone();
    if !(email_regex.is_match(&amp;login_user.email) &amp;&amp; pswd_regex.is_match(&amp;login_user.password)) {
        return HttpResponse::BadRequest().finish();
    }

    let resp = state.postgres
        .send(login_user)
        .await;

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(r_users) =&gt; {
            match r_users {
                Err(e) =&gt; {
                    error!(&quot;{:?}&quot;,e);
                    HttpResponse::NoContent().finish()
                },
                Ok(users) =&gt; {
                    let user = users.first().unwrap();
                    match user.verify(info.clone().password) {
                        Ok(true) =&gt; generate_jwt(user, state).await,
                        Ok(false) =&gt; HttpResponse::NoContent().finish(),
                        Err(_) =&gt; HttpResponse::NoContent().finish()

                    }
                }
            }
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que podemos notar no controller de <code>login</code> é o <code>is_match</code> das regex, lembrando que usar regex pode sempre ser algo perigoso e devemos ter muito cuidado. Isso é algo que claramente podemos extrair. Em seguida repetimos o processo de outros outros controllers e enviamos uma mensagem com <code>Login</code> em <code>state.postgres.send(login_user).await</code>, nesta chamada recebemos um vetor de <code>User</code> que passam nosso filtro, porém como estamos filtrando pela chave primária <code>email</code> não pode haver conflitos. creio que a estração das verificações de email e de senha por regex fica com a seguinte cara:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn signup_user(state: web::Data&lt;Clients&gt;, info: web::Json&lt;SignUp&gt;) -&gt; impl Responder {
    let signup = info.into_inner();
    if !is_email_pswd_valids(&amp;signup.email, &amp;signup.password) {
        return HttpResponse::BadRequest();
    }

    // ...
}

pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    let login_user = info.clone();
    if !is_email_pswd_valids(&amp;login_user.email, &amp;login_user.password) {
        return HttpResponse::BadRequest().finish();
    }

    // ...
}

pub fn is_email_pswd_valids(email: &amp;str, pswd: &amp;str) -&gt; bool {
    use regex::Regex;

    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    let pswd_regex = Regex::new(&quot;[[a-z]+[A-Z]+[0-9]+(\\s@!=_#&amp;~\\[\\]\\{\\}\\?)]{32,64}&quot;).unwrap();
    
    email_regex.is_match(email) &amp;&amp; pswd_regex.is_match(pswd)
}
<span class="boring">}
</span></code></pre></pre>
<p>A vantagem deste formato, é que executar os testes fica ainda mais fácil, pois passam a ser validações unitárias, e o motivo pelo qual deixei anteriormente como exercícios. Assim, os testes podem ser como a seguir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod valid_email_pswd {
    use super::is_email_pswd_valids;

    #[test]
    fn valid_email_and_pswd() {
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
    }

    #[test]
    fn invalid_emails() {
        assert!(!is_email_pswd_valids(&quot;my_email.com&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
        assert!(!is_email_pswd_valids(&quot;my@email.com.br.us&quot;, &quot;My cr4zy P@ssw0rd My cr4zy P@ssw0rd&quot;));
    }

    #[test]
    fn invalid_passwords() {
        assert!(!is_email_pswd_valids(&quot;my@email.com.br&quot;, &quot;My cr4zy P@ssw0rd&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;my cr4zy p@ssw0rd my cr4zy p@ssw0rd&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My crazy P@ssword My crazy P@ssword&quot;));
        assert!(is_email_pswd_valids(&quot;my@email.com&quot;, &quot;My cr4zy Passw0rd My cr4zy Passw0rd&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Também podemos observar que no controller <code>login</code> há uma série de <code>HttpResponse::NoContent().finish()</code> para qualquer caso de erro. Duas coisas para observarmos aqui, a primeira é a presença de <code>finish</code> que se deve ao método <code>generate_jwt</code> que retorna um <code>HttpResponse</code>, a segunda é que presumo que quando alguém tenta logar em um serviço e ocorro qualquer problema, o serviço deve responder um <code>2XX</code> sem nenhuma informação, por isso do <code>NoContent</code>.</p>
<p>Agora podemos seguir para o caso que todas as extrações de <code>resp</code> via pattern matching e chegar em <code>user.verify(info.clone().password)</code>. O objetivo de função é validar que o <code>password</code> de <code>info: web:Json&lt;Login&gt;</code> é um password possível para a hash de <code>user.password</code>. Como está função é somente uma camada em volta da função original, já testada, não é imprescindível implementar testes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
impl User {
    use bcrypt::{verify, BcryptResult};
    // ...

    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        verify(pswd,&amp;self.password)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que a resposta de <code>verify</code> é do tipo <code>BcryptResult</code>, ou seja, temos 3 cenários:</p>
<ol>
<li><code>Ok(true)</code> -&gt; Caso na qual o <code>password</code> enviado é uma hash válida. </li>
<li><code>Ok(false)</code> -&gt; Caso na qual o <code>password</code> não é válido.</li>
<li><code>Err</code> -&gt; Ocorreu algum erro de validação.</li>
</ol>
<p>O único dos casos que é importante para nós é o caso <code>1</code>, por isso é o caso que aplicamos a função <code>generate_jwt</code>, cujo objetivo será gerar um token <code>jwt</code>. Além disso, está função não funcionará para o teste que criamos pois não estamos utilizando uma hash real, assim uma solução para isso é simplesmente responder um tipo <code>BcryptResult&lt;bool&gt;</code> com conteúdo <code>true</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    // ...

    #[cfg(not(feature = &quot;dbtest&quot;))]
    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        verify(pswd,&amp;self.password)
    }

    #[cfg(feature = &quot;dbtest&quot;)]
    pub fn verify(&amp;self, pswd: String) -&gt; BcryptResult&lt;bool&gt; {
        BcryptResult::Ok(true)
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Antes de continuar com <code>generate_jwt</code> precisamos explorar a implementação de <code>Login</code>, pois é o <code>Login</code> que é afetado pela função <code>state.postgres.send(login_user).await</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Login {
    pub email: String,
    pub password: String,
}

impl Message for Login {
    type Result = Result&lt;Vec&lt;User&gt;, DbError&gt;;
}

impl Handler&lt;Login&gt; for DbExecutor {
    type Result = Result&lt;Vec&lt;User&gt;, DbError&gt;;

    fn handle(&amp;mut self, msg: Login, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Login recebe um <code>email</code> e um <code>password</code> para depois procurar no banco de dados com <code>scan_user</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scan_user(user_email: String, conn: &amp;mut PgConnection) -&gt; Result&lt;Vec&lt;User&gt;,DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let items = auth_user
            .filter(email.eq(&amp;user_email))
            .load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users),
        Err(_) =&gt; Err(DbError::CannotFindUser)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>É bastante simples o que acontece aqui, filtramos na tabela <code>auth_user</code> por um <code>user_email</code> que seja igual ao que enviamos. Caso essa lista seja maior que 1, houve um problema no banco de dados, pois como <code>email</code> é uma chave primária não podem haver 2, ou mais, repetidos. Qualquer outro <code>Err</code> é um <code>DbError</code> de não encontrar o usuário ou problemas de conexão. Temos um <code>Ok</code> extra que valida se a lista é zero, e retorna o erro <code>CannotFindUser</code> como a cláusula <code>Err</code>. E o <code>Ok</code> restante é o caso que procuramos. Note que ainda temos um refactor a fazer aqui, este refactor é modificar o tipo de retorno <code>Result&lt;Vec&lt;User&gt;,DbError&gt;</code> para <code>Result&lt;User,DbError&gt;</code> utilizando um <code>.first().unwrap()</code>, já que temos certeza que esse <code>first</code> existe. Além disso, precisamos adaptar este código para o teste, já que a ação <code>user.filter(email.eq(&amp;user_email)).load::&lt;User&gt;(conn)</code> não deve existir. Fazemos essa adaptação retornando um <code>Ok</code> com um <code>User</code> contendo o email que enviamos. Na função <code>scan_user</code> com a feature <code>dbtest</code> ainda fazemos um assert na query que será gerada por <code>auth_user.filter(email.eq(&amp;user_email))</code> e validamos com o <code>debug_query</code>. Caso você prefira substituir o <code>password</code> por uma hash válida para a senha sendo enviada no teste, não seria mais necessário utilizar a <code>cfg feature</code> para <code>verify</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn scan_user(user_email: String, conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let items = auth_user
            .filter(email.eq(&amp;user_email))
            .load::&lt;User&gt;(conn);

    match items {
        Ok(users) if users.len() &gt; 1 =&gt; Err(DbError::DatabaseConflit),
        Ok(users) if users.len() &lt; 1 =&gt; Err(DbError::CannotFindUser),
        Ok(users) =&gt; Ok(users.first().unwrap().clone().to_owned()),
        Err(_) =&gt; Err(DbError::CannotFindUser)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn scan_user(user_email: String, _conn: &amp;PgConnection) -&gt; Result&lt;User, DbError&gt;{
    use crate::schema::auth_user::dsl::*;
    use diesel::debug_query;
    use diesel::pg::Pg;
    let query = auth_user.filter(email.eq(&amp;user_email));
    let expected = &quot;SELECT \&quot;auth_user\&quot;.\&quot;email\&quot;, \&quot;auth_user\&quot;.\&quot;id\&quot;, \&quot;auth_user\&quot;.\&quot;password\&quot;, \&quot;auth_user\&quot;.\&quot;expires_at\&quot;, \&quot;auth_user\&quot;.\&quot;is_active\&quot; FROM \&quot;auth_user\&quot; WHERE \&quot;auth_user\&quot;.\&quot;email\&quot; = $1 -- binds: [\&quot;my@email.com\&quot;]&quot;.to_string();

    assert_eq!(debug_query::&lt;Pg, _&gt;(&amp;query).to_string(), expected);
    Ok(User::from(user_email, &quot;this is a hash&quot;.to_string()))
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora nossa <code>resp</code> de <code>state.postgres.send(login_user).await</code> pode ser resolvida em uma <code>match</code>, na qual a cláusula de <code>Err</code> vai simplesmente retornar um <code>NoContent</code> a cláusula <code>Ok</code> vai aplicar um novo <code>match</code> em <code>verify</code>. De acordo com a resposta de verify, criamos o token. O caso <code>Err</code> é simplesmente um <code>NoContent</code> porque houve um problema na criação da hash, já o caso <code>Ok(false)</code> corresponde a senha incorreta. No caso <code>Ok(true)</code>, criamos o token em <code>generate_jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api_web/controller/auth.rs
pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Login&gt;) -&gt; impl Responder {
    // ...

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(user) =&gt; {
            let usr = user.unwrap();
            match usr.verify(info.clone().password) {
                Ok(true) =&gt; generate_jwt(usr, state).await,
                Ok(false) =&gt; HttpResponse::NoContent().finish(),
                Err(_) =&gt; HttpResponse::NoContent().finish()
            }
        }
    }
}

// src/todo_api_web/model/auth.rs
impl Message for Login {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Login&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Login, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora falta implementarmos o <code>generate_jwt</code> para completarmos esse fluxo.</p>
<h3 id="gerando-um-token-jwt"><a class="header" href="#gerando-um-token-jwt">Gerando um token <code>JWT</code></a></h3>
<p>O objetivo de criarmos um token <code>JWT</code> é permitir que o usuário faça requisições para páginas que exigem autentição, e até autorização (é possível passar tokens de autorização), com um token de autenticação no header do request. Essa autenticação vai conter algumas informações cruciais que vão nos permitir validar este token no nosso banco de dados. As informação que vamos adicionar ao token neste momento são as contidas na struct <code>User</code> exceto <code>password</code>. </p>
<ul>
<li>É importante lembrar que o tópico de segurança é bastante complicado e não é o foco do livro, assim, a solução que vamos apresentar é útil, mas longe de ser uma solução aplicável em produção. </li>
</ul>
<p>Infelizmente, a função <code>generate_jwt</code> é cheio de efeitos colaterais e muito dificil de testar unitariamente, assim, vamos pular os testes dele por hora. Vamos manter essa função em um módulo <code>core</code>, a ideia desse módulo é conter a lógica associada à <code>src/todo_api</code>, mesmo que a função <code>generate_jwt</code> possua muitos efeitos colaterais e estará localizada em <code>src/todo_api/core/mod.rs</code>. O primeiro Efeito colaterial dele é criar uma nova data de expiração para daqui um dia com <code>crate::todo_api::db::helpers::one_day_from_now().naive_utc()</code>. Essa data será usada para criar uma struct que fará a atualização da data em <code>User</code>. Essa struct é chamada <code>UpdateDate</code> e contém dois campos <code>email</code> e <code>expires_at</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>JWT</strong></p>
<p>JWT, ou Json Web Token, é um padrão aberto baseado na <strong>RFC 7519</strong> que define uma forma compacta e auto contida de transmitir de forma segura entre duas partes em um formato Json. Este token pode ser assinado com uma chave secreta via <code>HMAC</code> ou chaves publicas/privadas via <code> RSA</code> ou <code>ECDSA.</code> Estes tokens podem ser encriptados ou não e os dois principais casos de uso são autorização e troca de informações. A estrutura de um JWT é <code>header</code>, <code>payload</code> e <code>assinatura</code>, assim o formato acaba sendo algo como <code>hhhhh.pppppp.aaaaa</code>. Usualmente o <code>header</code> possui duas partes o tipo, usualmente <code>&quot;typ&quot;: &quot;jwt&quot;</code> e o algoritmo que pode ser <code>HMAC SHA256 ou RSA</code>, algo como <code>&quot;alg&quot;: &quot;HS256&quot;</code>. <code>payload</code> é onde as informações que queremos trocar estão armazenadas. E assinatura, ou <code>signature</code>, é uma informação de como entender esses dados. Com o algoritmo <code>HMAC SHA256</code> a criação de um JWT o seguinte formato <code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code>, note que <code>payload</code> e <code>header</code> estão em um formato <code>base64</code>.</p>
</blockquote>
<p>Agora precisamos implementar a struct <code>UpdateDate</code>. Essa struct está estritamente associada a ao módulo <code>core</code> atuando somente como um complemento a lógica, por isso adicionel ela em <code>src/todo_api/core/model.rs</code>, mas se você achar mais adequado é correto também deixar <code>generate_jwt</code> em <code>src/todo_api/controller/core.rs</code> e <code>UpdateDate</code> em <code>src/todo_api/model/core.rs</code>. Agora, nossa struct também precisa poder se comunicar por mensagem com nosso postgres e para isso vamos implementar as traits <code>Message</code> e <code>Handle</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix::prelude::*;
use crate::todo_api::{
    db::{
        error::DbError,
        helpers::DbExecutor,
    },
};

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct UpdateDate {
    pub email: String,
    pub expires_at: chrono::NaiveDateTime,
}

impl Message for UpdateDate {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;UpdateDate&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: UpdateDate, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::update_user_jwt_date;

        update_user_jwt_date(msg, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que o tipo <code>Result</code> da nossa <code>Message</code> é apenas um <code>Result</code> com um <code>Ok</code> vazio e um erro do tipo <code>DbError</code>, <code>Result&lt;(), DbError&gt;</code>. Neste caso precisamos somente saber se o update da data foi bem sucedido ou falho, com qual erro. Assim, a função <code>handle</code>simplesmente atualiza a <code>expires_at</code> no banco conforme a chave <code>email</code>. É importante também garantir que <code>expires_at</code> seja do tipo <code>chrono::NaiveDateTime</code> para não termos problemas com o tipo da tabela <code>auth_user</code>. Vamos agora olhar a função <code>update_user_jwt_date</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target).set(expires_at.eq(update_date.expires_at)).execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para <code>update_user_jwt_date</code> precisamos disponibilizar a <code>dsl</code> de <code>auth_user</code> para fazermos operações na tabela e fazemos isso com <code>use crate::schema::auth_user::dsl::*;</code>. A primeira linha de código é encontrar o <code>User</code> alvo através de um <code>filter</code> que procura a igualdade entre os campos <code>email</code> com <code>auth_user.filter(email.eq(update_date.email))</code> sendo definido em um <code>let target</code>. Depois disso fazemos um <code>update</code> nesse <code>target</code> com <code>diesel::update(target)</code> e com isso podemos fazer um <code>set</code> do campo <code>expires_at</code> com o valor de <code>expires_at</code> de <code>update_date</code> com <code>set(expires_at.eq(update_date.expires_at))</code>. O resultado disso será um tipo <code>Result&lt;(), DbError&gt;</code>, que podemos utilizar em um <code>match</code> para fazer pattern matching e retornar se o update foi bem sucedido. Para realizar o teste pulamos a parte do <code>target</code>e do <code>match</code>, retornando apenas um <code>Ok(())</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target)
        .set((expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active)))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn update_user_jwt_date(_update_date: UpdateDate, _conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>De volta a <code>generate_jwt</code> fazemos este update de forma a utilizar os recursos de <code>Actor</code> enviando uma mensagem para <code>UpdateDate</code> com <code>let resp = state.postgres.send(update_date);</code>. Note que esta função é <code>async</code> e não estamos esperando ela com o <code>await</code>, isso se deve ao fato de que as duas próximas tarefas não precisam que <code>resp</code> esteja concluída. Enquanto esperamos o momento oportuno para concretizar <code>resp</code> com <code>await</code> iniciamos a criação efeitva do token e sua preparação para o tipo de resposta <code>Jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
    };

    let resp = state.postgres
        .send(update_date.clone());

    let token_jwt = create_token(user, update_date);
    let jwt = crate::todo_api::core::model::Jwt::new(token_jwt);    

    match resp.await {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E o tipo <code>Jwt</code> localizado em <code>src/todo_api/core/model.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
pub struct Jwt{
    token: String
}

impl Jwt {
    pub fn new(jwt: String) -&gt; Self {
        Self {
            token: jwt
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Antes de concretizarmos <code>resp</code> com um <code>await</code> criamos o token com <code>create_token</code> e passamos este valor para a struct <code>Jwt</code> com <code>let jwt = crate::todo_api::core::model::Jwt::new(token_jwt);</code>. <code>create_token</code> é a função responsável por montar o token com os campos necessários.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_token(user: User, update_date: UpdateDate) -&gt; String {
    use serde_json::json;
    use jsonwebtokens::{Algorithm, AlgorithmID, encode};
    use chrono::Utc;

    let alg = Algorithm::new_hmac(AlgorithmID::HS256, &quot;secret&quot;).unwrap();
    let header = json!({ &quot;alg&quot;: alg.name(), &quot;typ&quot;: &quot;jwt&quot;, &quot;date&quot;:  Utc::now().to_string()});
    let payload = json!({ &quot;id&quot;: user.clone().get_id(), &quot;email&quot;: user.email, &quot;expires_at&quot;: update_date.expires_at });
    encode(&amp;header, &amp;payload, &amp;alg).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que fazemos em <code>create_token</code> é gerar o algoritmo com a struct <code>Algorithm</code>.  Como vamos utilizar um algoritmo <code>HMAC SHA256</code> chamamos a função <code>new_hmac</code> e passamos como argumento o id que tipo que vamos utilizar com <code>AlgorithmID::HS256</code> e o segredo que vai ser passado. Uma boa alternativa para não ter o segredo exposto assim é ler ele de uma variável de ambiente. Depois disso, definimos o <code>header</code> com o algoritmo, o tipo e a data de criação em <code>json!({ &quot;alg&quot;: alg.name(), &quot;typ&quot;: &quot;jwt&quot;, &quot;date&quot;:  Utc::now().to_string()});</code>, note o uso da macro <code>json!</code> vinda de <code>serde_json</code>. Da mesma forma que com header, criamos o <code>payload</code> com os campos que nos interessam, <code>id, email, expires_at</code>. Por último geramos o token passando todas estas informações como argumento para função <code>encode</code> em <code>encode(&amp;header, &amp;payload, &amp;alg).unwrap()</code>.</p>
<p>Para finalizar precisamos que <code>generate_jwt</code> responda um status com o conteúdo do token. Para isso fazemos um match em <code>resp</code> e retornamos <code>HttpResponse::InternalServerError().finish()</code> para o caso de <code>Err</code> e para o caso de <code>Ok</code> retornamos um <code>HttpResponse::Ok()</code> com um Json contendo a struct <code>Jst</code> serializada:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    // ...
    let resp = state.postgres.send(update_date.clone());
    let token_jwt = create_token(user, update_date);
    let jwt = crate::todo_api::model::core::Jwt::new(token_jwt);

    match resp.await {
        Ok(_) =&gt; {
            HttpResponse::Ok()
                .content_type(&quot;application/json&quot;)
                .json(jwt)
        }
        Err(e) =&gt; {
            error!(&quot;{:?}&quot;, e);
            HttpResponse::InternalServerError().finish()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Login pronto. Agora precisamos implementar o logout.</p>
<h2 id="implementando-o-logout"><a class="header" href="#implementando-o-logout">Implementando o logout</a></h2>
<p>Um login é útil, mas pode ser necessário apagarmos a sessão que temos com o serviço e para fazer isso é necessário realizar um <code>logout</code>, que atende pelo método <code>DELETE</code>. Nosso logout vai modificar nosso user de modo que tenhamos um campo booleano <code>is_active</code>. Este campo tem como responsabilidade dizer se o <code>user</code> enviado no token ainda está autenticado. Assim, vamos adicionar o campo <code>is_active</code> ao struct <code>User</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/model/auth.rs
// ...
#[derive(Debug, Serialize, Deserialize, Clone, Queryable, Insertable)]
#[table_name = &quot;auth_user&quot;]
pub struct User {
    pub email: String,
    pub id: uuid::Uuid,
    #[cfg(test)] pub password: String,
    #[cfg(not(test))] password: String,
    #[cfg(test)] pub expires_at: chrono::NaiveDateTime,
    #[cfg(not(test))] expires_at: chrono::NaiveDateTime,
    pub is_active: bool
}

impl User {
    pub fn from(email: String, password: String) -&gt; Self {
        let utc = crate::todo_api::db::helpers::one_day_from_now();

        Self {
            email: email,
            id: uuid::Uuid::new_v4(),
            password: password,
            expires_at: utc.naive_utc(),
            is_active: false
        }
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Se observarmos o <code>rls</code> do editor vamos perceber o aviso de que <code>Insertable</code> está com problemas, este problema é que <code>is_active</code> não está mapeado. Para isso devemos criar uma migração com este campo, chamaremos ela de <code>valid_auth</code> e executaremos <code>diesel migration generate valid_auth</code> que criará uma nova pasta dentro de migrations, algo como <code>2020-02-22-011512_valid_auth</code>. Depois disso adicionaremos um <code>up.sql</code> e um <code>down.sql</code>:</p>
<pre><code class="language-sql">&lt;-- UP.sql --&gt;
ALTER TABLE auth_user
  ADD is_active BOOLEAN NOT NULL DEFAULT 'f';

&lt;-- DOWN.sql --&gt;
ALTER TABLE auth_user
  DROP is_active;
</code></pre>
<p>Esse script consiste em alterar a tabela <code>auth_user</code> para conter ou não o campo <code>is_active</code>. Com isso pronto executaremos <code>make db</code> e em seguida <code>diesel setup</code> para modificar o <code>schema.rs</code> que ficará assim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table! {
    auth_user (email) {
        email -&gt; Varchar,
        id -&gt; Uuid,
        password -&gt; Varchar,
        expires_at -&gt; Timestamp,
        is_active -&gt; Bool,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Lembre de adicionar <code>embed_migrations!();</code> depois de <code>table!(...)</code>. Antes de continuarmos com <code>logout</code> precisamos que o <code>login</code> ative a o campo <code>is_active</code> e para isso a struct <code>UpdateDate</code> precisa receber um novo campo booleano <code>is_active</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/core/model.rs
// ...
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct UpdateDate {
    pub email: String,
    pub expires_at: chrono::NaiveDateTime,
    pub is_active: bool
}
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Se rodarmos os testes agora veremos que o teste <code>insert_user_matches_url</code> de <code>src/todo_api/db/auth</code> falha pois não espera o campo <code>is_active</code>:</p>
<pre><code>esperado: &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;) VALUES ($1, $2, $3, $4) -- binds: [\&quot;email@my.com\&quot;, 0f3d625b-c85c-490c-b979-f20cbbd6a71d, \&quot;pswd\&quot;, 2020-02-23T19:31:34.896595]&quot;`,
encontrado: &quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;, \&quot;is_active\&quot;) VALUES ($1, $2, $3, $4, $5) -- binds: [\&quot;email@my.com\&quot;, 0f3d625b-c85c-490c-b979-f20cbbd6a71d, \&quot;pswd\&quot;, 2020-02-23T19:31:34.896595, false]&quot;`
</code></pre>
<p>Assim, devemos editar o teste para conter o campo <code>is_active</code> com valor default <code>false</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insert_user_matches_url() {
    use crate::todo_api::model::auth::User;

    let user = User::from(String::from(&quot;email@my.com&quot;), String::from(&quot;pswd&quot;));
    let query = diesel::insert_into(auth_user).values(&amp;user);
    let sql = String::from(&quot;INSERT INTO \&quot;auth_user\&quot; (\&quot;email\&quot;, \&quot;id\&quot;, \&quot;password\&quot;, \&quot;expires_at\&quot;, \&quot;is_active\&quot;) VALUES ($1, $2, $3, $4, $5) \
            -- binds: [\&quot;email@my.com\&quot;, &quot;) + &amp;user.id.to_string() + &quot;, \&quot;pswd\&quot;, &quot; + &amp;format!(&quot;{:?}&quot;, user.expires_at) +&quot;, false]&quot;;
    assert_eq!(&amp;sql, &amp;debug_query::&lt;Pg, _&gt;(&amp;query).to_string());
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos modificar também <code>core/mod.rs</code> para setar o campo <code>is_active</code> como true na função <code>generate_jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn generate_jwt(user: User, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    let utc = crate::todo_api::db::helpers::one_day_from_now().naive_utc();

    let update_date = UpdateDate {
        email: user.email.clone(),
        expires_at: utc,
        is_active: true,
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim como a função de <code>db/auth</code> <code>update_user_jwt_date</code>, que agora precisa setar o campo <code>is_active</code> como <code>true</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update_user_jwt_date(update_date: UpdateDate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt;{
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(update_date.email));
    match diesel::update(target)
        .set((expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active)))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora <code>diesel::update(target)</code> precisa atualizar 2 campos, e para isso é precisa enviar como parâmetro uma tupla contendo os dois campos a serem atualizados <code>(expires_at.eq(update_date.expires_at), is_active.eq(update_date.is_active))</code>. Com isso, podemos agora continuar com o <code>logout</code>.</p>
<p>Para nosso <code>logout</code> precisamos começar criando o endpoint <code>/auth/logout</code> com o método delete:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::todo_api_web::controller::{
    // ...
    auth::{signup_user, login, logout}
};
use actix_web::{web, HttpResponse};

pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(ping)
            .service(readiness)
            .service(create_todo)
            .service(show_all_todo)
            .service(signup_user)
            .service(login)
            .service(logout)
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>O teste para este cenário será:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn logout_accepted() {
    dotenv().ok();
    let mut app = test::init_service(
        App::new()
            .data(Clients::new())
            .configure(app_routes)
    ).await;

    let logout_req = test::TestRequest::delete()
        .uri(&quot;/auth/logout&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .header(&quot;x-auth&quot;, &quot;token&quot;)
        .set_payload(read_json(&quot;logout.json&quot;).as_bytes().to_owned())
        .to_request();

    let resp = test::call_service(&amp;mut app,logout_req).await;
    assert_eq!(resp.status(), StatusCode::ACCEPTED);
}
<span class="boring">}
</span></code></pre></pre>
<p>E <code>logout.json</code> será:</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;my@email.com&quot;
}
</code></pre>
<p>Agora com o teste pronto podemos passar para entender o controller de <code>logout</code>. Em <code>logout</code> vamos receber o email como parâmetro e um token válido, conforme o teste. Com o email vamos buscar a entidade a ser atualizada e no token vamos verificar a validade do token e se pertence ao usuário correto. Uma vez que as validações estiverem corretas, inativamos seu token com <code>is_active: false</code>. Não é tão crítico garantir o <code>logout</code> por não se tratar de um código em produção e por ser pouco sensível invalidar um token, caso você queira levar este código a produção, garanta a melhor estratégia com sua equipe de segurança. No nosso controller a primeira coisa que precisamos fazer é verificar se o conteúdo de <code>Logout</code> é um email de verdade, para evitar superficialmente <code>SQL Injection</code>. Fazemos isso com:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Logout&gt;) -&gt; impl Responder {
    use regex::Regex;

    let logout_user = info.clone();
    let email_regex = Regex::new(&quot;\\w{1,}@\\w{2,}.[a-z]{2,3}(.[a-z]{2,3})?$&quot;).unwrap();
    
    if !email_regex.is_match(&amp;logout_user.email) {
        return HttpResponse::BadRequest().finish();
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Perceba que caso o campo email não coincida com a regex, nos retornamos <code>BadRequest</code>. Além disso, ainda falta implementarmos a struct <code>Logout</code> que nos permitirá trocar mensagens com o actor de <code>DbExecutor</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_web_api/model/auth.rs
// ...
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Logout {
    pub email: String,
}

impl Message for Logout {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Logout&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Logout, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Vale salientar que a função <code>scan_user</code> já possui implementação para a feature <code>db-test</code>. Além disso, é importante ressaltar que a struct <code>Logout</code> faz exatamente a mesma coisa que a struct <code>Login</code>, exceto pelo fato de que <code>Login</code> possui o campo <code>password</code>, por isso podemos simplificar a nosso <code>model</code> contendo apenas um tipo de <code>Login/Logout</code> com o campo <code>password</code> opcional. Assim <code>Login</code> pode se transformar em <code>Auth</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Auth {
    pub email: String,
    pub password: Option&lt;String&gt;,
}

impl Message for Auth {
    type Result = Result&lt;User, DbError&gt;;
}

impl Handler&lt;Auth&gt; for DbExecutor {
    type Result = Result&lt;User, DbError&gt;;

    fn handle(&amp;mut self, msg: Auth, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::scan_user;

        scan_user(msg.email, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim, precisamos atualizar nosso <code>controller/auth</code> para utilizar <code>Auth</code> em vez de <code>Login</code> e <code>Logout</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn login(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    let login_user = info.clone();
    if !is_email_pswd_valids(&amp;login_user.email, &amp;login_user.password.clone().unwrap()) {
        return HttpResponse::BadRequest().finish();
    }

    let resp = state.postgres
        .send(login_user)
        .await;

    match resp {
        Err(e)  =&gt; {
            error!(&quot;{:?}&quot;,e);
            HttpResponse::NoContent().finish()
        },
        Ok(user) =&gt; {
            let usr = user.unwrap();
            match usr.verify(info.clone().password.unwrap()) {
                Ok(true) =&gt; generate_jwt(usr, state).await,
                Ok(false) =&gt; HttpResponse::NoContent().finish(),
                Err(_) =&gt; HttpResponse::NoContent().finish()
            }
        }
    }
}

pub async fn logout(state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Para continuarmos com <code>logout</code> precisamos receber o conteúdo do header em um request, fazemos isso adicionando o request aos argumentos de <code>logout</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {...}
<span class="boring">}
</span></code></pre></pre>
<p>Para acessarmos o conteúdo que enviamos agora vamos utilizar de uma função chamada <code>headers</code>, que retorna um mapa com todos os headers disponíveis. Nosso header de autorizaçnao terá uma cara um pouco diferente, pois se chamará <code>x-auth</code> e para obtermos ele basta chamarmos a função <code>get</code> que nos retornará um <code>Option</code> de <code>HeaderValue</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    use regex::Regex;

    let jwt = req.headers().get(&quot;x-auth&quot;);
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora vamos fazer uma pequena mudança para tornar mais claro e organizado o controller. A função <code>is_email_pswd_valids</code> não pertence a este domínio, assim moveremos ela, e seus testes, para o módulo de core em <code>src/todo_api/core/mod.rs</code>, lembre-se de utilizar o <code>use crate::todo_api::core</code> no controller.</p>
<p>Em <code>logout</code> paramos no match do <code>email</code>, mas agora com a informação de email queremos receber informações de <code>User</code> para podermos fazer validações para o logout. Fazemos isso utilizando <code>let resp = state.postgres.send(logout_user.clone())</code> que se comporta de forma identica ao caso de <code>login</code>, e como não temos necessidade desta informação agora, podemos não utilizar o <code>await</code> imediatamente. O próximo passo é entender o estado associado ao valor <code>jwt</code>, fazemos isso em um <code>match</code>, na qual a cláusula <code>None</code> é uma resposta de <code>BadRequest</code> e a resposta <code>Some</code> vai agir sobre <code>jwt</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...
    let resp = state.postgres
        .send(logout_user.clone());

    match jwt {
        None =&gt; return HttpResponse::BadRequest().finish(),
        Some(jwt) =&gt; {
            let jwt_value : JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap())).expect(&quot;failed to parse JWT Value&quot;);
            match validate_jwt_date(jwt_value.expires_at) {
                false =&gt; 
                    HttpResponse::Unauthorized().finish(),
                true =&gt; {
                    validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;))
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que devemos fazer em <code>Some</code> é decodificar o <code>jwt</code> com a função <code>decode_jwt</code>, que recebe como argumento um tipo <code>&amp;str</code> (<code>jwt.to_str().unwrap(</code>). Nosso uso de <code>decode_jwt</code> é bem simples, pois queremos apenas saber se o token ainda é válido, fazemos isso da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/todo_api/core/mod.rs
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    use jsonwebtokens::raw::{TokenSlices, split_token, decode_json_token_slice};

    let TokenSlices {claims, .. } = split_token(jwt).unwrap();
    let claims = decode_json_token_slice(claims).expect(&quot;Failed to decode token&quot;);
    claims
}
<span class="boring">}
</span></code></pre></pre>
<p>A função <code>decode_jwt</code> consiste em separar os tokents do argumento <code>jwt</code> em partes como <code>claims</code> e <code>headers</code> e depois aplicar a função <code>decode_json_token_slice</code> para extrair o tipo <code>serde_json::value::Value</code> de <code>claims</code> e retornar <code>Value</code>. Essa implementação falharia nosso teste, assim precisamos retornar algum valor aleatório de <code>Value</code>, fazemos isso utilizando <code>serde_json::from_str</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;db-test&quot;)]
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    serde_json::from_str(&quot;{\&quot;expires_at\&quot;: \&quot;2020-11-02T00:00:00\&quot;, \&quot;id\&quot;: \&quot;bc45a88e-8bb9-4308-a206-6cc6eec9e6a1\&quot;, \&quot;email\&quot;: \&quot;my@email.com\&quot;}&quot;).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>Essa função não necessita grandes testes, já que ela não vai ser alterada com o tempo, mas é sempre bom testar que os valores batem. Assim, o módulo a seguire testa um token Jwt criado no site jwt.io e os valores de seu <code>claim</code> sendo transformado em Json pela macro <code>json!</code>. Depois disso, testamos a igualdade das partes. Com o teste a seguir vamos quebrar nossa pipeline de testes, pois este teste não utilzia a feature <code>dbtest</code> e é executado junto com todos os oturos testes. A solução mais simples para isso é separar testes unitários de testes de integração. Assim, criaremos um target <code>unit</code> no Makefile que executará <code>cargo test --lib</code>, e os testes de integração serão executados com <code>cargo test --test lib --features &quot;dbtest&quot;</code> que executará toda <code>lib</code> de <code>tests/lib</code>. Note os argumentos <code>--locked</code>, <code>--no-fail-fast</code> e <code>-- --test-threads 3</code>, que representam validar o <code>Cargo.lock</code>, não terminar o processo quando algum testes falha e executar os testes em 3 threads, repectivamente. Além disso, os testes <code>all_args_are_equal_is_accepted</code> e <code>all_args_are_not_equal_is_unauth</code> deverão ser movidos para a pasta de testes de integração <code>tests</code>, pois necessitam da feature <code>db-test</code>, coloquei eles em um módulo <code>todo_api_web/validation</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod decode_jwt {
    use super::decode_jwt;
    use serde_json::json;

    #[test]
    fn decodes_random_jwt() {
        let jwt = decode_jwt(&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6InRlc3QiLCJpYXQiOjE1MTYyMzkwMjJ9.tRF6jrkFnCfv6ksyU-JwVq0xsW3SR3y5cNueSTdHdAg&quot;);
        let expected = json!({&quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;test&quot;, &quot;iat&quot;: 1516239022 });

        assert_eq!(jwt, expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-sh">int: db
	sleep 2
	diesel setup
	diesel migration run
	cargo test --test lib --no-fail-fast --features &quot;dbtest&quot; -- --test-threads 3
	diesel migration redo


unit:
	cargo test --locked --no-fail-fast --lib -- --test-threads 3

test: unit int
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// todo_api_web/validation.rs
use todo_server::todo_api::core::{validate_jwt_info};
use todo_server::todo_api::model::auth::User;
use todo_server::todo_api_web::model::http::Clients;
use actix_web::http::StatusCode;

#[actix_rt::test]
async fn all_args_are_equal_is_accepted() {
    use dotenv::dotenv;
    dotenv().ok();

    let exec = Clients::new();
    let state = actix_web::web::Data::new(exec);

    let user = User::from(&quot;my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
    let email = &quot;my@email.com&quot;.to_string();

    let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
    assert_eq!(resp.status(), StatusCode::ACCEPTED);
}

#[actix_rt::test]
async fn all_args_are_not_equal_is_unauth() {
    use dotenv::dotenv;
    dotenv().ok();

    let exec = Clients::new();
    let state = actix_web::web::Data::new(exec);

    let user = User::from(&quot;not_my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
    let email = &quot;my@email.com&quot;.to_string();

    let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois de aplicarmos <code>decode_jwt</code> ao valor <code>jwt</code> transformamos este dado em algo manipulável coma struct que representa seu formato <code>JwtValue</code>, <code>let jwt_value :JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap()))</code>.  Com <code>jwt_value</code> em mãos podemos checar se a data está correta coma função <code>validate_jwt_date</code>, que verificar se a data do momento é inferior ou igual a <code>expires_at</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn validate_jwt_date(jwt_expires: chrono::NaiveDateTime) -&gt; bool {
    chrono::Utc::now().naive_utc() &lt;= jwt_expires
}
<span class="boring">}
</span></code></pre></pre>
<p>Com este teste implementado a função <code>#[cfg(feature = &quot;db-test&quot;)] decode_jwt</code> deve começar a falhar a partir do dia 2 de Novembro, assim, precisamos modificar ela para algo mais próximo de infinito, como mil anos deste momento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;db-test&quot;)]
pub fn decode_jwt(jwt: &amp;str) -&gt; Value {
    serde_json::from_str(&quot;{\&quot;expires_at\&quot;: \&quot;3020-11-02T00:00:00\&quot;, \&quot;id\&quot;: \&quot;bc45a88e-8bb9-4308-a206-6cc6eec9e6a1\&quot;, \&quot;email\&quot;: \&quot;my@email.com\&quot;}&quot;).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>Voltando a <code>validate_jwt_date</code>, seu tipo de retorno é um booleano, que podemos fazer <code>match</code> para validar as respostas. Caso a resposta seja false, respondemos com <code>HttpResponse::Unauthorized().finish()</code> e caso seja verdadeiro chamamos um outra função que validará as informações internas, <code>validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;))</code>. Essa validação consiste em validar a coerência entre todos os <code>email</code>s, do Jwt, do Json enviado pelo <code>DELETE</code> e o salvo no banco. Note que o <code>email</code> salvo no banco é chamado através da concretização da future <code>resp</code> com <code>await</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn validate_jwt_info(jwt_email: String, req_email: String, user: Result&lt;User, DbError&gt;) -&gt; HttpResponse {
    match user {
        Err(_) =&gt; HttpResponse::Unauthorized().finish(),
        Ok(u) =&gt; {
            if u.email == jwt_email &amp;&amp; jwt_email == req_email {
                HttpResponse::Accepted().finish()
            } else {
                HttpResponse::Unauthorized().finish()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A primeira coisa que fazemos em <code>validate_jwt_info</code> é um <code>match</code> de seu <code>Result</code>. Se ocorrer algum erro, o mais fácil é simplesmente responder que a pessoa não tem autorização. Caso não ocorram erros, velrificamos a igualdade entre os emails com <code>if u.email == jwt_email &amp;&amp; jwt_email == req_email </code>, retornando <code>HttpResponse::Accepted().finish()</code> em caso de sucesso e <code>HttpResponse::Unauthorized().finish()</code> em caso de falha. Outro ponto importante aqui é que <code>is_active</code> deve se tornar falso. E para isso precisamos criar uma nova struct <code>Inactivate</code> que comunicará com <code>DbExecutor</code> para inativar o email associado:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct Inactivate {
    pub email: String,
    pub is_active: bool
}
<span class="boring">}
</span></code></pre></pre>
<p>Que pode ter uma função <code>new</code> que recebe o <code>email</code> é já cria a struct com <code>is_active = false</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Inactivate {
    pub fn new(email: String) -&gt; Self {
        Self {
            email: email,
            is_active: false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Depois disso precisamos implementar as traits <code>Message</code> e <code>Handle</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Message for Inactivate {
    type Result = Result&lt;(), DbError&gt;;
}

impl Handler&lt;Inactivate&gt; for DbExecutor {
    type Result = Result&lt;(), DbError&gt;;

    fn handle(&amp;mut self, msg: Inactivate, _: &amp;mut Self::Context) -&gt; Self::Result {
        use crate::todo_api::db::auth::inactivate_user;

        inactivate_user(msg, &amp;mut self.0.get().expect(&quot;Failed to open connection&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Quando a <code>inactivate_user</code>, seu corpo é muito parecido com <code>update_user_jwt_date</code>, pois encontramos o <code>target</code> da mesma forma, mas fazemos update apenas no campo <code>is_active</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn inactivate_user(msg: Inactivate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(msg.email));
    match diesel::update(target)
        .set(is_active.eq(msg.is_active))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, a função de teste é exatamente igual a <code>update_user_jwt_date</code>, pois retorna somente um <code>Ok(())</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dbtest&quot;))]
pub fn inactivate_user(msg: Inactivate, conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    use crate::schema::auth_user::dsl::*;

    let target = auth_user.filter(email.eq(msg.email));
    match diesel::update(target)
        .set(is_active.eq(msg.is_active))
        .execute(conn) {
        Ok(_) =&gt; Ok(()),
        Err(_) =&gt; Err(DbError::TryAgain)
    }
}

#[cfg(feature = &quot;dbtest&quot;)]
pub fn inactivate_user(_msg: Inactivate, _conn: &amp;PgConnection) -&gt; Result&lt;(), DbError&gt; { 
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Para finalizar a atualização devemos enviar a struct como mensagem com <code>state.postgres.send</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn validate_jwt_info(jwt_email: String, req_email: String, user: Result&lt;User, DbError&gt;, state: web::Data&lt;Clients&gt;) -&gt; HttpResponse {
    match user {
        Err(_) =&gt; HttpResponse::Unauthorized().finish(),
        Ok(u) =&gt; {
            if u.email == jwt_email &amp;&amp; jwt_email == req_email {
                let inactivate = Inactivate::new(req_email);
                let is_inactive = state.postgres.send(inactivate).await;

                match is_inactive {
                    Ok(_) =&gt; HttpResponse::Accepted().finish(),
                    Err(_) =&gt; HttpResponse::Unauthorized().finish()
                }
            } else {
                HttpResponse::Unauthorized().finish()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Algumas coisas mudaram. Agora precisamos passar <code>state</code> como argumento <code>state: web::Data&lt;Clients&gt;</code> e ao utilizarmos <code>state.postgres.send(inactivate)</code>, precisamos de um <code>await</code>, que exige que nossa função passe a ser <code>async</code> com <code>pub async fn validate_jwt_info</code>. Além disso, chamamos a função <code>new</code> da struct <code>Inactivate</code> com algum dos emails que temos e depois enviamos ela para <code>DbExecutor</code> com <code>let is_inactive = state.postgres.send(inactivate).await;</code>. Um pattern matching simples em <code>is_inactive</code> nos permite responder <code>Accepted</code> para o único caso que ocorreu tudo bem. Lembre de incorporar <code>crate::todo_api::core::model::Inactivate</code> em seu escopo e de modificar o controller de <code>logout</code> para enviar o <code>state</code> e utilizar <code>await</code> em <code>validate_jwt_info</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn logout(req: HttpRequest, state: web::Data&lt;Clients&gt;, info: web::Json&lt;Auth&gt;) -&gt; impl Responder {
    // ...

    match jwt {
        None =&gt; return HttpResponse::BadRequest().finish(),
        Some(jwt) =&gt; {
            let jwt_value : JwtValue = serde_json::from_value(decode_jwt(jwt.to_str().unwrap())).expect(&quot;failed to parse JWT Value&quot;);
            match validate_jwt_date(jwt_value.expires_at) {
                false =&gt; 
                    HttpResponse::Unauthorized().finish(),
                true =&gt; {
                    validate_jwt_info(jwt_value.email, logout_user.email, resp.await.expect(&quot;Failed to read contact info&quot;), state).await
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora, os testes <code>all_args_are_equal_is_accepted</code> e <code>all_args_are_not_equal_is_unauth</code> em <code>core/mod.rs</code> passam a falhar por não receberem o state correto. Como a função <code>validate_jwt_info</code> passou a ser <code>async</code> sua testabilidade diminuiu, junto com isso vamos utilizar <code>CLients::new</code> que depende de <code>dotenv</code> estar executando. Para isso, devemos criar um <code>web::Data&lt;CLients&gt;</code> que será passado como argumento e disponibilizar um runtime para <code>async</code> com <code>#[actix_rt::test]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
    async fn all_args_are_equal_is_accepted() {
        use dotenv::dotenv;
        dotenv().ok();

        let exec = Clients::new();
        let state = actix_web::web::Data::new(exec);

        let user = User::from(&quot;my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
        let email = &quot;my@email.com&quot;.to_string();
        
        let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
        assert_eq!(resp.status(), StatusCode::ACCEPTED);
    }

    #[actix_rt::test]
    async fn all_args_are_not_equal_is_unauth() {
        use dotenv::dotenv;
        dotenv().ok();

        let exec = Clients::new();
        let state = actix_web::web::Data::new(exec);

        let user = User::from(&quot;not_my@email.com&quot;.to_string(), &quot;pass&quot;.to_string());
        let email = &quot;my@email.com&quot;.to_string();

        let resp = validate_jwt_info(email.clone(), email, Ok(user), state).await;
        assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Por último, precisamos dar uma organizada no nosso código.</p>
<h2 id="refatorando"><a class="header" href="#refatorando">Refatorando</a></h2>
<p>Existem três coisas que eu gostaria de refatorar no momento. A primeira é o módulo de erros <code>db/error.rs</code>, que está totalmente deslocado. A segunda é mover o <code>core/model.rs</code> para <code>model/core.rs</code>, pois creio que agora já cresceu bastante. E a terceira é encontrar um nome melhor para <code>UpdateDate</code>,  como <code>UpdateUserStatus</code>. Começando pela terceira, selecionei para que meu editor de texto encontrasse todos os casos de <code>UpdateDate</code> e substituisse eles por <code>UpdateUserStatus</code> sem grandes conflitos. Depois disso, vamos mover o módulo de erros. Para iniciarmos o processo, precisamos mover a definição do módulo de <code>db/mod.rs</code> para <code>model/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//db/mod.rs
pub mod helpers;
pub mod todo;
pub mod auth;

// model/mod.rs
use aws_sdk_dynamodb::model::AttributeValue;
use std::collections::HashMap;
use uuid::Uuid;

pub mod auth;
pub mod error;
// ...
<span class="boring">}
</span></code></pre></pre>
<p>Movemos todo o arquivo e precisamores modificar o caminho do <code>use</code> deste arquivo nos seguintes arquivos:</p>
<ul>
<li><code>src/todo_api/core</code> em <code>mod.rs</code> e <code>model.rs</code>.</li>
<li><code>src/todo_api/db/auth.rs</code></li>
<li><code>src/todo_api_web/model/auth.rs</code></li>
</ul>
<p>São mudanças bastante simples, basta substituir o <code>db</code> pelo <code>model</code> nos caminhos dos <code>use</code>. E para a segunda mudança, vamos criar o módulo <code>core</code> em <code>model/mod.rs</code>  com <code>pub mod core</code> e mover o arquivo <code>core/model.rs</code> para <code>model/core.rs</code>. Vamos modificar os mesmos arquivos que modificamos em <code>db/error</code>, a única diferença é que a função <code>generate_jwt</code> incorporava <code>Jwt</code> em seu escopo de forma individual. Executando nossos testes com <code>make test</code> está tudo ok e podemos continuar para implementar o requerimento de jwt nas chamadas dos endpoints que já temos.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-1/04-serving.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../part-1/06-middleware.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-1/04-serving.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../part-1/06-middleware.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
