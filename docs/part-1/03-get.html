<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Obtendo todas as Todo Cards inseridas - Desenvolvimento Web em Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../0-capa.html">Capa</a></li><li class="chapter-item expanded affix "><a href="../intro/1-about.html">Sobre autora</a></li><li class="chapter-item expanded affix "><a href="../intro/2-Audience.html">Público alvo</a></li><li class="chapter-item expanded affix "><a href="../intro/3-book.html">Como o livro está organizado</a></li><li class="chapter-item expanded affix "><a href="../intro/4-setup.html">Instalando Rust</a></li><li class="chapter-item expanded affix "><a href="../intro/5-exercício.html">Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded affix "><a href="../part-1/00-capa.html">Todo Server com Actix</a></li><li class="chapter-item expanded "><a href="../part-1/01-ping-pong.html"><strong aria-hidden="true">1.</strong> Configurando os primeiros endpoints</a></li><li class="chapter-item expanded "><a href="../part-1/02-create.html"><strong aria-hidden="true">2.</strong> Criando Tarefas</a></li><li class="chapter-item expanded "><a href="../part-1/03-get.html" class="active"><strong aria-hidden="true">3.</strong> Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded "><a href="../part-1/04-serving.html"><strong aria-hidden="true">4.</strong> Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded "><a href="../part-1/05-auth.html"><strong aria-hidden="true">5.</strong> Autenticação</a></li><li class="chapter-item expanded "><a href="../part-1/06-middleware.html"><strong aria-hidden="true">6.</strong> Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded "><a href="../part-1/07-ci.html"><strong aria-hidden="true">7.</strong> Configurando um CI</a></li><li class="chapter-item expanded "><a href="../part-1/08-conclusao.html"><strong aria-hidden="true">8.</strong> Concluindo o serviço</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="obtendo-todas-as-todo-cards-inseridas"><a class="header" href="#obtendo-todas-as-todo-cards-inseridas">Obtendo todas as Todo Cards inseridas</a></h1>
<p>Existem muitas abordagens para como vamos adicionar um novo endpoint no nosso sistema, mas a abordagem que eu gostaria de tratar aqui é a de começar de cima para baixo, ou seja, criamos um endpoint <code>GET</code> que lé todas as <code>TodoCard</code> e nos retorna elas no formato Json. Dessa vez vamos começar escrevendo um teste para este novo endpoint:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod read_all_todos {
    use todo_server::todo_api_web::{
        routes::app_routes
    };

    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use actix_service::Service;

    #[actix_rt::test]
    async fn test_todo_index_ok() {
        let mut app = test::init_service(
            App::new()
                .configure(app_routes)
        ).await;
    
        let req = test::TestRequest::with_uri(&quot;/api/index&quot;).to_request();
    
        let resp = app.call(req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::OK);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Felizmente, nosso teste falha retornanto um <code>NOT_FOUND</code> e nos obriga a implementar a nova rota, <code>index</code> em <code>src/todo_api_web/routes.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;/&quot;)
            .service(
                web::scope(&quot;api/&quot;)
                .route(&quot;create&quot;, web::post().to(create_todo))
                .route(&quot;index&quot;, web::get().to(show_all_todo)))
            .route(&quot;ping&quot;, web::get().to(pong))
            .route(&quot;~/ready&quot;, web::get().to(readiness))
            .route(&quot;&quot;, web::get().to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora estamos utilizando uma nova função controller chamada de <code>show_all_todo</code>, ela precisa ser incorporada no escopo da função, fazemos isso através de <code>use crate::todo_api_web::controller::todo::show_all_todo</code> e recebemos um aviso de que ela não existe, assim devemos implementá-la no módulo <code>src/todo_api_web/controller/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_all_todo() -&gt; impl Responder {
    HttpResponse::Ok()
}
<span class="boring">}
</span></code></pre></pre>
<p>Como nosso teste checa apenas o retorno do status <code>200</code>, isso é suficiente. Nosso próximo passo é implementar um teste um pouco mais robusto. Esse teste consiste em garantir que o JSON recebido possua um vetor de tamanho 1 após um post em <code>api/create</code> ser enviado:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>od read_all_todos {
    use todo_server::todo_api_web::{
        model::TodoCardsResponse,
        routes::app_routes
    };

    use actix_web::{
        test, App,
        http::StatusCode,
    };
    use actix_service::Service;
    use serde_json::from_str;

    use crate::helpers::read_json;

    #[actix_rt::test]
    async fn test_todo_index_ok() {
        // ...
    }

    #[actix_rt::test]
    async fn test_todo_cards_count() {
        let mut app = test::init_service(
            App::new()
                .configure(app_routes)
        ).await;
    
        let post_req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();

        let _ = app.call(post_req).await.unwrap();
        let req = test::TestRequest::with_uri(&quot;/api/index&quot;).to_request();
        let resp = test::read_response(&amp;mut app, req).await;

        let todo_cards: TodoCardsResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
        assert_eq!(todo_cards.cards.len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para fazer isso vamos criar uma struct serializável para o formato Json. Essa struct se encontrará em <code>sr/todo_api_web/model/mod.rs</code> e se chamará <code>TodoCardsResponse</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct TodoCardsResponse {
    pub cards: Vec&lt;String&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que no momento não precisamos nos preocupar com o tipo de resposta, somente com a struct e seus campos. Agora precisamos fazer nosso controller retornar um vetor com uma String:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//src/todo_api_web/controller/todo.rs
pub async fn show_all_todo() -&gt; impl Responder {
    HttpResponse::Ok()
        .content_type(&quot;application/json&quot;)
        .body(serde_json::to_string(&amp;TodoCardsResponse{cards: vec![String::from(&quot;test&quot;)]}).expect(&quot;Failed to serialize todo cards&quot;))
}
<span class="boring">}
</span></code></pre></pre>
<p>Com este teste pronto, nosso próximo teste fica bastante simples, pois agora precisamos fazer um teste quase igual, mas que garanta que o retorno seja um <code>TodoCard</code> com as informações que postamos. Note que como este teste conterá um mock da resposta do banco de dados, podemos simplesmente adicionar um <code>Uuid</code> pré-determinado no mock. Vou criar uma função de teste, no módulo de <code>helpers</code> que retorna um vetor com uma <code>TodoCard</code>, <code>mock_get_todos</code>.</p>
<blockquote>
<p>Note que <code>TodoCard</code> não possui um id, assim temos duas opções: a primeira é criar um <code>TodoCardResponse</code>, que contém um Id e a segunda é modificarmos a <code>TodoCard</code> para conter um campo <code>id: Option&lt;Uuid&gt;</code>. Nós vamos seguir a segunda abordagem, cuja única mudança será adicionar <code>id: None,</code> no teste <code>converts_json_to_db</code> encontrado em <code>src/todo_api/adapter/mod.rs</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use todo_server::todo_api_web::model::{State, Task, TodoCard};

// ...

pub fn mock_get_todos() -&gt; Vec&lt;TodoCard&gt; {
    vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
        title: String::from(&quot;This is a card&quot;),
        description: String::from(&quot;This is the description of the card&quot;),
        owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
        tasks: vec![
            Task {
                title: String::from(&quot;title 1&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 2&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 3&quot;),
                is_done: false,
            },
        ],
        state: State::Doing,
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>Com nossa função implementada, podemos criar o novo cenário de teste no submódulo <code>read_all_todos</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_rt::test]
async fn test_todo_cards_with_value() {
    let mut app = test::init_service(
        App::new()
            .configure(app_routes)
    ).await;

    let post_req = test::TestRequest::post()
        .uri(&quot;/api/create&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
        .to_request();

    let _ = app.call(post_req).await.unwrap();
    let req = test::TestRequest::with_uri(&quot;/api/index&quot;).to_request();
    let resp = test::read_response(&amp;mut app, req).await;

    let todo_cards: TodoCardsResponse = from_str(&amp;String::from_utf8(resp.to_vec()).unwrap()).unwrap();
    assert_eq!(todo_cards.cards, mock_get_todos());
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que agora os tipos de <code>todo_cards.cards, mock_get_todos()</code> são incompatíveis, assim, devemos modificar a a struct <code>TodoCardsResponse</code> para:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, PartialEq)]
pub struct TodoCardsResponse {
    pub cards: Vec&lt;TodoCard&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Também é necessário, para fins de teste, implementarmos a trait <code>PartialEq</code> para todas as structs, e enums, derivadas de <code>TodoCardsResponse</code>. Com essa mudança, precisamos modificar a lógica do nosso controller já que agora é necessário que ele busque <code>TodoCard</code>s no banco. Faremos isso pela função <code>get_todos</code>, que retornará <code>Vec&lt;TodoCard&gt;</code>. Caso o <code>match</code> retorne, não podemos enviar um erro <code>500</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn show_all_todo() -&gt; impl Responder {
    match get_todos() {
        None =&gt; HttpResponse::InternalServerError().body(&quot;Failed to read todo cards&quot;),
        Some(todos) =&gt; HttpResponse::Ok()
            .content_type(&quot;application/json&quot;)
            .body(serde_json::to_string(&amp;TodoCardsResponse{cards: todos}).expect(&quot;Failed to serialize todo cards&quot;)),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar a função <code>get_todos</code>, mas antes vamos implementar a versão de teste (<code>feature = dynamo</code>) da função em <code>src/todo_api/db/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dynamo&quot;)]
pub fn get_todos() -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use crate::todo_api_web::model::{State, Task};
    use rusoto_dynamodb::DynamoDb;

    let _ = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        ..ScanInput::default()
    };

    Some(vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
        title: String::from(&quot;This is a card&quot;),
        description: String::from(&quot;This is the description of the card&quot;),
        owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
        tasks: vec![
            Task {
                title: String::from(&quot;title 1&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 2&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 3&quot;),
                is_done: false,
            },
        ],
        state: State::Doing,
    }])
}
<span class="boring">}
</span></code></pre></pre>
<p>Note a presença da struct <code>ScanInput</code>. Ela está presente como forma de garantir em teste que a construção dela está coerente. Ao rodarmos o teste (comente o <code>#[cfg(feature = &quot;dynamo&quot;)]</code>), obtemos sucesso! Agora podemos partir para a leitura da base de dados de fato. Nossa função de <code>get_todos</code> vai precisar de algumas mudanças como um <code>let client = client()</code> e fazer esse <code>client</code> executar um <code>scan</code> no banco de dados com o valor de <code>scan_item</code>. Em caso de <code>Err</code> no <code>match</code> retornamos <code>None</code> e em caso de sucesso precisamos passar a função por um <code>adapter</code> que transforma um <code>ScanOutput</code> em um vetor de <code>TodoCard</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dynamo&quot;))]
pub fn get_todos() -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use crate::todo_api::db::helpers::client;
    use rusoto_dynamodb::DynamoDb;

    let client = client();
    let scan_item = ScanInput {
        limit: Some(100i64),
        table_name: TODO_CARD_TABLE.to_string(),
        ..ScanInput::default()
    };

    match client.scan(scan_item).sync() {
        Ok(resp) =&gt; Some(adapter::scanoutput_to_todocards(resp)),
        Err(_) =&gt; None,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que limitamos o <code>ScanInput</code> a <code>100i64</code>, isso se deve ao fato de que o Dynamo não vai responder mais de 100 itens. Se você precisar de mais, é importante realizar filtros no scan. Antes de implementarmos o <code>adapter</code>, seria bom dar uma olhada em como é um <code>ScanOutput</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ScanOutput { 
    consumed_capacity: None, 
    count: Some(2), 
    items: Some([
        {&quot;title&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;title&quot;), ss: None }, 
        &quot;description&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;descrition&quot;), ss: None }, 
        &quot;owner&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;), ss: None }, 
        &quot;state&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;Done&quot;), ss: None }, 
        &quot;id&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;), ss: None }, 
        &quot;tasks&quot;: AttributeValue { b: None, bool: None, bs: None, l: Some([
            AttributeValue { b: None, bool: None, bs: None, l: None, m: Some({
                &quot;is_done&quot;: AttributeValue { b: None, bool: Some(true), bs: None, l: None, m: None, n: None, ns: None, null: None, s: None, ss: None }, 
                &quot;title&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;blob&quot;), ss: None }
            }), 
            n: None, ns: None, null: None, s: None, ss: None }]), m: None, n: None, ns: None, null: None, s: None, ss: None }
        }, 
        {&quot;owner&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;), ss: None }, 
        &quot;description&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;descrition&quot;), ss: None }, 
        &quot;id&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;23997c2c-cd10-477f-8838-e88f2f6d7e7d&quot;), ss: None }, 
        &quot;state&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;Done&quot;), ss: None }, 
        &quot;title&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;title&quot;), ss: None }, 
        &quot;tasks&quot;: AttributeValue { b: None, bool: None, bs: None, l: Some([
            AttributeValue { b: None, bool: None, bs: None, l: None, m: Some({
                &quot;title&quot;: AttributeValue { b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;blob&quot;), ss: None }, 
                &quot;is_done&quot;: AttributeValue { b: None, bool: Some(true), bs: None, l: None, m: None, n: None, ns: None, null: None, s: None, ss: None }}), n: None, ns: None, null: None, s: None, ss: None }
            ]),m: None, n: None, ns: None, null: None, s: None, ss: None }
        }]), 
    last_evaluated_key: None, 
    scanned_count: Some(2) }
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos começar a implementar a função <code>scanoutput_to_todocards</code> e, para isso, vamos escrever o primeiro teste com apenas um <code>items</code> em <code>src/todo_api/adapters/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod scan_to_cards {
    use super::scanoutput_to_todocards;
    use crate::todo_api_web::model::{Task, TodoCard, State};
    use rusoto_dynamodb::ScanOutput;

    fn scan_with_one() -&gt; ScanOutput {
        let mut tasks_hash = std::collections::HashMap::new();
        tasks_hash.insert(&quot;title&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;blob&quot;.to_string()), ss: None });
        tasks_hash.insert(&quot;is_done&quot;.to_string(), AttributeValue{ b: None, bool: Some(true), bs: None, l: None, m: None, n: None, ns: None, null: None, s: None, ss: None });
        let mut hash = std::collections::HashMap::new();
        hash.insert(&quot;title&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;title&quot;.to_string()), ss: None });
        hash.insert(&quot;description&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;description&quot;.to_string()), ss: None });
        hash.insert(&quot;owner&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;.to_string()), ss: None });
        hash.insert(&quot;id&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;.to_string()), ss: None });
        hash.insert(&quot;state&quot;.to_string(), AttributeValue{ b: None, bool: None, bs: None, l: None, m: None, n: None, ns: None, null: None, s: Some(&quot;Done&quot;.to_string()), ss: None });
        hash.insert(&quot;tasks&quot;.to_string(), AttributeValue { b: None, bool: None, bs: None, l: Some(vec![
            AttributeValue { b: None, bool: None, bs: None, l: None, m: Some(tasks_hash), n: None, ns: None, null: None, s: None, ss: None }]), m: None, n: None, ns: None, null: None, s: None, ss: None });

        ScanOutput { 
            consumed_capacity: None, 
            count: Some(1), 
            items: Some(vec![hash]), 
            last_evaluated_key: None, 
            scanned_count: Some(1) }
    }

    #[test]
    fn scanoutput_has_one_item() {
        let scan = scan_with_one();
        let todos = vec![
            TodoCard {
                title: &quot;title&quot;.to_string(),
                description: &quot;description&quot;.to_string(),
                state: State::Done,
                id: Some(uuid::Uuid::parse_str(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;).unwrap()),
                owner: uuid::Uuid::parse_str(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;).unwrap(),
                tasks: vec![
                    Task {
                        is_done: true,
                        title: &quot;blob&quot;.to_string()
                    }
                ]
            }
        ];

        assert_eq!(scanoutput_to_todocards(scan), todos)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos finalmente implementar nossa função <code>scanoutput_to_todocards</code> para o caso de 1 <code>items</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scanoutput_to_todocards(scan: ScanOutput) -&gt; Vec&lt;TodoCard&gt; {
    let item = scan.items.unwrap()[0].to_owned();

    vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(&amp;item.get(&quot;id&quot;).unwrap().s.clone().unwrap()).unwrap()),
        owner: uuid::Uuid::parse_str(&amp;item.get(&quot;owner&quot;).unwrap().s.clone().unwrap()).unwrap(),
        title: item.get(&quot;title&quot;).unwrap().s.clone().unwrap(),
        description: item.get(&quot;description&quot;).unwrap().s.clone().unwrap(),
        state: State::from(item.get(&quot;state&quot;).unwrap().s.clone().unwrap()),
        tasks: item .get(&quot;tasks&quot;).unwrap().l .clone().unwrap()
            .iter()
            .map(|t| Task {
                title: t.clone().m.unwrap().get(&quot;title&quot;).unwrap()
                    .s.clone().unwrap(),
                is_done: t.clone().m.unwrap().get(&quot;is_done&quot;).unwrap()
                    .bool.clone().unwrap(),
            })
            .collect::&lt;Vec&lt;Task&gt;&gt;(),
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>Infelizmente o código de <code>scanoutput_to_todocards</code> conta com muitas referências e tipos <code>Option</code>, o que nos força a ter um excesso de <code>clone()</code> e <code>unwrap()</code>, mas basicamente estamos navegando por dentro dos tipos de <code>AttributeValue</code> e, quando o tipo é um <code>HashMap</code>, utilizamos <code>get</code>. Agora podemos testar o caso para um <code>scan</code> com dois conjuntos de <code>AttributeValue</code>. Para isso, vamos isolar a criação dos <code>HashMap</code> em <code>scan_with_one</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attr_values() -&gt; std::collections::HashMap&lt;String, AttributeValue&gt; {
        let mut tasks_hash = std::collections::HashMap::new();
        tasks_hash.insert(
            &quot;title&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None, 
                ns: None, null: None, s: Some(&quot;blob&quot;.to_string()), ss: None,
            },
        );
        tasks_hash.insert(
            &quot;is_done&quot;.to_string(),
            AttributeValue {
                b: None, bool: Some(true), bs: None, l: None,
                m: None, n: None, ns: None, null: None, s: None,  ss: None,
            },
        );
        let mut hash = std::collections::HashMap::new();
        hash.insert(
            &quot;title&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None, s: Some(&quot;title&quot;.to_string()), ss: None,
            },
        );
        hash.insert(
            &quot;description&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None,s: Some(&quot;description&quot;.to_string()), ss: None,
            },
        );
        hash.insert(
            &quot;owner&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None, s: Some(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;.to_string()),
                ss: None,
            },
        );
        hash.insert(
            &quot;id&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None, s: Some(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;.to_string()),
                ss: None,
            },
        );
        hash.insert(
            &quot;state&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None, l: None, m: None, n: None,
                ns: None, null: None, s: Some(&quot;Done&quot;.to_string()), ss: None,
            },
        );
        hash.insert(
            &quot;tasks&quot;.to_string(),
            AttributeValue {
                b: None, bool: None, bs: None,
                l: Some(vec![AttributeValue {
                    b: None, bool: None, bs: None, l: None,
                    m: Some(tasks_hash), n: None, ns: None,
                    null: None, s: None, ss: None,
                }]),
                m: None, n: None, ns: None, null: None, s: None,  ss: None,
            },
        );
        hash
    }
<span class="boring">}
</span></code></pre></pre>
<p>Assim a função <code>scan_with_one</code> fica:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_with_one() -&gt; ScanOutput {
    let hash = attr_values();

    ScanOutput {
        consumed_capacity: None,
        count: Some(1),
        items: Some(vec![hash]),
        last_evaluated_key: None,
        scanned_count: Some(1),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E podemos fazer a <code>scan_with_two</code> ser:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_with_two() -&gt; ScanOutput {
        let hash = attr_values();

        ScanOutput {
            consumed_capacity: None,
            count: Some(2),
            items: Some(vec![hash.clone(), hash]),
            last_evaluated_key: None,
            scanned_count: Some(2),
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>E assim já implementamos o seguinte teste (lembre-se de adicionar a trait <code>Clone</code> a <code>TodoCard</code> e seus derivados):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn scanoutput_has_two_items() {
    let scan = scan_with_two();
    let todo = TodoCard {
        title: &quot;title&quot;.to_string(),
        description: &quot;description&quot;.to_string(),
        state: State::Done,
        id: Some(uuid::Uuid::parse_str(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;).unwrap()),
        owner: uuid::Uuid::parse_str(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;).unwrap(),
        tasks: vec![Task {
            is_done: true,
            title: &quot;blob&quot;.to_string(),
        }],
    };
    let todos = vec![todo.clone(), todo];

    assert_eq!(scanoutput_to_todocards(scan), todos)
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso teste falha e agora nos permite modificar a função <code>scanoutput_to_todocards</code> para retornar um vetor com todos os <code>TodoCard</code>s contidos em <code>ScanOutput</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scanoutput_to_todocards(scan: ScanOutput) -&gt; Vec&lt;TodoCard&gt; {
    scan.items.unwrap()
        .into_iter()
        .map(|item| TodoCard {
            id: Some(uuid::Uuid::parse_str(&amp;item.get(&quot;id&quot;).unwrap().s.clone().unwrap()).unwrap()),
            owner: uuid::Uuid::parse_str(&amp;item.get(&quot;owner&quot;).unwrap().s.clone().unwrap()).unwrap(),
            title: item.get(&quot;title&quot;).unwrap().s.clone().unwrap(),
            description: item.get(&quot;description&quot;).unwrap().s.clone().unwrap(),
            state: State::from(item.get(&quot;state&quot;).unwrap().s.clone().unwrap()),
            tasks: item.get(&quot;tasks&quot;).unwrap().l.clone().unwrap()
                .iter()
                .map(|t| Task {
                    title: t.clone().m.unwrap().get(&quot;title&quot;)
                        .unwrap().s.clone().unwrap(),
                    is_done: t.clone().m.unwrap().get(&quot;is_done&quot;)
                        .unwrap().bool.clone().unwrap(),
                })
                .collect::&lt;Vec&lt;Task&gt;&gt;(),
        })
        .collect::&lt;Vec&lt;TodoCard&gt;&gt;()
}
<span class="boring">}
</span></code></pre></pre>
<p>A mudança que fizemos é bastante simples. Ela simplesmente consiste em transformar a variável <code>item</code> em um argumento da closure de <code>map</code>. Dessa forma, scan vira um iterável com <code>scan.items.unwrap().into_iter()</code> e, depois do <code>map</code>, colecionamos todos os valores com <code>.collect::&lt;Vec&lt;TodoCard&gt;&gt;()</code>. Pronto, <code>adapter</code> feito. Agora podemos utilizar esse <code>adapter</code> na função <code>get_todos</code>. Para testar a mudança, podemos executar a aplicação novamente e testar:</p>
<p><img src="../imagens/get_todos.png" alt="Obtendo todos nossos TodoCards." /></p>
<p>No próximo capítulo, vamos parar um pouco com a criação de endpoints e entender melhor como tornar nosso serviço mais viável para produção</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../part-1/02-create.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../part-1/04-serving.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../part-1/02-create.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../part-1/04-serving.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
