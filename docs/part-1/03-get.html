<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Obtendo todas as Todo Cards inseridas - Desenvolvimento Web em Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li class="chapter-item expanded "><a href="../intro/1-about.html"><strong aria-hidden="true">2.</strong> Sobre autora</a></li><li class="chapter-item expanded "><a href="../intro/2-Audience.html"><strong aria-hidden="true">3.</strong> Público alvo</a></li><li class="chapter-item expanded "><a href="../intro/3-book.html"><strong aria-hidden="true">4.</strong> Como o livro está organizado</a></li><li class="chapter-item expanded "><a href="../intro/4-setup.html"><strong aria-hidden="true">5.</strong> Instalando Rust</a></li><li class="chapter-item expanded "><a href="../intro/5-exercício.html"><strong aria-hidden="true">6.</strong> Exercício Maior Produto de uma Série</a></li><li class="chapter-item expanded "><a href="../part-1/00-capa.html"><strong aria-hidden="true">7.</strong> Todo Server com Actix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-1/01-ping-pong.html"><strong aria-hidden="true">7.1.</strong> Configurando os primeiros endpoints</a></li><li class="chapter-item expanded "><a href="../part-1/02-create.html"><strong aria-hidden="true">7.2.</strong> Criando Tarefas</a></li><li class="chapter-item expanded "><a href="../part-1/03-get.html" class="active"><strong aria-hidden="true">7.3.</strong> Obtendo todas as Todo Cards inseridas</a></li><li class="chapter-item expanded "><a href="../part-1/04-serving.html"><strong aria-hidden="true">7.4.</strong> Tornam nosso serviço mais realístico</a></li><li class="chapter-item expanded "><a href="../part-1/05-auth.html"><strong aria-hidden="true">7.5.</strong> Autenticação</a></li><li class="chapter-item expanded "><a href="../part-1/06-middleware.html"><strong aria-hidden="true">7.6.</strong> Exigindo Autenticação através de middlewares</a></li><li class="chapter-item expanded "><a href="../part-1/07-ci.html"><strong aria-hidden="true">7.7.</strong> Configurando um CI</a></li><li class="chapter-item expanded "><a href="../part-1/08-conclusao.html"><strong aria-hidden="true">7.8.</strong> Concluindo o serviço</a></li></ol></li><li class="chapter-item expanded "><a href="../part-2/00-capa.html"><strong aria-hidden="true">8.</strong> GraphQL com Actix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-2/01-ping-gql.html"><strong aria-hidden="true">8.1.</strong> Configurando o GraphQL</a></li><li class="chapter-item expanded "><a href="../part-2/02-bestprices.html"><strong aria-hidden="true">8.2.</strong> Query Best Prices</a></li><li class="chapter-item expanded "><a href="../part-2/03-recommendations.html"><strong aria-hidden="true">8.3.</strong> Query Recommendations</a></li><li class="chapter-item expanded "><a href="../part-2/04-redis.html"><strong aria-hidden="true">8.4.</strong> Adicionando Caching com Redis</a></li></ol></li><li class="chapter-item expanded "><a href="../part-3/00-capa.html"><strong aria-hidden="true">9.</strong> Frontend com WebAssembly e YewStack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-3/01-setup.html"><strong aria-hidden="true">9.1.</strong> Setup de WebAssembly</a></li><li class="chapter-item expanded "><a href="../part-3/02-iniciando.html"><strong aria-hidden="true">9.2.</strong> Iniciando o projeto</a></li><li class="chapter-item expanded "><a href="../part-3/03-best-prices.html"><strong aria-hidden="true">9.3.</strong> Componente de Best Prices</a></li><li class="chapter-item expanded "><a href="../part-3/04-recommendations.html"><strong aria-hidden="true">9.4.</strong> Componente de Recomendações</a></li><li class="chapter-item expanded "><a href="../part-3/05-route.html"><strong aria-hidden="true">9.5.</strong> Aplicando um Router</a></li></ol></li><li class="chapter-item expanded "><a href="../appendix.html"><strong aria-hidden="true">10.</strong> Appendix</a></li><li class="chapter-item expanded "><a href="../bibliografia.html"><strong aria-hidden="true">11.</strong> Bibliografia</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento Web em Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="obtendo-todas-as-todo-cards-inseridas"><a class="header" href="#obtendo-todas-as-todo-cards-inseridas">Obtendo todas as Todo Cards inseridas</a></h1>
<p>Existem muitas abordagens para como vamos adicionar um novo endpoint no nosso sistema, mas a abordagem que eu gostaria de tratar aqui é a de começar de cima para baixo, ou seja, criamos um endpoint <code>GET</code> que lista todas as <code>TodoCard</code> e nos retorna elas no formato Json. Dessa vez vamos começar escrevendo um teste para este novo endpoint:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod read_all_todos {
    use todo_server::todo_api_web::{
        routes::app_routes
    };

    use actix_web::{
        test, App,
        http::StatusCode,
    };

    #[actix_web::test]
    async fn test_todo_index_ok() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
    
        let req = test::TestRequest::get().uri(&quot;/api/index&quot;).to_request();
    
        let resp = test::call_service(&amp;mut app, req).await;
        assert_eq!(resp.status(), StatusCode::OK);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Felizmente, nosso teste falha retornanto um <code>NOT_FOUND</code> e nos obriga a implementar a nova rota, <code>index</code> em <code>src/todo_api_web/routes.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn app_routes(config: &amp;mut web::ServiceConfig) {
    config.service(
        web::scope(&quot;&quot;)
            .service(ping)
            .service(readiness)
            .service(create_todo)
            .service(show_all_todo)
            .default_service(web::to(|| HttpResponse::NotFound())),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que agora estamos utilizando uma nova função controller chamada de <code>show_all_todo</code>, ela precisa ser incorporada no escopo da função, fazemos isso através de <code>use crate::todo_api_web::controller::todo::show_all_todo</code> e recebemos um aviso de que ela não existe, assim devemos implementá-la no módulo <code>src/todo_api_web/controller/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo() -&gt; impl Responder {
    HttpResponse::Ok()
}
<span class="boring">}
</span></code></pre></pre>
<p>Como nosso teste checa apenas o retorno do status <code>200</code>, isso é suficiente. Nosso próximo passo é implementar um teste um pouco mais robusto. Esse teste consiste em garantir que o JSON recebido possua um vetor de tamanho 1 após um post em <code>api/create</code> ser enviado:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod read_all_todos {
    use serde_json::from_str;
    use todo_server::todo_api_web::{model::todo::TodoCardsResponse, routes::app_routes};

    use actix_web::{body, http::StatusCode, test, App};

    use crate::helpers::read_json;

    #[actix_web::test]
    async fn test_todo_index_ok() {
        // ...
    }

    #[actix_web::test]
    async fn test_todo_cards_count() {
        let mut app = test::init_service(App::new().configure(app_routes)).await;
    
        let post_req = test::TestRequest::post()
            .uri(&quot;/api/create&quot;)
            .insert_header((CONTENT_TYPE, ContentType::json()))
            .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
            .to_request();
        
        let _ = test::call_service(&amp;mut app, post_req).await;
        let get_req = test::TestRequest::get().uri(&quot;/api/index&quot;).to_request();
        let resp_body = test::call_service(&amp;mut app, get_req).await.into_body();
        let bytes = body::to_bytes(resp_body).await.unwrap();
        let todo_cards = from_str::&lt;TodoCardsResponse&gt;(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();
        
        assert_eq!(todo_cards.cards.len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para fazer isso vamos criar uma struct serializável para o formato Json. Essa struct se encontrará em <code>sr/todo_api_web/model/mod.rs</code> e se chamará <code>TodoCardsResponse</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct TodoCardsResponse {
    pub cards: Vec&lt;String&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que no momento não precisamos nos preocupar com o tipo de resposta, somente com a struct e seus campos. Agora precisamos fazer nosso controller retornar um vetor com uma String:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//src/todo_api_web/controller/todo.rs
#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo() -&gt; impl Responder {
    HttpResponse::Ok().content_type(ContentType::json()).body(
        serde_json::to_string(&amp;TodoCardsResponse {
            cards: vec![String::from(&quot;test&quot;)],
        })
        .expect(&quot;Failed to serialize todo cards&quot;)
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>Com este teste pronto, nosso próximo teste fica bastante simples, pois agora precisamos fazer um teste quase igual, mas que garanta que o retorno seja um <code>TodoCard</code> com as informações que postamos. Note que como este teste conterá um mock da resposta do banco de dados, podemos simplesmente adicionar um <code>Uuid</code> pré-determinado no mock. Vou criar uma função de teste, no módulo de <code>helpers</code> que retorna um vetor com uma <code>TodoCard</code>, <code>mock_get_todos</code>.</p>
<blockquote>
<p>Note que <code>TodoCard</code> não possui um id, assim temos duas opções: a primeira é criar um <code>TodoCardResponse</code>, que contém um Id e a segunda é modificarmos a <code>TodoCard</code> para conter um campo <code>id: Option&lt;Uuid&gt;</code>. Nós vamos seguir a segunda abordagem, cuja única mudança será adicionar <code>id: None,</code> no teste <code>converts_json_to_db</code> encontrado em <code>src/todo_api/adapter/mod.rs</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...
use todo_server::todo_api_web::model::todo::{State, Task, TodoCard};

// ...

pub fn mock_get_todos() -&gt; Vec&lt;TodoCard&gt; {
    vec![TodoCard {
        id: Some(uuid::Uuid::from_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
        title: String::from(&quot;This is a card&quot;),
        description: String::from(&quot;This is the description of the card&quot;),
        owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
        tasks: vec![
            Task {
                title: String::from(&quot;title 1&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 2&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 3&quot;),
                is_done: false,
            },
        ],
        state: State::Doing,
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>Com nossa função implementada, podemos criar o novo cenário de teste no submódulo <code>read_all_todos</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> #[actix_web::test]
async fn test_todo_cards_with_value() {
    let mut app = test::init_service(App::new().configure(app_routes)).await;

    let post_req = test::TestRequest::post()
        .uri(&quot;/api/create&quot;)
        .insert_header((CONTENT_TYPE, ContentType::json()))
        .set_payload(read_json(&quot;post_todo.json&quot;).as_bytes().to_owned())
        .to_request();

    let _ = test::call_service(&amp;mut app, post_req).await;
    let req = test::TestRequest::with_uri(&quot;/api/index&quot;).to_request();
    let resp_body = test::call_service(&amp;mut app, req).await.into_body();
    let bytes = body::to_bytes(resp_body).await.unwrap();
    let todo_cards: TodoCardsResponse =
        from_str(&amp;String::from_utf8(bytes.to_vec()).unwrap()).unwrap();

    assert_eq!(todo_cards.cards, mock_get_todos());
}
<span class="boring">}
</span></code></pre></pre>
<p>Veja que agora os tipos de <code>todo_cards.cards, mock_get_todos()</code> são incompatíveis, assim, devemos modificar a a struct <code>TodoCardsResponse</code> para:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, PartialEq)]
pub struct TodoCardsResponse {
    pub cards: Vec&lt;TodoCard&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Também é necessário, para fins de teste, implementarmos a trait <code>PartialEq</code> para todas as structs, e enums, derivadas de <code>TodoCardsResponse</code>. Com essa mudança, precisamos modificar a lógica do nosso controller já que agora é necessário que ele busque <code>TodoCard</code>s no banco. Faremos isso pela função <code>get_todos</code>, que retornará <code>Vec&lt;TodoCard&gt;</code>. Caso o <code>match</code> retorne, não podemos enviar um erro <code>500</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get(&quot;/api/index&quot;)]
pub async fn show_all_todo() -&gt; impl Responder {
    let client = get_client().await;
    let resp = get_todos(&amp;client).await;
    match resp {
        None =&gt; HttpResponse::InternalServerError().body(&quot;Failed to read todo cards&quot;),
        Some(cards) =&gt; HttpResponse::Ok()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;TodoCardsResponse { cards }).expect(ERROR_SERIALIZE)),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos implementar a função <code>get_todos</code>, mas antes vamos implementar a versão de teste (<code>feature = dynamo</code>) da função em <code>src/todo_api/db/todo.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;dynamo&quot;)]
pub async fn get_todos(_client: &amp;Client) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use crate::todo_api_web::model::todo::{State, Task};

    Some(vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(&quot;be75c4d8-5241-4f1c-8e85-ff380c041664&quot;).unwrap()),
        title: String::from(&quot;This is a card&quot;),
        description: String::from(&quot;This is the description of the card&quot;),
        owner: uuid::Uuid::parse_str(&quot;ae75c4d8-5241-4f1c-8e85-ff380c041442&quot;).unwrap(),
        tasks: vec![
            Task {
                title: String::from(&quot;title 1&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 2&quot;),
                is_done: true,
            },
            Task {
                title: String::from(&quot;title 3&quot;),
                is_done: false,
            },
        ],
        state: State::Doing,
    }])
}
<span class="boring">}
</span></code></pre></pre>
<p>Ao rodarmos o teste (comente o <code>#[cfg(feature = &quot;dynamo&quot;)]</code>), obtemos sucesso! Agora podemos partir para a leitura da base de dados de fato. Nossa função de <code>get_todos</code> vai precisar de algumas mudanças como receber um <code>client</code> e executar um <code>scan</code> no banco de dados na tabela <code>TODO_CARD_TABLE</code>. Em caso de <code>Err</code> no <code>match</code> retornamos <code>None</code> e em caso de sucesso precisamos passar a função por um <code>adapter</code> que transforma um <code>scan_output</code> em um vetor de <code>TodoCard</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = &quot;dynamo&quot;))]
pub async fn get_todos(client: &amp;Client) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    use crate::todo_api::adapter;

    let scan_output = client
        .scan()
        .table_name(TODO_CARD_TABLE.to_string())
        .limit(100i32)
        .send()
        .await;

    match scan_output {
        Ok(dbitems) =&gt; Some(adapter::scanoutput_to_todocards(
            dbitems.items().unwrap().to_vec(),
        )),
        Err(_) =&gt; None,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note que limitamos o scan a <code>100i32</code>, isso se deve ao fato de que o Dynamo não vai responder mais de 100 itens. Se você precisar de mais, é importante realizar filtros no scan. Antes de implementarmos o <code>adapter</code>, seria bom dar uma olhada em como é o resultado do scan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[
    {
        &quot;id&quot;: S(&quot;7d9b9e38-199e-46e1-939c-80e0b10e1674&quot;), 
        &quot;owner&quot;: S(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;), 
        &quot;description&quot;: S(&quot;descrition&quot;), 
        &quot;title&quot;: S(&quot;title&quot;), 
        &quot;tasks&quot;: L([M({&quot;title&quot;: S(&quot;blob&quot;), 
        &quot;is_done&quot;: Bool(true)})]), 
        &quot;state&quot;: S(&quot;Done&quot;)
    }
]
<span class="boring">}
</span></code></pre></pre>
<p>Onde S, L e Bool sao do tipo <code>aws_sdk_dynamodb::model::AttributeValue</code>. Agora podemos começar a implementar a função <code>scanoutput_to_todocards</code> e, para isso, vamos escrever o primeiro teste com apenas um <code>items</code> em <code>src/todo_api/adapters/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod scan_to_cards {
    use aws_sdk_dynamodb::model::AttributeValue;

    use super::scanoutput_to_todocards;
    use crate::todo_api_web::model::todo::{State, Task, TodoCard};

    fn scan_with_one() -&gt; Option&lt;Vec&lt;std::collections::HashMap&lt;String, AttributeValue&gt;&gt;&gt; {
        let tasks = vec![
            (&quot;is_done&quot;.to_string(), AttributeValue::Bool(true)),
            (&quot;title&quot;.to_string(), AttributeValue::S(&quot;blob&quot;.to_string())),
        ];
        let tasks_hash = HashMap::&lt;String, AttributeValue&gt;::from_iter(tasks);

        let values = vec![
            (&quot;title&quot;.to_string(), AttributeValue::S(&quot;title&quot;.to_string())),
            (
                &quot;description&quot;.to_string(),
                AttributeValue::S(&quot;description&quot;.to_string()),
            ),
            (
                &quot;owner&quot;.to_string(),
                AttributeValue::S(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;.to_string()),
            ),
            (
                &quot;id&quot;.to_string(),
                AttributeValue::S(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;.to_string()),
            ),
            (&quot;state&quot;.to_string(), AttributeValue::S(&quot;Done&quot;.to_string())),
            (
                &quot;tasks&quot;.to_string(),
                AttributeValue::L(vec![AttributeValue::M(tasks_hash)]),
            ),
        ];
        let hash = HashMap::&lt;String, AttributeValue&gt;::from_iter(values);

        Some(vec![hash])
    }

    #[test]
    fn scanoutput_has_one_item() {
        let scan = scan_with_one();
        let todos = vec![TodoCard {
            title: &quot;title&quot;.to_string(),
            description: &quot;description&quot;.to_string(),
            state: State::Done,
            id: Some(uuid::Uuid::parse_str(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;).unwrap()),
            owner: uuid::Uuid::parse_str(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;).unwrap(),
            tasks: vec![Task {
                is_done: true,
                title: &quot;blob&quot;.to_string(),
            }],
        }];

        assert_eq!(scanoutput_to_todocards(scan).unwrap(), todos)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora podemos finalmente implementar nossa função <code>scanoutput_to_todocards</code> para o caso de 1 <code>items</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scanoutput_to_todocards(scan: Vec&lt;HashMap&lt;String, AttributeValue&gt;&gt;) -&gt; Vec&lt;TodoCard&gt; {
    let item = scan[0].to_owned();
    let id = item.get(&quot;id&quot;).unwrap().as_s().unwrap();
    let owner = item.get(&quot;owner&quot;).unwrap().as_s().unwrap();
    let title = item.get(&quot;title&quot;).unwrap().as_s().unwrap();
    let description = item.get(&quot;description&quot;).unwrap().as_s().unwrap();
    let state = item.get(&quot;state&quot;).unwrap().as_s().unwrap();
    let tasks = item.get(&quot;tasks&quot;).unwrap().as_l().unwrap();

    vec![TodoCard {
        id: Some(uuid::Uuid::parse_str(id).unwrap()),
        owner: uuid::Uuid::parse_str(owner).unwrap(),
        title: title.to_string(),
        description: description.to_string(),
        state: State::from(state),
        tasks: tasks
            .iter()
            .map(|t| Task {
                title: t
                    .as_m()
                    .unwrap()
                    .get(&quot;title&quot;)
                    .unwrap()
                    .as_s()
                    .unwrap()
                    .to_string(),
                is_done: *t.as_m().unwrap().get(&quot;is_done&quot;).unwrap().as_bool().unwrap(),
            })
            .collect::&lt;Vec&lt;Task&gt;&gt;(),
    }]
}
<span class="boring">}
</span></code></pre></pre>
<p>Em <code>scanoutput_to_todocards</code>, estamos navegando por dentro dos tipos de <code>AttributeValue</code> e, quando o tipo é um <code>HashMap</code>, utilizamos <code>get</code>. Agora podemos testar o caso para um <code>scan</code> com dois conjuntos de <code>AttributeValue</code>. Para isso, vamos isolar a criação dos <code>HashMap</code> em <code>scan_with_one</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn attr_values() -&gt; HashMap&lt;String, AttributeValue&gt; {
    let mut tasks_hash = HashMap::new();
    tasks_hash.insert(&quot;is_done&quot;.to_string(), AttributeValue::Bool(true));
    tasks_hash.insert(&quot;title&quot;.to_string(), AttributeValue::S(&quot;blob&quot;.to_string()));
    let mut hash = HashMap::new();
    hash.insert(&quot;title&quot;.to_string(), AttributeValue::S(&quot;title&quot;.to_string()));
    hash.insert(
        &quot;description&quot;.to_string(),
        AttributeValue::S(&quot;description&quot;.to_string()),
    );
    hash.insert(
        &quot;owner&quot;.to_string(),
        AttributeValue::S(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;.to_string()),
    );
    hash.insert(
        &quot;id&quot;.to_string(),
        AttributeValue::S(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;.to_string()),
    );
    hash.insert(&quot;state&quot;.to_string(), AttributeValue::S(&quot;Done&quot;.to_string()));
    hash.insert(
        &quot;tasks&quot;.to_string(),
        AttributeValue::L(vec![AttributeValue::M(tasks_hash)]),
    );
    hash
}

<span class="boring">}
</span></code></pre></pre>
<p>Assim a função <code>scan_with_one</code> fica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_with_one() -&gt; ScanOutput {
    let hash = attr_values();

    let mut output = ScanOutput::builder().build();
    output.consumed_capacity = None;
    output.count = 1;
    output.items = Some(vec![hash]);
    output.scanned_count = 1;
    output.last_evaluated_key = None;

    output
}
<span class="boring">}
</span></code></pre></pre>
<p>E podemos fazer a <code>scan_with_two</code> ser:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_with_two() -&gt; ScanOutput {
    let hash = attr_values();
    let mut output = ScanOutput::builder().build();

    output.consumed_capacity = None;
    output.count = 2;
    output.items = Some(vec![hash.clone(), hash]);
    output.scanned_count = 2;
    output.last_evaluated_key = None;

    output
}
<span class="boring">}
</span></code></pre></pre>
<p>E assim já implementamos o seguinte teste (lembre-se de adicionar a trait <code>Clone</code> a <code>TodoCard</code> e seus derivados):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn scanoutput_has_two_items() {
    let scan = scan_with_two();
    let todo = TodoCard {
        title: &quot;title&quot;.to_string(),
        description: &quot;description&quot;.to_string(),
        state: State::Done,
        id: Some(uuid::Uuid::parse_str(&quot;646b670c-bb50-45a4-ba08-3ab684bc4e95&quot;).unwrap()),
        owner: uuid::Uuid::parse_str(&quot;90e700b0-2b9b-4c74-9285-f5fc94764995&quot;).unwrap(),
        tasks: vec![Task {
            is_done: true,
            title: &quot;blob&quot;.to_string(),
        }],
    };
    let todos = vec![todo.clone(), todo];

    assert_eq!(scanoutput_to_todocards(scan).unwrap(), todos)
}
<span class="boring">}
</span></code></pre></pre>
<p>Nosso teste falha e agora nos permite modificar a função <code>scanoutput_to_todocards</code> para retornar um vetor com todos os <code>TodoCard</code>s contidos em um scan output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn scanoutput_to_todocards(output: ScanOutput) -&gt; Option&lt;Vec&lt;TodoCard&gt;&gt; {
    Some(
        output
            .items()?
            .into_iter()
            .map(|item| {
                let id = item.get(&quot;id&quot;).unwrap().as_s().unwrap();
                let owner = item.get(&quot;owner&quot;).unwrap().as_s().unwrap();
                let title = item.get(&quot;title&quot;).unwrap().as_s().unwrap();
                let description = item.get(&quot;description&quot;).unwrap().as_s().unwrap();
                let state = item.get(&quot;state&quot;).unwrap().as_s().unwrap();
                let tasks = item.get(&quot;tasks&quot;).unwrap().as_l().unwrap();

                TodoCard {
                    id: Some(uuid::Uuid::parse_str(id).unwrap()),
                    owner: uuid::Uuid::parse_str(owner).unwrap(),
                    title: title.to_string(),
                    description: description.to_string(),
                    state: State::from(state),
                    tasks: tasks
                        .iter()
                        .map(|t| Task {
                            title: t
                                .as_m()
                                .unwrap()
                                .get(&quot;title&quot;)
                                .unwrap()
                                .as_s()
                                .unwrap()
                                .to_string(),
                            is_done: *t.as_m().unwrap().get(&quot;is_done&quot;).unwrap().as_bool().unwrap(),
                        })
                        .collect::&lt;Vec&lt;Task&gt;&gt;(),
                }
            })
            .collect(),
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>A mudança que fizemos é bastante simples. Ela simplesmente consiste em transformar a variável <code>item</code> em um argumento da closure de <code>map</code>. Dessa forma, scan vira um iterável com <code>scan.items.unwrap().into_iter()</code> e, depois do <code>map</code>, colecionamos todos os valores com <code>.collect::&lt;Vec&lt;TodoCard&gt;&gt;()</code>. Pronto, <code>adapter</code> feito. Agora podemos utilizar esse <code>adapter</code> na função <code>get_todos</code>. Para testar a mudança, podemos executar a aplicação novamente e testar:</p>
<p><img src="../imagens/get_todos.png" alt="Obtendo todos nossos TodoCards." /></p>
<p>No próximo capítulo, vamos parar um pouco com a criação de endpoints e entender melhor como tornar nosso serviço mais viável para produção</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-1/02-create.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../part-1/04-serving.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-1/02-create.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../part-1/04-serving.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
